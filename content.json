{"meta":{"title":"9032676's Blog","subtitle":"为探索而生","description":null,"author":9032676,"url":"http://blog.e7mc.com"},"pages":[{"title":"关于我","date":"2018-11-21T20:18:45.000Z","updated":"2019-07-24T17:39:13.934Z","comments":true,"path":"about-me/index.html","permalink":"http://blog.e7mc.com/about-me/index.html","excerpt":"","text":"曾在国内 Minecraft 圈子混迹多年，曾经参与过众多服务器建设，插件以及 Mod 等开发维护等工作，期间更认识了一众开发/生活上的好友，帮助提升我日后的开发水平，视野。同时也收获了成就感，让我重新展望未来。在此感谢曾经帮助过我，支持过我的一众好友！ @card{ 兴趣爱好 音游方面：Osu! Cytus。打粉饼大概有个接近两年了，途中还跑去魔改了下 Osu，而 Cytus 则是近期才开始打 太空科幻题材：Space Engineers EVE Stellaris Warframe 策略/生存/大生产：Minecraft Space Engineers Factorio 问我为什么没有FPS游戏？因为我是FPS鬼(cai)才(bi)好吧 死也要钻研一些有兴趣的问题 康好康的番/康好康的记录片 忠实车万厨，虽然并非原著 STG 玩家，但被其二次创作作品魅力深深折服，平时爱好听东方音乐喜好的社团/唱见有例如：凋叶棕，めらみぽっぷ，幽閉サテライト 等 咕咕咕？ } @column-3{ @card{ 主要开发语言 Haskell Kotlin Java NodeJS } @card{ 赞美IDE / Text Editor Intellij IDEA WebStorm Rider Vim / NeoVim VSCode Nodepad++ } @card{ 日后研究领域 Multi-threading programming and parallel JVM Specification Category and Type Theory Functional programming OpenGL and Linear algebra } } @column-3{ @card{ 职衔 / 职务 前 YourCraft 服务器技术组长负责日常开发及后台运维工作 Cthuwork 开发组成员负责维护服务器日常稳定 Minecraft 插件百科成员贡献脑洞？ BakaXL Dev 成员负责摸鱼 } @card{ 联系方式 QQ / TIM: 499723944 常用 Discord: @9032676#2654 Telegram: 9032676 Steam: 9032676 Email: 9032676@gmail.com } @card{ 康大佬们 TT菌的萌萌哒小屋 宅魂Kill的空间 ustc-zzzz’s blog 華落博客 } }"}],"posts":[{"title":"星际蜗牛折腾记 第一章：安装 ArchLinux","slug":"Archlinux-install-on-j1900","date":"2019-08-07T08:43:25.000Z","updated":"2019-08-08T05:02:08.664Z","comments":true,"path":"2019/08/07/Archlinux-install-on-j1900/","link":"","permalink":"http://blog.e7mc.com/2019/08/07/Archlinux-install-on-j1900/","excerpt":"","text":"最近本来有打算直接入手一台 Synology 主机的，但经过一个朋友的推介，最终我选择了星际蜗牛搭载 ArchLinux 作为 NAS 使用。 简介由于收到时店家已经为我预装好 Synology (黑群辉）了，本来不太打算怎么折腾直接使用的，但想了想为了日后更好的可自定义化最终还是使用了数天之后展开了重装的旅程（ArchLinux 真香。 配置 CPU: Intel(R) Celeron(R) CPU J1900 @ 1.99GHZ 内存: 8G DDR3 SSD: 16G 盘位数: 4个 网口: 2个 (双千兆) 配置看上去其实差不多也就这样，但查了下发现供电可能是雷区，毕竟如果4个盘满载运行的话稳定性可能成为疑问，但暂且来说目前还只有两个盘那就不管了。 准备工作备份这个就不用多说了，在安装之前有重要数据切记要备份。 参阅官方安装教程在安装的同时建议打开 官方安装教程 边参考边安装，以免出错。 制作 LiveCD 引导盘首先前往 ArchLinux 国内镜像站（我这里选用了清华源），然后寻找合适版本的 ArchLinux 镜像文件并使用工具刻录到 USB 上（由于我的电脑系统使用了 Ubuntu 18.04 + gnome 桌面环境，因此我使用了可视化的 Disks 工具进行 LiveCD 制作），该步骤由于网上已有不同环境下制造的教程，因此略过。 预处理步骤插入已制作好的 LiveCD现在我们把 LiveCD 插入到星际蜗牛主机上，并且在开机后进入 BIOS 界面，把启动项调整成我们刚插入到主机上的 USB （UEFI 方式），并在 F10 保存之后重新启动。 擦除 Synology 系统数据在完成上述步骤之后，成功地进入了 ArchLinux 的命令行环境，但由于店家本身已经预装了黑群辉，因此我们需要把残留的数据都给清空掉。 输入 fdisk -l 查看黑群辉系统所在分区（我这里查出来是 /dev/sda）。 使用 dd if=/dev/zero of=/dev/sda 写 0 擦除 /dev/sda 硬盘上的内容，并且在擦除完毕后直接使用 Ctrl+C 退出。 创建分区表现在使用 fdisk 与 parted （官方推荐这两个）等工具对 /dev/sda 建立新的分区表（我这里使用的是 cfdisk /dev/sda）： 首先要创建 EFI System Partition (ESP) 并作为引导文件储存用，这里我分出了 512M 给予 /dev/sda1 分区（官方建议 UEFI with GPT 是 260 ～ 512MB）。 然后的就是把剩余的空间全数分配给 /dev/sda2（这里你也可以预留一些大于 512MB 的空间分配给 /dev/sda3 作为 swap 区使用），并指定分区表类型为 Linux filesystem 即可。 保存并退出。 最终分区表如下：123Device Start End Sectors Size Type/dev/sda1 2048 1050623 1048576 512M EFI System/dev/sda2 1050624 31277198 30226575 14.4G Linux filesystem 格式化分区空间完成上述步骤之后，现在我们可以对上面两个分区进行格式化：12# mkfs.fat -F32 /dev/sda1# mkfs.ext4 /dev/sda2 创建 Swap 分区（可选）如果在创建分区表的步骤上已经为系统创建了 Swap 分区，那么现在可以使用如下指令创建 Swap 区：12# mkswap /dev/sda2# swapon /dev/sda2 挂载分区刚才我们已经对 /dev/sda 建立起了 /dev/sda1 与 /dev/sda2 这两个分区，现在我们开始把它们挂载到对应的位置上： 1234# mount /dev/sda2 /mnt# cd /mnt# mkdir boot# mount /dev/sda1 /boot 安装系统在确认挂载无误之后，我们现在就可以开始安装 ArchLinux 了！让我们看看接下来要干什么吧！ 配置 Pacman 镜像源（可略过，Live 模式默认启动所有镜像）由于 ArchLinux 采用了 Pacman 作为包管理系统并需要联网以安装一些基础包，而为了提升下载速度，所以在这个激动人心的安装过程之前先配置好我们的镜像列表： 可以先前往 官方的镜像列表生成器 生成你所在国家或地区的镜像服务器列表。 然后将它们复制粘贴到 /etc/pacman.d/mirrorlist 并保存即可。 安装 base 程序包组在确保联网状态可用的情况下，使用 pacstrap 指令去安装及下载，并且稍稍等待一段时间：123# ip link# ping archlinux.org# pacstrap /mnt base 不过要注意的是 base 包组在 Live 模式下安装并不包含所有工具，当然你也可以使用 pacstrap /mnt base-devel 安装基础开发者工具包组。 配置 fstab对于一些日后可能需要用到的硬盘或者分区，或者哪些分区需要开机的时候自动挂载，我们可能需要在 /etc/fstab 文件中指定出来。现在使用 genfstab 指令简单的生成一个配置文件并用 cat 查询以确认生成结果。12# genfstab -U /mnt &gt;&gt; /mnt/etc/fstab# cat /mnt/etc/fstab 移动至系统根目录我们当前进程还是以 LiveCD 下的引导系统作为根目录，因此我们需要把根目录移动到我们新创建好的系统中（/mnt 里）再进行操作：1# arch-chroot /mnt 调整系统内的个性化配置（可选）这里的配置较为次要，因此不作更详细的说明，详情可前往官方文档参阅： 时区设置创建软链接把 /etc/localtime 指向 /usr/share/zoneinfo/Region/City /etc/localtime 让系统读取：12# ln -sf /usr/share/zoneinfo/Asia/Hong_Kong /etc/localtime# hwclock --systohc 本地化设置创建本地化配置 /etc/locale.conf 并让系统读取，可使用 nano / vi 等方式进行编辑：1LANG=en_US.UTF-8 配置网络配置 hosts 文件现在我们编辑 /etc/hosts 文件，使 hosts 文件生效，下面是我的配置：123127.0.0.1 localhost::1 localhost127.0.1.1 90-ArchLinux 设置 Root 密码设置 Root 密码：1# passwd 设置启动引导在完成上述所有的步骤之后，现在来到最关键的一步了。在我们把系统配置完成之后，系统本身并不会自行引导并启动系统的，因此我们需要安装启动引导器，而官方给出了一整个 启动引导器列表 供我们选择。 在这里我选用了 Grub 作为我的引导器，因此下面会列出 Grub 的安装流程：123# pacman -S grub efibootmgr# grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB# grub-mkconfig -o /boot/grub/grub.cfg 使用 pacman 下载并安装 grub 与 efibootmgr 包 执行 grub-install 指令安装，我这里使用的是 UEFI 架构，因此设置 --target 为 x86_64-efi，而 efi 路径则设置为上面创建好的 /boot 路径（也为ESP）即可。 执行 grub-mkconfig 以生成 grub 的默认配置文件 重启主机进入安装系统在完成上述所有流程之后，我们现在可以输入 exit 或按下 Ctrl+D 退出 Chroot 环境，并执行 reboot（不要忘记移除我们搭载 Live 系统的 USB），进入新系统并使用设置好的 root 密码登陆，至此安装完毕！","categories":[],"tags":[{"name":"NAS","slug":"NAS","permalink":"http://blog.e7mc.com/tags/NAS/"},{"name":"硬盘分区","slug":"硬盘分区","permalink":"http://blog.e7mc.com/tags/硬盘分区/"},{"name":"ArchLinux","slug":"ArchLinux","permalink":"http://blog.e7mc.com/tags/ArchLinux/"},{"name":"系统安装","slug":"系统安装","permalink":"http://blog.e7mc.com/tags/系统安装/"},{"name":"RAID","slug":"RAID","permalink":"http://blog.e7mc.com/tags/RAID/"}]},{"title":"纯函数与副作用，以及如何对其建模","slug":"Pure-Function-and-Side-Effects","date":"2019-07-22T09:22:27.000Z","updated":"2019-07-25T15:46:23.915Z","comments":true,"path":"2019/07/22/Pure-Function-and-Side-Effects/","link":"","permalink":"http://blog.e7mc.com/2019/07/22/Pure-Function-and-Side-Effects/","excerpt":"","text":"纯函数是什么？副作用又是什么？它们会引致什么问题或有什么作用？相信对刚踏入函数式编程大门的人会对此抱有疑惑，本篇将会一一讲解。","categories":[],"tags":[{"name":"函数式编程","slug":"函数式编程","permalink":"http://blog.e7mc.com/tags/函数式编程/"},{"name":"Haskell","slug":"Haskell","permalink":"http://blog.e7mc.com/tags/Haskell/"}]},{"title":"一个 Haskeller 的范畴论入坑笔记 第二章：函数与其关系","slug":"Category-Theory-2","date":"2019-07-20T11:09:41.000Z","updated":"2019-08-07T04:20:06.879Z","comments":true,"path":"2019/07/20/Category-Theory-2/","link":"","permalink":"http://blog.e7mc.com/2019/07/20/Category-Theory-2/","excerpt":"","text":"前言要说到函数与类型，只要是个写带有类型系统的编程语言，都应该很熟悉，因为我们天天都会接触到。但是对于在范畴论上，或更广义地我们指在数学上的函数，以及类型的概念（因为数学上类型相等于只是集合，下面会提及），他们又或许又有不一样的面貌展现在我们的面前。 函数（Function）函数只是一个过程（或者说是一个黑箱），因为它只负责接受某些参数，然后处理，最后返回一些返回值。这或许是大部分写命令式编程语言的人心中对于函数所理解的了，即使是对于使用函数式编程开发的人，函数的概念多多少少与数学上也是有出入的。正因为在不同领域对函数的定义与概念都不一样，因此先让我们定义函数这个概念究竟是什么。 概念首先我们来回顾一下我在范畴论上一章对于态射（Morphism）与组合（Compose）的概念，且我们得知态射其实是可以被直接作为函数来看待的，在这里要再补充的是：对象（Object）在态射这个过程中不仅仅只是存在一个对象，而是可以有一个或多个对象在同时态射，就例如我们在数学上不仅可以定义两个整数为对象，然后把它们相加在一起（像 $5 + 8$ 这样），而加法本身也是个函数，而且这条函数本身并不仅能接受 $5$ 作为一个参数，然后返回 $8$，而是根据具体这条函数的定义域（Domain）来决定所接受的参数都有什么（例如在这我们设为 $\\forall x.x \\in \\mathbb Z$），再把集合内的所有整数加上另外一个整数（例如 map (+3) [1,2,3] 或 $x + 3$），最后输出到新的集合 $Y$ 上，正如下图这样： 集合 $X$ 是作为定义域（Domain）出现的，然后我们把 $X$ 当中的元素给态射到集合 $Y$，即像 / 值域（Image / Range）上，因此使用映射关系也可以公理化成这样：$X \\xrightarrow[f]{} Y$。 函数关系（Relationship of function）既然在概念上我们提到，函数之间的关系可以以集合映射的形式表示出来，因为这样可以更清晰地描述其中的关系。下面我们不妨来粗略地了解下函数的映射关系吧（详尽的定义可以参考维基）。 陪域与像（Codomain and Image）培域就相当于一个于一个函数 满射函数（Surjection function）满射的含义为完满，完全，所有的意思，也就是指对于在定义域集合上的所有对象（元素）， Epimorphism（Epic）单射函数（Injection function）Monomorphism（Monic）双射函数（Bijective function）透过观察在概念中 $X \\xrightarrow[f]{} Y$ 的例子我们得知，左边的集合（定义域）与右边集合（像 / 值域）的对象是全部对应起来的，因为我们上面的定义域为 $\\forall x.x \\in \\mathbb Z$（也就是对于所有 $x$，它们都属于整数这个集合），且是一一对应的，也就是 $1 \\to 2$，$2 \\to 3$，$3 \\to 6$ 这样，它们并不会形成类似多对一，一对多的关系。因此我们可以把这种关系称之为双射（满射且单射）。 反函数与原像（Inverse function and Preimages）函数可逆性（Function invertibility）并不属于函数范畴的态射关系多值函数（Multivalued function）偏函数（Partial function）同构（Isomorphism）同态（Homomorphism）","categories":[],"tags":[{"name":"范畴论","slug":"范畴论","permalink":"http://blog.e7mc.com/tags/范畴论/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://blog.e7mc.com/tags/函数式编程/"}]},{"title":"一个 Haskeller 的范畴论入坑笔记 第一章: 组合的本质","slug":"Category-Theory-1","date":"2019-07-19T11:13:32.000Z","updated":"2019-07-22T09:40:46.706Z","comments":true,"path":"2019/07/19/Category-Theory-1/","link":"","permalink":"http://blog.e7mc.com/2019/07/19/Category-Theory-1/","excerpt":"","text":"在入坑接触 Haskell 一段时间后，碰到很多类似 Functor Applicative Monad 等等这些诸如此类的 “魔法”，虽然有时候用是会用了，利用各种自定义的 Monad instance 也实际优化了 FP （Functional Programming） 工程上的代码，但是回头一看 Monad（单子）这个神奇的词，仔细想想又并不这么简单能够解释，一查发现其中又牵涉出 Monoid（么半群） Semigroup（半群） 等等这些群论以至于范畴论上的概念出来。于是乎为了能够 彻底弄清楚这一大堆东西 (mǎn zú hào qí xīn) （顺便记录下学习的过程），特意开了本篇作为学习笔记，也希望能够记录这个入坑 猫论 (Category Theory) 到入土的心路历程（笑。 概念（Concept） 研究范畴就是试图以“公理化”的方法抓住在各种相关连的“数学结构”中的共同特性，并以结构间的“结构保持函数”将这些结构相关起来。因此，对范畴论系统化的研究将允许任何一个此类数学结构的普遍结论由范畴的公理中证出。 范畴论这门学问，虽然分类上是属于数学的基础内容，但个人（以作为 Haskeller 的角度）反倒觉得像是一门 “数学上的抽象语言”。就如同上面引文提及：它负责对数学结构中的共同特性，加以公理化的形式把这一个个的数学结构连接起来。举个例子：就如同数学上最简单的加减乘除这些 “二元运算”，均能被视为是一种连接两个数学结构之间的一个公理化的连接，因此才被称为 “二元运算”。 对象与态射（Object and Morphism）通俗地讲，一个最简单的范畴结构可以由一个 对象（Object） 与 态射（Morphism） 组合而成的，一个对象可以是任何东西（例如一个自然数或是个英文字母等等），而态射就相等于对象变换的过程，然后把一个个对象之间像是加上了一个个箭头（Arrow）一样将它们逐一连接起来，首先由对象 $A$ 态射到对象 $B$ ，最终由对象 $B$ 再态射到对象 $C$，正如这样：$$ A \\to B \\to C $$ 从上面我们可以很清晰的看到似乎就只是加上了箭头作为对象之间的连接，就形成了一个包含三个对象，两次态射的范畴了。 组合（Composition）现在我们要提及到另一个重要的概念：组合（Composition）。上面对象与态射的小章节已经举出了一个简单的范畴例子，实际上我们可以为上面的态射给命名一下，例如改成这样：$$ A\\xrightarrow[f]{} B \\xrightarrow[g]{} C $$ 于是乎现在会更加直观地看到态射的名字了，我们设对象 $A$ 到 $B$ 的态射称为 $f$ ，而从对象 $B$ 到 $C$ 的态射为 $g$，最终由于对象 $A$ $B$ $C$ 会透过态射形成一个具备可传递性质的范畴，对象 $A$ 态射到 $C$ 的时候就会形成一个态射的组合（Composition of morphism），因此可以演变成这样：$$ A \\xrightarrow[g \\circ f]{} C $$ 我们看到上面由 $A$ 到 $C$ 的过程实际就是把 态射 $g$ 和 $f$ 给组合起来，形成一个新的复合态射，称之为 $g \\circ f$。 在 Haskell 上的函数组合众所周知很多图灵完全的编程语言上，函数不仅仅只能接受一个或多个参数，并且返回一个返回值，而是可以在满足下列至少任一条件： 一个函数接受一个或多个函数作为输入 输出一个函数 的情况下，作为一个普通函数使用，而这一概念也就是为人熟知的 高阶函数（Higher-order function）。那么当然在 Haskell 中也不例外，比方说我们现在有两条函数：12trim :: String -&gt; Stringlower :: String -&gt; String 分别是首先对字符串清除空格和后续的把字符串转换为全小写的函数。现在我们可以简单地把它们组合在一起，形成一个复合函数，在 Haskell 里面以 Point-free 形式写出来的代码大概像是这样：lower . trim，就已经成为了一个简单的函数组合了！ 组合的特性（Properties of Composition）组合（Composition）有两个非常重要的特性，在任何范畴内都必须满足这些特性，才能被称之为组合。 结合律（Associative Property）组合是可结合的，也就是指出一个二元运算（这里是组合）只要它们算子（态射）的位置没有被改变，那就不会对整个组合过程的结果产生影响，也就是即使我们给组合加上改变优先级的运算符（例如括号），也并不会改变整个过程的结果。现在给出三个对象，它们分别是 $f$，$g$，$h$。然后把它们组合到一起：$$(h \\circ g) \\circ f = h \\circ (g \\circ f) = h \\circ g \\circ f$$ 最终可以看出它们的结果均是恒等的。 单位元（Identity）单位元就如同一个特殊的单位（Unit），任何对象与其组合结果都会返回对象自身：$$ A \\xrightarrow[id_A]{} A $$ $$f \\circ id_A = id_A \\circ f = f $$ 但要切记，上面的单位元 $id_A$ 依旧是一种态射，只不过组合后的结果还是落入了与 $f$ 同一个范畴内。就如同 $2 * 1$一样（$1$ 是乘法单位元），它的运算结果永远都只会是整数（这里的范畴可以是整数乘法群，且群论上已定义了封闭性，所以结果不会是其他什么像是字符串，其他类型的自然数等等的这类东西），且最终它运算得出来的结果都会是等于 $2$，也就是等于自身，因此 $1$ 便符合了作为乘法单位元的特性。 组合的哲学（Philosophy of Composition）要讲到组合的本质，它不仅仅只是在 物理学 / 数学 领域下某些分支的概念，或是函数式编程领域公理化或简化实际问题的 “东西”。从计算机的角度出发的话，它表示成一个个的过程，例如说实际编写 Haskell / Java / C++ 等等这些 Higher-Level 编程语言的代码，经过编译这个过程，实际上看似也很类似于态射这个概念，然后把这些代码 “自然转换” 为机器读的懂的东西，最终再由承载执行该语言的虚拟机，或者是 Runtime 负责运行，这一系列的过程连接起来也就形成了一个组合，而这个组合最终代表的就是一个完整的范畴，甚至某种程度上我们可以说我们日常生活遇到的各种事情都可以是一个范畴，而不仅仅是一个集合。范畴本身不仅可以被当成一个分类，而且他还可以把多个小分类给 “连接” 起来，解决一个很复杂很困难的事。在计算机领域最为直接的例子就是现代 CPU 的架构，其逻辑或线路布局复杂程度显然相当的高，但还是分出了 ALU，CU，寄存器，各种总线 等等的这些概念，然后把它们组合在一起运行。其次也就是我们日常编写代码时，如果没有这样化简归纳成一个个范畴的概念，那么现在的程序员可能每时每刻都只能用二进制去编写程序了，导致编写一个程序的门槛不知道高了多少多少，计算机领域的发展也就十分局限了。 总结（Conclusion）以上便是本章节的内容了，本篇作为第一节可能会较少讲述实质在范畴论上的内容，而概念较多也是为了帮助自己和读者能够理解及学习到范畴论上的概念，作为日后深入范畴论的一个垫脚石。 外部链接（Outside Links）本文部分内容参考或引用至下列网页，也可供作为额外的延伸资源帮助阅读： 范畴论 - Wikipedia Category: The Essence of Composition - Bartosz Milewski","categories":[],"tags":[{"name":"范畴论","slug":"范畴论","permalink":"http://blog.e7mc.com/tags/范畴论/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://blog.e7mc.com/tags/函数式编程/"}]},{"title":"Codewars: Haskell Five Fundamental Monads","slug":"Codewars-Five-Fundamental-Monads","date":"2019-06-24T11:32:13.000Z","updated":"2019-06-25T13:24:24.478Z","comments":true,"path":"2019/06/24/Codewars-Five-Fundamental-Monads/","link":"","permalink":"http://blog.e7mc.com/2019/06/24/Codewars-Five-Fundamental-Monads/","excerpt":"","text":"This kata corresponds to Five-Fundamental-Monads in CodewarsDifficulty: 4 kyuTags: FUNDAMENTALS MONADS DATA STRUCTURES FUNCTIONAL PROGRAMMING QuestionsIn this kata we will implement five of the most fundamental monads. Newcomers to Haskell find monads to be one of the most intimidating concepts but on a basic level - they are not too difficult to understand. A datatype forms a monad if it is possible to complete the following definitions such that the monad laws (described below) hold. There’s nothing more to it! For a more intuitive understanding then there are a plethora of tutorials which use (sometimes wild) analogies to explain this concept.123class Monad m where return :: a -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b Monad laws123return x &gt;&gt;= f = f xm &gt;&gt;= return = m(m &gt;&gt;= f) &gt;&gt;= g = m &gt;&gt;= (\\x -&gt; f x &gt;&gt;= g) It turns out that many different types of computation can be encapsulated by monads. For example the Maybe monad encapsulates a computation which can fail and State a computation with mutable state. The five we will implement here are Identity, Maybe, State, Writer and Reader. Hint: https://www.haskell.org/haskellwiki/Monad_tutorials_timeline Note: Please feel free to contribute! Sources Code123456789101112131415161718192021222324252627282930313233343536373839404142&#123;-# LANGUAGE NoImplicitPrelude #-&#125;module Monads whereimport Prelude hiding (Monad, Identity, Maybe(..), State, Reader, Writer)import Data.Monoidclass Monad m where return :: a -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m bdata Identity a = Identity a deriving (Show, Eq)data Maybe a = Nothing | Just a deriving (Show, Eq)data State s a = State &#123;runState :: s -&gt; (a, s)&#125;data Reader s a = Reader &#123;runReader :: s -&gt; a &#125;data Writer w a = Writer &#123;runWriter :: (w, a)&#125;instance Monad Identity where return = undefined (Identity v) &gt;&gt;= f = undefinedinstance Monad Maybe where return = undefined Nothing &gt;&gt;= f = undefined (Just v) &gt;&gt;= f = undefinedinstance Monad (State s) where return = undefined (State g) &gt;&gt;= f = undefinedinstance Monad (Reader s) where return = undefined (Reader g) &gt;&gt;= f = undefinedinstance Monoid w =&gt; Monad (Writer w) where return = undefined (Writer (s, v)) &gt;&gt;= f = undefined How to solveIdentity MonadAbove all, we need to implement the Identity monad instance at first, according to the law of identity in Category Theory: which means for every object $x$, there exists a morphism $id_x : x \\mapsto x$ called the identity morphism for $x$, such that for every morphism $f : a \\mapsto x$ and every morphism $g : x \\mapsto b$, we have $id_x \\circ f = f$ and $g \\circ id_x = g$. Straightforwardly we can call this as a morphism (or function in a programming language) which always return itself, and for every morphism combine with any identity must be equals to morphism itself anyway. By looking at Monad typeclass defination:1234567class Applicative m =&gt; Monad (m :: * -&gt; *) where (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b (&gt;&gt;) :: m a -&gt; m b -&gt; m b return :: a -&gt; m a fail :: String -&gt; m a &#123;-# MINIMAL (&gt;&gt;=) #-&#125; -- Defined in ‘GHC.Base’ So, in Haskell we can implement identity instance like this:123instance Monad Identity where return = Identity (Identity v) &gt;&gt;= f = f v return function was return a Identity which accepted a parameter a implicitly, and as explicitly can be write like this: return a = Identity a &gt;&gt;= is a monad-binding operator function, means that (Identity v) was bound on function f, by looking at type definition of this function, which accept the parameter m a, (a -&gt; m b) and return the monad m b finally. So now let’s turn back to this instance, (Identity v) is the first parameter m a also f represents to (a -&gt; m b), after the (Identity v) is done the pattern-matching, by take the parameter v out and put it into f and finally return the monad m b, that’s it what we need! Maybe MonadAfter done the identity monad, we are learned about how to construct the simple monad in Haskell, but just the only identity? Not enough! So now I’ll start to talk about the next most useful monad in Haskell, the Maybe Monad. In this monad, defined two data types: Nothing and Just a, which Nothing does not accept any type parameter but Just a will accept a type parameter a here. So when we hold something just like an integer 1, they we can put it into Just 1, but when holding nothing, then we didn’t need to put anything into Just a, so we use Nothing to alternative that. So let’s implement return function on Maybe Monad first, it seems like the identity monad, but still have some differences. In this case, we need to specify the Nothing and Just, just take a look at the type definition of return function, it’s must provide a parameter a, then we can be wrapping it into Just a to becomes return = Just in instance. Second, after completed return function, to finish the &gt;&gt;= function, it’s also closed to the identity instance, but we know when we put a Nothing into f, there must always return Nothing, otherwise return the result moand from f, so here could be using pattern-matching to partition these two case. Finally the Maybe Monad likes:1234instance Monad Maybe where return = Just Nothing &gt;&gt;= f = Nothing (Just v) &gt;&gt;= f = f v State MonadReader MonadWriter MonadConclusionGreat thanks to Henry for fixing my noob English grammar problem!","categories":[],"tags":[{"name":"Haskell","slug":"Haskell","permalink":"http://blog.e7mc.com/tags/Haskell/"},{"name":"Monad","slug":"Monad","permalink":"http://blog.e7mc.com/tags/Monad/"},{"name":"Data Structures","slug":"Data-Structures","permalink":"http://blog.e7mc.com/tags/Data-Structures/"}]},{"title":"Java 泛型的本质 开篇","slug":"Java-generic-type-md","date":"2019-04-15T05:01:11.000Z","updated":"2019-07-22T09:42:09.757Z","comments":true,"path":"2019/04/15/Java-generic-type-md/","link":"","permalink":"http://blog.e7mc.com/2019/04/15/Java-generic-type-md/","excerpt":"","text":"提起泛型, 或许许多人在学习 Java 的时候就遇到了不少的问题, 又或者只会用基础的特性, 但有些更加高层次根本不知道怎么用, 又或是很容易混淆, 所以就有个想法来写一下关于泛型的一些内容, 接下来可能会用数章的篇幅去讲解下究竟何为泛型, 其中又能发挥些什么作用. 概念待填坑…","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.e7mc.com/tags/Java/"},{"name":"类型","slug":"类型","permalink":"http://blog.e7mc.com/tags/类型/"},{"name":"参数化类型","slug":"参数化类型","permalink":"http://blog.e7mc.com/tags/参数化类型/"}]},{"title":"记录一次在 Linux 下增加分区大小的过程","slug":"Linux-partition-sizes-modify","date":"2018-12-04T01:23:54.000Z","updated":"2019-07-22T09:42:36.844Z","comments":true,"path":"2018/12/04/Linux-partition-sizes-modify/","link":"","permalink":"http://blog.e7mc.com/2018/12/04/Linux-partition-sizes-modify/","excerpt":"","text":"最近因为要开发一个 Android 项目，因此需要在系统上安装 AndroidStudio，安装途中却提示我 java.io.IOException: No space left on device，立刻就意识到分区空间不足了，因此进行了该次扩容。而我本身是双系统（Ubuntu 18.04 作为日常开发使用，而 Windows 10 作为游戏娱乐用），因此我要对 Ubuntu 下的分区进行扩容。 如何扩容 使用 GUI 工具：GParted （本篇文章不进行阐述） 利用 fdisk / parted / lvm 等指令进行扩容 提前准备 备份重要数据，很关键！！！ 因为涉及到 umount 卸载分区操作，请制作好 LiveCD（对应 Linux 版本的 USB 启动盘） 遇到其他问题请主动查阅相关资料 找出空间不足的分区首先使用 df -h | grep &quot;dev/sda&quot; 指令查看 /dev/sda 以下各个分区占用比12345 a9032676@90-Ubuntu  ~  df -h | grep &quot;sda&quot;/dev/sda10 22G 21G 96M 100% //dev/sda8 1.9G 467M 1.3G 27% /media/a9032676/b2b692f8-bdcf-46c1-9998-503b0970f5b3/dev/sda9 19G 2.8G 15G 16% /media/a9032676/9b5cdc3a-f296-490a-b329-6ae23acee7de/dev/sda7 4.7G 20M 4.4G 1% /media/a9032676/1bbfb6fa-f919-4460-86f9-5ced5a900ec8 可以得出挂载于 / 的根分区 /dev/sda10 空间严重不足，剩下 96MB。然后我们使用 sudo fdisk -l /dev/sda 指令查询 /dev/sda 下各分区大小及总和。123456789101112 a9032676@90-Ubuntu  ~  sudo fdisk -l /dev/sdaDisk /dev/sda: 232.9 GiB, 250059350016 bytes, 488397168 sectors/dev/sda1 * 2048 1126399 1124352 549M 7 HPFS/NTFS/exFAT/dev/sda2 1126400 383537151 382410752 182.4G 7 HPFS/NTFS/exFAT/dev/sda3 383539198 488396799 104857602 50G 5 Extended/dev/sda5 383539200 383928319 389120 190M 83 Linux/dev/sda6 383930368 387928063 3997696 1.9G 82 Linux swap / Solaris/dev/sda7 387930112 397928447 9998336 4.8G 83 Linux/dev/sda8 397930496 401928191 3997696 1.9G 83 Linux/dev/sda9 401930240 441927679 39997440 19.1G 83 Linux/dev/sda10 441929728 488396799 46467072 22.2G 83 Linux a9032676@90-Ubuntu  ~  可以看到这个盘大小总和是 232.9G，而由于双系统的缘故， /dev/sda1 与 /dev/sda2 这两个分区是 Windows 10 的，因此是 NTFS 文件系统。/dev/sda5 为 grub 预留分区，而扩展分区 /dev/sda3 则作为我 Ubuntu 系统所有文件的主分区，可以看见扇区从 383539198 横跨到 488396799，途中包含了 sda5 到 sda10 这几个分区，而他们都是 ext4 文件系统的逻辑分区，加起来刚刚好 50G。 查询分区挂载情况确定了是 /dev/sda10 分区空间不足后，我们利用 mount -l | grep &quot;/dev/sda&quot; 指令查看分区实际挂载情况。 12345 a9032676@90-Ubuntu  ~  sudo mount -l | grep &quot;/dev/sda&quot;/dev/sda10 on / type ext4 (rw,relatime,errors=remount-ro,data=ordered)/dev/sda8 on /media/a9032676/b2b692f8-bdcf-46c1-9998-503b0970f5b3 type ext4 (rw,nosuid,nodev,relatime,data=ordered,uhelper=udisks2)/dev/sda9 on /media/a9032676/9b5cdc3a-f296-490a-b329-6ae23acee7de type ext4 (rw,nosuid,nodev,relatime,data=ordered,uhelper=udisks2)/dev/sda7 on /media/a9032676/1bbfb6fa-f919-4460-86f9-5ced5a900ec8 type ext4 (rw,nosuid,nodev,relatime,data=ordered,uhelper=udisks2) 从以上情况总括出：这台电脑两个系统都是安装在了同一个盘上面（因为是 SSD），合计可用大小是 232.9G，而分给 Ubuntu 的总共有 50G，Windows 则占用了 182.4G（撇除系统保留的 549M）。但现在 Ubuntu 挂载在根目录的分区 /dev/sda10 已经所剩无几，因此我打算的是从 Windows 处 /dev/sda2 释放 30G 的空间为 /dev/sda10 增加容量。 开始调整 重启电脑，将系统更换成 Windows 10。 在【磁盘管理】处压缩 NTFS 卷/分区，释放已分配空间给予 Ubuntu 使用，这里我共计在 /dev/sda2 处压缩并腾出了共计 30G 的未分配空间。（本步骤不多作阐述，具体可参考：如何在 Windows 中对硬盘进行分区） 因为途中涉及根分区前后移动，因此必须要让本身处于 busy（忙碌） 状态的根分区先 unmount （卸载分区），否则会一直锁定着，无法移动。制作对应 Ubuntu 版本的 LiveCD（USB启动盘）。 重启电脑并插入刚刚制作好的 USB，切换系统到 USB 搭载的 Ubuntu 系统上。 进入系统后。于命令行内手动输入 sudo umount /dev/sda10，把我们的目标分区卸载掉，同时需要将扩展分区内的 Swap Space（交换空间）关闭掉：sudo swapoff -a。 然后使用 sudo fdisk /dev/sda 进入 fdisk 命令交互界面以调整分区： 123456789 a9032676@90-Ubuntu  ~  sudo fdisk /dev/sda[sudo] password for a9032676: Welcome to fdisk (util-linux 2.31.1).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help): 然后我们使用 p 指令查询分区情况，虽然上面已经查询过，但为了安全起见还是先确认一遍。 123456789101112131415161718Command (m for help): pDisk /dev/sda: 232.9 GiB, 250059350016 bytes, 488397168 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0xdefb6f09Device Boot Start End Sectors Size Id Type/dev/sda1 * 2048 1126399 1124352 549M 7 HPFS/NTFS/exFAT/dev/sda2 1126400 320622591 319496192 152.4G 7 HPFS/NTFS/exFAT/dev/sda3 383539198 488396799 104857602 50G 5 Extended/dev/sda5 383539200 383928319 389120 190M 83 Linux/dev/sda6 383930368 387928063 3997696 1.9G 82 Linux swap / Solaris/dev/sda7 387930112 397928447 9998336 4.8G 83 Linux/dev/sda8 397930496 401928191 3997696 1.9G 83 Linux/dev/sda9 401930240 441927679 39997440 19.1G 83 Linux/dev/sda10 441929728 488396799 46467072 22.2G 83 Linux 可以看到在 /dev/sda2 的扇尾 320622591 与 /dev/sda3 的扇头 383539198 之间差了 62916607 个 Blocks，刚好 30G，也就是我们之前在 Windows 上腾出来的空间。 接下来这一步很关键，由于在我们上面的分区里面，没分配空间是处于扩展分区 /dev/sda3 以及 /dev/sda10 的前面（左侧），而我们需要先将其移动到靠近我们的 /dev/sda10 分区右侧（也就是把 free space 移动到整个盘最后面）方可与 /dev/sda10 逻辑分区进行合并，因此我们需要用到 dd 这条指令去操作分区移动： 待补充 但由于我们这里的例子 /dev/sda10 本身已经处于整个盘的最后方，因此可以直接使用 fdisk 的 d 与 n 指令直接合并已经移动到 /dev/sda10 左侧旁的 free space，而省去了最后的从 /dev/sda10 左侧移动到其的右侧。 待补充 在一轮操作完成之后，再输入 p 查询分区表究竟是否有误，再三确认后输入 w 保存变更并退出。 待补充","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.e7mc.com/tags/Linux/"},{"name":"硬盘分区","slug":"硬盘分区","permalink":"http://blog.e7mc.com/tags/硬盘分区/"}]},{"title":"让 Lambda 特性使你的 Kotlin 代码更加优雅","slug":"Lambda-make-code-more-elegant-on-Kotlin","date":"2018-11-21T17:20:36.000Z","updated":"2019-07-22T09:43:19.555Z","comments":true,"path":"2018/11/22/Lambda-make-code-more-elegant-on-Kotlin/","link":"","permalink":"http://blog.e7mc.com/2018/11/22/Lambda-make-code-more-elegant-on-Kotlin/","excerpt":"","text":"相信近年来，也许有这么一批人会认为 Java 语法过于保守及传统，代码写起来就显得有点臃肿了，不直观也不方便，而相对于 Java 而言，Kotlin 虽然与 Java 同属 JVM 平台衍生出来的计算机语言，Kotlin 的语法却比起 Java 来讲有更大的语法自由度（这里仅从语法角度分析），因此我们得以很好地实现某些看起来更简洁更方便的写法，就如同我们今天要讲的主题：在 Kotlin 上让你的代码更加优雅。 开发环境System：Ubuntu 18.04IDE：IntelliJ IDEA 2018.2.5JDK version：1.8.0_181（Java 8）Kotlin version：1.3.10（Kotlin 1.3） DSL 是什么？概念阅读本篇文章要求读者应清晰地认识 DSL 的概念，以及 Kotlin Lambda 的思想。关于 DSL 可参考我择写的另外一篇文章： 对于 Kotlin 而言，DSL 的思维究竟可以对代码有什么实际帮助？如果你已经阅读过上面的文章，应该能够明白到 DSL 应在特定领域发挥作用的重要性，而在 Kotlin 上也是如此。如果你是使用 IntelliJ IDEA 作为你的 IDE，那么在你学习 Kotlin 的时候肯定会使用到内置的 Java to Kotlin converter（J2KC），也就是把复制后的 Java 的代码粘贴到 .kt 文件后自动转换成 Kotlin 代码，如下面 JavaFX 创建布局的示例： 原本的 Java 代码： 12345678910111213141516public void create() &#123; Label label = new Label(&quot;This is label&quot;); label.setStyle(&quot;-fx-font-weight: bold;&quot;); label.setTextFill(Color.web(&quot;0069B1&quot;)); Rectangle rectangle = new Rectangle(46.0, 18.0); rectangle.setArcHeight(10.0); rectangle.setArcWidth(10.0); rectangle.setFill(Color.web(&quot;#CCEEFF&quot;)); rectangle.setPadding(new Insets(2.0, 3.0, 2.0, 3.0)); StackPane stack = new StackPane(); stack.setHgap(10); stack.setVgap(10); stack.children.addAll(rectangle, label);&#125; 透过 J2KC 之后自动转换的 Kotlin 代码： 12345678910111213141516fun create() &#123; val label = Label(&quot;This is label&quot;) label.style(&quot;-fx-font-weight: bold;&quot;) label.textFill(Color.web(&quot;0069B1&quot;)) val rectangle = Rectangle(46.0, 18.0) rectangle.arcHeight(10.0) rectangle.arcWidth(10.0) rectangle.fill(Color.web(&quot;#CCEEFF&quot;)) rectangle.padding(Insets(2.0, 3.0, 2.0, 3.0)) val stack = StackPane() stack.hgap(10) stack.vgap(10) stack.children.addAll(rectangle, label)&#125; 我们来回顾下上面代码的转化过，首先 J2KC 分别自动将函数标签从 public void create() 简化成了 fun create()，而因为在 Java 里返回值为 void 而在 Kotlin 里的后置类型声明 fun create(): Unit 可以直接被简化掉。除此以外还有包含对局部变量类型声明直接简化成 var val 以及在创建新实例时把 new 关键词直接去除。当然 J2KC 还有很聪明的一点，也就是能够识别出以 get set 为开头的函数名，直接将其简化成像是对一个字段进行赋值一样，而且也将以 ; 为行结尾的符号也去掉了，看起来已经相当不错了。 美中不足转换过程虽然简单，但也足够粗暴，我们再来观察一下转换后的结果，可以看到 1234val stack = StackPane()stack.hgap(10)stack.vgap(10)stack.children.addAll(rectangle, label) stack.xxx 像这样的操作实在太繁琐，每设置一个值都得事先输入 stack.，而且看上去代码也会显得特别密集，怎么办呢？这部分就是接下来便是我们要解决的问题了。 如何优化善用 apply() 与 also() 函数像是上面这种情况，我们可以透过 Kotlin 上一个叫 apply() 的函数解决！这个函数位于 Kotlin 标准库内的 Standard.kt 文件里，下面我直接把这一段源码贴上来： 1234567891011/** * Calls the specified function [block] with `this` value as its receiver and returns `this` value. */@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; block() return this&#125; 源码分析对于何为扩展函数与泛型本篇并不多作阐述，具体可参考官方文档：Kotlin - ExtensionsKotlin - Generics 这个函数很简单，我们首先先看函数标签：public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T，意思大概就是一个带有型参 T 内联函数，并以这个型参作为扩展函数 apply 的目标，并且接受一个 T.() -&gt; Unit 的 Lambda 类型作为参数传入，最终返回型参实际值 T。可以看到其实最核心的部分其实是 T.() -&gt; Unit，也就是接受一个无参数无返回值的 Lambda，其作用就相当于是一个回调函数，而这个 Lambda 也是基于型参 T 扩展出来的函数。因此我们传入回调函数的时候就可以像这么写：example.apply {}，在 {} 之内的内容就是我们回调函数需要执行的代码了。 例子12345678910111213val example = Example()example.apply &#123; // 这里的 `this` 实际上指向的是 `example` 这个实例 this // 调用一条被定义在 `Example` 类下的函数实际上可以从 this.test() // 简化成这样，而类下方的字段则也是相同做法 test()&#125; 实际使用然后我们使用在之前提到的 JavaFX 例子上： 12345678910111213141516171819fun create() &#123; val label = Label(&quot;This is label&quot;).apply &#123; style(&quot;-fx-font-weight: bold;&quot;) textFill(Color.web(&quot;0069B1&quot;)) &#125; val rectangle = Rectangle(46.0, 18.0).apply &#123; arcHeight(10.0) arcWidth(10.0) fill(Color.web(&quot;#CCEEFF&quot;)) padding(Insets(2.0, 3.0, 2.0, 3.0)) &#125; val stack = StackPane().apply &#123; hgap(10) vgap(10) children.addAll(rectangle, label) &#125;&#125; 感觉不够？我们还可以改成这样： 12345678910111213141516171819fun create() &#123; val label = val rectangle = val stack = StackPane().apply &#123; hgap(10) vgap(10) children.addAll( Label(&quot;This is label&quot;).apply &#123; style(&quot;-fx-font-weight: bold;&quot;) textFill(Color.web(&quot;0069B1&quot;)) &#125;, Rectangle(46.0, 18.0).apply &#123; arcHeight(10.0) arcWidth(10.0) fill(Color.web(&quot;#CCEEFF&quot;)) padding(Insets(2.0, 3.0, 2.0, 3.0)) &#125;) &#125;&#125;","categories":[],"tags":[{"name":"DSL","slug":"DSL","permalink":"http://blog.e7mc.com/tags/DSL/"},{"name":"代码设计","slug":"代码设计","permalink":"http://blog.e7mc.com/tags/代码设计/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://blog.e7mc.com/tags/Kotlin/"},{"name":"Lambda","slug":"Lambda","permalink":"http://blog.e7mc.com/tags/Lambda/"}]},{"title":"DSL：解释与设计目的","slug":"DSL-explain-and-goals","date":"2018-11-21T14:29:41.000Z","updated":"2019-07-22T09:41:28.162Z","comments":true,"path":"2018/11/21/DSL-explain-and-goals/","link":"","permalink":"http://blog.e7mc.com/2018/11/21/DSL-explain-and-goals/","excerpt":"","text":"一直以来，对于 DSL 这个词大家应该是既熟悉而又陌生，熟悉的是它写起来像啥样，陌生的是他的本质到底是什么，而今天作为第一篇在博客发布的文章就想来探讨一下这个问题。 DSL 的本质与解释首先，我们来看看 Wiki 是怎么解释 DSL 的： A domain-specific language (DSL) is a computer language specialized to a particular application domain. This is in contrast to a general-purpose language (GPL), which is broadly applicable across domains （原文出处：Wiki: Domain-Specific Language） 而把上面择要翻译过来就是：DSL (领域特定语言) 是专注于某个应用程序领域的计算机语言，而对比起 GPL （通用程序设计语言，例如 Java / C / Python…），DSL 能够在特定的应用领域中具有更大的拓展性及其延伸性。看到这里可能还有部分人不明白这到底是怎么一回事，其实简单来说 DSL 就是为解决特定领域的事情而生的，如果曾经作为 Java 程序员，你可能会经常使用 Maven 跟 Gradle 这两款包管理器去管理你的依赖/库，而透过对比两者语法上更是大相径庭，例如 Maven 采用的是 XML 语法的标记语言，因此我们先来看一下在 Maven 引用依赖部分是怎么写的： 12345&lt;dependency&gt; &lt;groupId&gt;group&lt;/groupId&gt; &lt;artifactId&gt;project&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt; 而 Gradle 则是像这样: 123dependencies &#123; compile group: &quot;group&quot;, name: &quot;project&quot;, version: 1.0.0&#125; 从上述看到的两种包管理框架语法差别都很大，而 Gradle 对比起 Maven 而言则要更为简洁，而这是为什么呢？最主要的其实就是这两者各自采用了不同种类的语法，Maven 采用的是基于 GPL 的标记语言： GPML (General-purpose markup languages)，而 GPML 还包含了 XML YAML GML 等等。除此以外，我们想要在 Maven 里插入有关构建时执行的代码段（或是Task）是非常困难的，其 XML 语法的甚至都大大束缚了代码编写，例如 if switch 这一类流程控制的语法在 XML 上实现就显得非常困难或根本无法实现。由此可见，其实 Maven 虽然用了 XML，但其本身是基于 GPML 的，对于解决特定范畴的问题就显得特别的繁琐了。 而 Gradle 呢？除了继承自 Groovy 的语法外，其本身还具有一个特性：为解决 Java，Kotlin，Scala 等包问题管理而推出的一种独立框架，也就三基于 DSL 设计思想出来的产物，而相较于 Maven，Gradle 其本身就是为了解决特定领域的问题而生的，其本身语法上导入包更简洁，而且可以比 Maven 更方便解决插入构建期的代码段，解决了 Maven 一直以来难以实现的地方。 DSL 的设计目标DSL 的设计理应十分谨慎，在软件工程上，DSL 总是负责解决领域相关问题及应用于特定领域。一个良好的 DSL 语法设计可以有助于在特定领域更方便地使用，以至于提升开发效率。 以下给出在 Wiki 给出的三个设计重点的定义，而且均是有别于 GPL 的： domain-specific languages are less comprehensive.domain-specific languages are much more expressive in their domain.domain-specific languages should exhibit minimal redundancy. DSL 相较于 GPL 而言范用性要低，因为需要专注于单个特定领域 DSL 理应在特定领域上比基于 GPL 发挥的作用更大更广 DSL 应该要尽可能地将（语法设计）冗余部分最小化，更为简单 总结总括而言，虽然 GPL 出来的产物可以广泛地应用在不同领域上，例如序列化，上述的 Maven 包管理等，有些时候这类语言在解决某些领域上的特定问题就很困难。而 DSL 则可以解决某些特定领域的问题，而且提出该领域应用更优的解决方案，就如同上述的 Gradle，SQL 等。 延伸阅读 Domain-specific language - Wikipedia What is domain specific language? Anybody using it? And in what way? - StackOverflow Domain-Specific Languages - Jetbrains","categories":[],"tags":[{"name":"DSL","slug":"DSL","permalink":"http://blog.e7mc.com/tags/DSL/"},{"name":"代码设计","slug":"代码设计","permalink":"http://blog.e7mc.com/tags/代码设计/"}]}]}