{"meta":{"title":"9032676's Blog","subtitle":"为探索而生","description":null,"author":9032676,"url":"http://blog.e7mc.com"},"pages":[{"title":"关于我","date":"2018-11-21T20:18:45.000Z","updated":"2018-11-22T07:46:49.033Z","comments":true,"path":"about-me/index.html","permalink":"http://blog.e7mc.com/about-me/index.html","excerpt":"","text":"曾在国内 Minecraft 圈子混迹多年，曾经参与过众多服务器建设，插件以及 Mod 等开发维护等工作，期间更认识了一众开发/生活上的好友，帮助提升我日后的开发水平，视野。同时也收获了成就感，让我重新展望未来。在此感谢曾经帮助过我，支持过我的一众好友！ @card{ 兴趣爱好 音游方面：Osu! Cytus。打粉饼大概有个接近两年了，途中还跑去魔改了下 Osu，而 Cytus 则是近期才开始打 太空科幻题材：Space Engineers EVE Stellaris 策略/生存/大生产：Minecraft Space Engineers Factorio 问我为什么没有FPS游戏？因为我是FPS鬼(cai)才(bi)好吧 死也要钻研一些有兴趣的问题 康好康的番/康好康的记录片 忠实车万厨，虽然并非原著 STG 玩家，但被其二次创作作品魅力深深折服，平时爱好听东方音乐喜好的社团/唱见有例如：凋叶棕，めらみぽっぷ，幽閉サテライト 等 咕咕咕？ } @column-3{ @card{ 主要开发语言 NodeJS Kotlin Java C# } @card{ 赞美IDE / Text Editor Intellij IDEA WebStorm Rider Vim / NeoVim VSCode Nodepad++ } @card{ 日后研究领域 多线程与高并发 Java 字节码与 JVM 调优 C++ 重新开坑 OpenGL 以及 线性代数 } } @column-3{ @card{ 职衔 / 职务 前 YourCraft 服务器技术组长负责日常开发及后台运维工作 Cthuwork 开发组成员负责维护服务器日常稳定 Minecraft 插件百科成员贡献脑洞？ BakaXL Dev 成员负责摸鱼 } @card{ 联系方式 QQ / TIM: 499723944 常用 Discord: @9032676#2654 Telegram: 9032676 Steam: 9032676 Email: 9032676@gmail.com } @card{ 友情链接 TT菌的萌萌哒小屋 宅魂Kill的空间 ustc-zzzz’s blog 華落博客 } }"}],"posts":[{"title":"在 Kotlin 上让你的代码更加优雅","slug":"Kotlin_code_design_more_beautiful","date":"2018-11-21T17:20:36.000Z","updated":"2018-11-24T06:25:27.116Z","comments":true,"path":"2018/11/22/Kotlin_code_design_more_beautiful/","link":"","permalink":"http://blog.e7mc.com/2018/11/22/Kotlin_code_design_more_beautiful/","excerpt":"","text":"相信近年来，也许有这么一批人会认为 Java 语法过于保守及传统，代码写起来就显得有点臃肿了，不直观也不方便，而相对于 Java 而言，Kotlin 虽然与 Java 同属 JVM 平台衍生出来的计算机语言，Kotlin 的语法却比起 Java 来讲有更大的语法自由度（这里仅从语法角度分析），因此我们得以很好地实现某些看起来更简洁更方便的写法，就如同我们今天要讲的主题：在 Kotlin 上让你的代码更加优雅。 开发环境System：Ubuntu 18.04IDE：IntelliJ IDEA 2018.2.5JDK version：1.8.0_181（Java 8）Kotlin version：1.3.10（Kotlin 1.3） DSL 是什么？概念阅读本篇文章要求读者应清晰地认识 DSL 的概念，以及 Kotlin Lambda 的思想。关于 DSL 可参考我择写的另外一篇文章：DSL：解释与设计目的 对于 Kotlin 而言，DSL 的思维究竟可以对代码有什么实际帮助？如果你已经阅读过上面的文章，应该能够明白到 DSL 应在特定领域发挥作用的重要性，而在 Kotlin 上也是如此。如果你是使用 IntelliJ IDEA 作为你的 IDE，那么在你学习 Kotlin 的时候肯定会使用到内置的 Java to Kotlin converter（J2KC），也就是把复制后的 Java 的代码粘贴到 .kt 文件后自动转换成 Kotlin 代码，如下面 JavaFX 创建布局的示例： 原本的 Java 代码： 12345678910111213141516public void create() &#123; Label label = new Label(&quot;This is label&quot;); label.setStyle(&quot;-fx-font-weight: bold;&quot;); label.setTextFill(Color.web(&quot;0069B1&quot;)); Rectangle rectangle = new Rectangle(46.0, 18.0); rectangle.setArcHeight(10.0); rectangle.setArcWidth(10.0); rectangle.setFill(Color.web(&quot;#CCEEFF&quot;)); rectangle.setPadding(new Insets(2.0, 3.0, 2.0, 3.0)); StackPane stack = new StackPane(); stack.setHgap(10); stack.setVgap(10); stack.children.addAll(rectangle, label);&#125; 透过 J2KC 之后自动转换的 Kotlin 代码： 12345678910111213141516fun create() &#123; val label = Label(&quot;This is label&quot;) label.style(&quot;-fx-font-weight: bold;&quot;) label.textFill(Color.web(&quot;0069B1&quot;)) val rectangle = Rectangle(46.0, 18.0) rectangle.arcHeight(10.0) rectangle.arcWidth(10.0) rectangle.fill(Color.web(&quot;#CCEEFF&quot;)) rectangle.padding(Insets(2.0, 3.0, 2.0, 3.0)) val stack = StackPane() stack.hgap(10) stack.vgap(10) stack.children.addAll(rectangle, label)&#125; 我们来回顾下上面代码的转化过，首先 J2KC 分别自动将函数标签从 public void create() 简化成了 fun create()，而因为在 Java 里返回值为 void 而在 Kotlin 里的后置类型声明 fun create(): Unit 可以直接被简化掉。除此以外还有包含对局部变量类型声明直接简化成 var val 以及在创建新实例时把 new 关键词直接去除。当然 J2KC 还有很聪明的一点，也就是能够识别出以 get set 为开头的函数名，直接将其简化成像是对一个字段进行赋值一样，而且也将以 ; 为行结尾的符号也去掉了，看起来已经相当不错了。 美中不足转换过程虽然简单，但也足够粗暴，我们再来观察一下转换后的结果，可以看到 1234val stack = StackPane()stack.hgap(10)stack.vgap(10)stack.children.addAll(rectangle, label) stack.xxx 像这样的操作实在太繁琐，每设置一个值都得事先输入 stack.，而且看上去代码也会显得特别密集，怎么办呢？这部分就是接下来便是我们要解决的问题了。 如何优化善用 apply() 函数像是上面这种情况，我们可以透过 Kotlin 上一个叫 apply() 的函数解决！这个函数位于 Kotlin 标准库内的 Standard.kt 文件里，下面我直接把这一段源码贴上来： 1234567891011/** * Calls the specified function [block] with `this` value as its receiver and returns `this` value. */@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; block() return this&#125; 源码分析这个函数很简单，我们首先先看函数标签：public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T，意思大概就是一个带有型参 T 内联函数，并以这个型参作为扩展函数 apply 的目标，并且接受一个 T.() -&gt; Unit 的 Lambda 类型作为参数传入，最终返回型参实际值 T。可以看到其实最核心的部分其实是 T.() -&gt; Unit，也就是接受一个无参数无返回值的 Lambda，但这个 Lambda 是基于型参 T 扩展出来的函数。因此因为 T.apply(...): T 与 T.() -&gt; Unit 的作用之下可以让这个 apply() 函数高度泛化，适用于任何是以对象作为延伸的地方。","categories":[],"tags":[{"name":"DSL","slug":"DSL","permalink":"http://blog.e7mc.com/tags/DSL/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://blog.e7mc.com/tags/Kotlin/"},{"name":"Lambda","slug":"Lambda","permalink":"http://blog.e7mc.com/tags/Lambda/"}]},{"title":"DSL：解释与设计目的","slug":"DSL_explain_and_goals","date":"2018-11-21T14:29:41.000Z","updated":"2018-11-24T03:49:29.870Z","comments":true,"path":"2018/11/21/DSL_explain_and_goals/","link":"","permalink":"http://blog.e7mc.com/2018/11/21/DSL_explain_and_goals/","excerpt":"","text":"一直以来，对于 DSL 这个词大家应该是既熟悉而又陌生，熟悉的是它写起来像啥样，陌生的是他的本质到底是什么，而今天作为第一篇在博客发布的文章就想来探讨一下这个问题。 DSL 的本质与解释首先，我们来看看 Wiki 是怎么解释 DSL 的： A domain-specific language (DSL) is a computer language specialized to a particular application domain. This is in contrast to a general-purpose language (GPL), which is broadly applicable across domains （原文出处：Wiki: Domain-Specific Language） 而把上面择要翻译过来就是：DSL (领域特定语言) 是专注于某个应用程序领域的计算机语言，而对比起 GPL （通用程序设计语言，例如 Java / C / Python…），DSL 能够在特定的应用领域中具有更大的拓展性及其延伸性。看到这里可能还有部分人不明白这到底是怎么一回事，其实简单来说 DSL 就是为解决特定领域的事情而生的，如果曾经作为 Java 程序员，你可能会经常使用 Maven 跟 Gradle 这两款包管理器去管理你的依赖/库，而透过对比两者语法上更是大相径庭，例如 Maven 采用的是 XML 语法的标记语言，因此我们先来看一下在 Maven 引用依赖部分是怎么写的： 12345&lt;dependency&gt; &lt;groupId&gt;group&lt;/groupId&gt; &lt;artifactId&gt;project&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt; 而 Gradle 则是像这样: 123dependencies &#123; compile group: &quot;group&quot;, name: &quot;project&quot;, version: 1.0.0&#125; 从上述看到的两种包管理框架语法差别都很大，而 Gradle 对比起 Maven 而言则要更为简洁，而这是为什么呢？最主要的其实就是这两者各自采用了不同种类的语法，Maven 采用的是基于 GPL 的标记语言： GPML (General-purpose markup languages)，而 GPML 还包含了 XML YAML GML 等等。除此以外，我们想要在 Maven 里插入有关构建时执行的代码段（或是Task）是非常困难的，其 XML 语法的甚至都大大束缚了代码编写，例如 if switch 这一类流程控制的语法在 XML 上实现就显得非常困难或根本无法实现。由此可见，其实 Maven 虽然用了 XML，但其本身是基于 GPML 的，对于解决特定范畴的问题就显得特别的繁琐了。 而 Gradle 呢？除了继承自 Groovy 的语法外，其本身还具有一个特性：为解决 Java，Kotlin，Scala 等包问题管理而推出的一种独立框架，也就三基于 DSL 设计思想出来的产物，而相较于 Maven，Gradle 其本身就是为了解决特定领域的问题而生的，其本身语法上导入包更简洁，而且可以比 Maven 更方便解决插入构建期的代码段，解决了 Maven 一直以来难以实现的地方。 DSL 的设计目标DSL 的设计理应十分谨慎，在软件工程上，DSL 总是负责解决领域相关问题及应用于特定领域。一个良好的 DSL 语法设计可以有助于在特定领域更方便地使用，以至于提升开发效率。 以下给出在 Wiki 给出的三个设计重点的定义，而且均是有别于 GPL 的： 123domain-specific languages are less comprehensive.domain-specific languages are much more expressive in their domain.domain-specific languages should exhibit minimal redundancy. DSL 相较于 GPL 而言范用性要低，因为需要专注于单个特定领域 DSL 理应在特定领域上比基于 GPL 发挥的作用更大更广 DSL 应该要尽可能地将（语法设计）冗余部分最小化，更为简单 总结总括而言，虽然 GPL 出来的产物可以广泛地应用在不同领域上，例如序列化，上述的 Maven 包管理等，有些时候这类语言在解决某些领域上的特定问题就很困难。而 DSL 则可以解决某些特定领域的问题，而且提出该领域应用更优的解决方案，就如同上述的 Gradle，SQL 等。 延伸阅读 Domain-specific language - Wikipedia What is domain specific language? Anybody using it? And in what way? - StackOverflow Domain-Specific Languages - Jetbrains","categories":[],"tags":[{"name":"DSL","slug":"DSL","permalink":"http://blog.e7mc.com/tags/DSL/"},{"name":"Code Design","slug":"Code-Design","permalink":"http://blog.e7mc.com/tags/Code-Design/"}]}]}