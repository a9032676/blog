<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>9032676&#39;s Blog</title>
  
  <subtitle>为探索而生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.e7mc.com/"/>
  <updated>2019-06-25T10:22:51.261Z</updated>
  <id>http://blog.e7mc.com/</id>
  
  <author>
    <name>9032676</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Codewars: Haskell Five Fundamental Monads</title>
    <link href="http://blog.e7mc.com/2019/06/24/Codewars-Five-Fundamental-Monads/"/>
    <id>http://blog.e7mc.com/2019/06/24/Codewars-Five-Fundamental-Monads/</id>
    <published>2019-06-24T11:32:13.000Z</published>
    <updated>2019-06-25T10:22:51.261Z</updated>
    
    <content type="html"><![CDATA[<p>This kata corresponds to <a href="https://www.codewars.com/kata/547202bdf7587835d9000c46" target="_blank" rel="noopener">Five-Fundamental-Monads</a> in Codewars<br>Difficulty: 4 kyu<br>Tags: <code>FUNDAMENTALS</code> <code>MONADS</code> <code>DATA STRUCTURES</code> <code>FUNCTIONAL PROGRAMMING</code></p><h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2><p>In this kata we will implement five of the most fundamental monads.</p><p>Newcomers to Haskell find monads to be one of the most intimidating concepts but on a basic level - they are not too difficult to understand.</p><p>A datatype forms a monad if it is possible to complete the following definitions such that the monad laws (described below) hold. There’s nothing more to it! For a more intuitive understanding then there are a plethora of tutorials which use (sometimes wild) analogies to explain this concept.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Monad m where</span><br><span class="line">    return :: a -&gt; m a</span><br><span class="line">    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br></pre></td></tr></table></figure></p><p>Monad laws<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return x &gt;&gt;= f = f x</span><br><span class="line">m &gt;&gt;= return = m</span><br><span class="line">(m &gt;&gt;= f) &gt;&gt;= g = m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</span><br></pre></td></tr></table></figure></p><p>It turns out that many different types of computation can be encapsulated by monads. For example the Maybe monad encapsulates a computation which can fail and State a computation with mutable state.</p><p>The five we will implement here are <code>Identity</code>, <code>Maybe</code>, <code>State</code>, <code>Writer</code> and <code>Reader</code>.</p><p>Hint: <a href="https://www.haskell.org/haskellwiki/Monad_tutorials_timeline" target="_blank" rel="noopener">https://www.haskell.org/haskellwiki/Monad_tutorials_timeline</a></p><p>Note: Please feel free to contribute!</p><h2 id="Sources-Code"><a href="#Sources-Code" class="headerlink" title="Sources Code"></a>Sources Code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#123;-# LANGUAGE NoImplicitPrelude #-&#125;</span><br><span class="line">module Monads where</span><br><span class="line"></span><br><span class="line">import Prelude hiding (Monad, Identity, Maybe(..), State, Reader, Writer)</span><br><span class="line">import Data.Monoid</span><br><span class="line"></span><br><span class="line">class Monad m where</span><br><span class="line">  return :: a -&gt; m a</span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line"></span><br><span class="line">data Identity a = Identity a</span><br><span class="line">  deriving (Show, Eq)</span><br><span class="line"></span><br><span class="line">data Maybe a = Nothing | Just a</span><br><span class="line">  deriving (Show, Eq)</span><br><span class="line"></span><br><span class="line">data State s a = State &#123;runState :: s -&gt; (a, s)&#125;</span><br><span class="line"></span><br><span class="line">data Reader s a = Reader &#123;runReader :: s -&gt; a &#125;</span><br><span class="line"></span><br><span class="line">data Writer w a = Writer &#123;runWriter :: (w, a)&#125;</span><br><span class="line"></span><br><span class="line">instance Monad Identity where</span><br><span class="line">  return = undefined</span><br><span class="line">  (Identity v) &gt;&gt;= f = undefined</span><br><span class="line"></span><br><span class="line">instance Monad Maybe where</span><br><span class="line">  return = undefined</span><br><span class="line">  Nothing &gt;&gt;= f = undefined</span><br><span class="line">  (Just v) &gt;&gt;= f = undefined</span><br><span class="line"></span><br><span class="line">instance Monad (State s) where</span><br><span class="line">  return = undefined</span><br><span class="line">  (State g) &gt;&gt;= f = undefined</span><br><span class="line"></span><br><span class="line">instance Monad (Reader s) where</span><br><span class="line">  return = undefined</span><br><span class="line">  (Reader g) &gt;&gt;= f = undefined</span><br><span class="line"></span><br><span class="line">instance Monoid w =&gt; Monad (Writer w) where</span><br><span class="line">  return = undefined</span><br><span class="line">  (Writer (s, v)) &gt;&gt;= f = undefined</span><br></pre></td></tr></table></figure><h2 id="How-to-solve"><a href="#How-to-solve" class="headerlink" title="How to solve"></a>How to solve</h2><h3 id="Identity-Monad"><a href="#Identity-Monad" class="headerlink" title="Identity Monad"></a>Identity Monad</h3><p>Above all, we need to implement the Identity monad instance at first, according to the law of identity in Category Theory: which means for every object $x$, there exists a morphism $id_x : x \mapsto x$ called the identity morphism for $x$, such that for every morphism $f : a \mapsto x$ and every morphism $g : x \mapsto b$, we have $id_x \circ f = f$ and $g \circ id_x = g$. Straightforwardly we can call this as a morphism (or function in a programming language) which always return itself, and for every morphism combine with any identity must be equals to morphism itself anyway.</p><p>By looking at Monad typeclass defination:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Applicative m =&gt; Monad (m :: * -&gt; *) where</span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">  (&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line">  return :: a -&gt; m a</span><br><span class="line">  fail :: String -&gt; m a</span><br><span class="line">  &#123;-# MINIMAL (&gt;&gt;=) #-&#125;</span><br><span class="line">      -- Defined in ‘GHC.Base’</span><br></pre></td></tr></table></figure></p><p>So, in Haskell we can implement identity instance like this:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance Monad Identity where</span><br><span class="line">  return = Identity</span><br><span class="line">  (Identity v) &gt;&gt;= f = f v</span><br></pre></td></tr></table></figure></p><p><code>return</code> function was return a Identity which accepted a parameter <code>a</code> implicitly, and as explicitly can be write like this: <code>return a = Identity a</code></p><p><code>&gt;&gt;=</code> is a monad-binding operator function, means that <code>(Identity v)</code> was bound on function <code>f</code>, by looking at type definition of this function, which accept the parameter <code>m a</code>, <code>(a -&gt; m b)</code> and return the monad <code>m b</code> finally. So now let’s turn back to this instance, <code>(Identity v)</code> is the first parameter <code>m a</code> also <code>f</code> represents to <code>(a -&gt; m b)</code>, after the <code>(Identity v)</code> is done the pattern-matching, by take the parameter <code>v</code> out and put it into <code>f</code> and finally return the monad <code>m b</code>, that’s it what we need!</p><h3 id="Maybe-Monad"><a href="#Maybe-Monad" class="headerlink" title="Maybe Monad"></a>Maybe Monad</h3><p>After done the identity monad, we are learned about how to construct the simple monad in Haskell, but just the only identity? Not enough! So now I’ll start to talk about the next most useful monad in Haskell, the <code>Maybe Monad</code>.</p><p>In this monad, defined two data types: <code>Nothing</code> and <code>Just a</code>, which <code>Nothing</code> does not accept any type parameter but <code>Just a</code> will accept a type parameter <code>a</code> there. So when we hold something just like an integer 1, they we can put it into <code>Just 1</code>, but when holding nothing, then we didn’t need to put anything into <code>Just a</code>, so we use <code>Nothing</code> to alternative that.</p><p>So let’s implement <code>return</code> function on <code>Maybe Monad</code> first, it seems like the identity monad, but still have some differences. In this case, we need to specify the <code>Nothing</code> and <code>Just</code>, just take a look at the type definition of <code>return</code> function, it’s must provide a parameter <code>a</code>, then we can be wrapping it into <code>Just a</code> to becomes <code>return = Just</code> in instance.</p><p>Second, after completed <code>return</code> function, to finish the <code>&gt;&gt;=</code> function, it’s also closed to the identity instance, but we know when we put a <code>Nothing</code> into <code>f</code>, there must always return <code>Nothing</code>, otherwise return the result moand from <code>f</code>, so here could be using pattern-matching to partition these two case.</p><p>Finally the <code>Maybe Monad</code> likes:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">instance Monad Maybe where</span><br><span class="line">  return = Just</span><br><span class="line">  Nothing &gt;&gt;= f = Nothing</span><br><span class="line">  (Just v) &gt;&gt;= f = f v</span><br></pre></td></tr></table></figure></p><h3 id="State-Monad"><a href="#State-Monad" class="headerlink" title="State Monad"></a>State Monad</h3><h3 id="Reader-Monad"><a href="#Reader-Monad" class="headerlink" title="Reader Monad"></a>Reader Monad</h3><h3 id="Writer-Monad"><a href="#Writer-Monad" class="headerlink" title="Writer Monad"></a>Writer Monad</h3><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Great thanks to Henry for fixing my low B English grammar problem!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This kata corresponds to &lt;a href=&quot;https://www.codewars.com/kata/547202bdf7587835d9000c46&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Five-Fundamental
      
    
    </summary>
    
    
      <category term="Haskell" scheme="http://blog.e7mc.com/tags/Haskell/"/>
    
      <category term="Monad" scheme="http://blog.e7mc.com/tags/Monad/"/>
    
      <category term="Data Structures" scheme="http://blog.e7mc.com/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>Java 泛型的本质 开篇</title>
    <link href="http://blog.e7mc.com/2019/04/15/Java-generic-type-md/"/>
    <id>http://blog.e7mc.com/2019/04/15/Java-generic-type-md/</id>
    <published>2019-04-15T05:01:11.000Z</published>
    <updated>2019-04-16T05:55:43.695Z</updated>
    
    <content type="html"><![CDATA[<p>提起泛型, 或许许多人在学习 Java 的时候就遇到了不少的问题, 又或者只会用基础的特性, 但有些更加高层次根本不知道怎么用, 又或是很容易混淆, 所以就有个想法来写一下关于泛型的一些内容, 接下来可能会用数章的篇幅去讲解下究竟何为泛型, 其中又能发挥些什么作用.</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;提起泛型, 或许许多人在学习 Java 的时候就遇到了不少的问题, 又或者只会用基础的特性, 但有些更加高层次根本不知道怎么用, 又或是很容易混淆, 所以就有个想法来写一下关于泛型的一些内容, 接下来可能会用数章的篇幅去讲解下究竟何为泛型, 其中又能发挥些什么作用.&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.e7mc.com/tags/Java/"/>
    
      <category term="Generic Type" scheme="http://blog.e7mc.com/tags/Generic-Type/"/>
    
  </entry>
  
  <entry>
    <title>记录一次在 Linux 下增加分区大小的过程</title>
    <link href="http://blog.e7mc.com/2018/12/04/linux_partitions_size_increase/"/>
    <id>http://blog.e7mc.com/2018/12/04/linux_partitions_size_increase/</id>
    <published>2018-12-04T01:23:54.000Z</published>
    <updated>2018-12-05T03:07:57.868Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为要开发一个 Android 项目，因此需要在系统上安装 AndroidStudio，安装途中却提示我 <code>java.io.IOException: No space left on device</code>，立刻就意识到分区空间不足了，因此进行了该次扩容。而我本身是双系统（Ubuntu 18.04 作为日常开发使用，而 Windows 10 作为游戏娱乐用），因此我要对 Ubuntu 下的分区进行扩容。</p><h2 id="如何扩容"><a href="#如何扩容" class="headerlink" title="如何扩容"></a>如何扩容</h2><ol><li>使用 GUI 工具：GParted （本篇文章不进行阐述）</li><li>利用 fdisk / parted / lvm 等指令进行扩容</li></ol><h2 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h2><ol><li>备份重要数据，很关键！！！</li><li>因为涉及到 <code>umount</code> 卸载分区操作，请制作好 LiveCD（对应 Linux 版本的 USB 启动盘）</li><li>遇到其他问题请主动查阅相关资料</li></ol><h2 id="找出空间不足的分区"><a href="#找出空间不足的分区" class="headerlink" title="找出空间不足的分区"></a>找出空间不足的分区</h2><p>首先使用 <code>df -h | grep &quot;dev/sda&quot;</code> 指令查看 <code>/dev/sda</code> 以下各个分区占用比<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> a9032676@90-Ubuntu  ~  df -h | grep &quot;sda&quot;</span><br><span class="line">/dev/sda10       22G   21G   96M 100% /</span><br><span class="line">/dev/sda8       1.9G  467M  1.3G  27% /media/a9032676/b2b692f8-bdcf-46c1-9998-503b0970f5b3</span><br><span class="line">/dev/sda9        19G  2.8G   15G  16% /media/a9032676/9b5cdc3a-f296-490a-b329-6ae23acee7de</span><br><span class="line">/dev/sda7       4.7G   20M  4.4G   1% /media/a9032676/1bbfb6fa-f919-4460-86f9-5ced5a900ec8</span><br></pre></td></tr></table></figure></p><p>可以得出挂载于 <code>/</code> 的根分区 <code>/dev/sda10</code> 空间严重不足，剩下 96MB。然后我们使用 <code>sudo fdisk -l /dev/sda</code> 指令查询 <code>/dev/sda</code> 下各分区大小及总和。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> a9032676@90-Ubuntu  ~  sudo fdisk -l /dev/sda</span><br><span class="line">Disk /dev/sda: 232.9 GiB, 250059350016 bytes, 488397168 sectors</span><br><span class="line">/dev/sda1  *         2048   1126399   1124352   549M  7 HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda2         1126400 383537151 382410752 182.4G  7 HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda3       383539198 488396799 104857602    50G  5 Extended</span><br><span class="line">/dev/sda5       383539200 383928319    389120   190M 83 Linux</span><br><span class="line">/dev/sda6       383930368 387928063   3997696   1.9G 82 Linux swap / Solaris</span><br><span class="line">/dev/sda7       387930112 397928447   9998336   4.8G 83 Linux</span><br><span class="line">/dev/sda8       397930496 401928191   3997696   1.9G 83 Linux</span><br><span class="line">/dev/sda9       401930240 441927679  39997440  19.1G 83 Linux</span><br><span class="line">/dev/sda10      441929728 488396799  46467072  22.2G 83 Linux</span><br><span class="line"> a9032676@90-Ubuntu  ~ </span><br></pre></td></tr></table></figure></p><p>可以看到这个盘大小总和是 232.9G，而由于双系统的缘故， <code>/dev/sda1</code> 与 <code>/dev/sda2</code> 这两个分区是 Windows 10 的，因此是 NTFS 文件系统。<code>/dev/sda5</code> 为 <code>grub</code> 预留分区，而扩展分区 <code>/dev/sda3</code> 则作为我 Ubuntu 系统所有文件的主分区，可以看见扇区从 <code>383539198</code> 横跨到 <code>488396799</code>，途中包含了 <code>sda5</code> 到 <code>sda10</code> 这几个分区，而他们都是 ext4 文件系统的逻辑分区，加起来刚刚好 50G。</p><h2 id="查询分区挂载情况"><a href="#查询分区挂载情况" class="headerlink" title="查询分区挂载情况"></a>查询分区挂载情况</h2><p>确定了是 <code>/dev/sda10</code> 分区空间不足后，我们利用 <code>mount -l | grep &quot;/dev/sda&quot;</code> 指令查看分区实际挂载情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> a9032676@90-Ubuntu  ~  sudo mount -l | grep &quot;/dev/sda&quot;</span><br><span class="line">/dev/sda10 on / type ext4 (rw,relatime,errors=remount-ro,data=ordered)</span><br><span class="line">/dev/sda8 on /media/a9032676/b2b692f8-bdcf-46c1-9998-503b0970f5b3 type ext4 (rw,nosuid,nodev,relatime,data=ordered,uhelper=udisks2)</span><br><span class="line">/dev/sda9 on /media/a9032676/9b5cdc3a-f296-490a-b329-6ae23acee7de type ext4 (rw,nosuid,nodev,relatime,data=ordered,uhelper=udisks2)</span><br><span class="line">/dev/sda7 on /media/a9032676/1bbfb6fa-f919-4460-86f9-5ced5a900ec8 type ext4 (rw,nosuid,nodev,relatime,data=ordered,uhelper=udisks2)</span><br></pre></td></tr></table></figure><p>从以上情况总括出：这台电脑两个系统都是安装在了同一个盘上面（因为是 SSD），合计可用大小是 232.9G，而分给 Ubuntu 的总共有 50G，Windows 则占用了 182.4G（撇除系统保留的 549M）。但现在 Ubuntu 挂载在根目录的分区 <code>/dev/sda10</code> 已经所剩无几，因此我打算的是从 Windows 处 <code>/dev/sda2</code> 释放 30G 的空间为 <code>/dev/sda10</code> 增加容量。</p><h2 id="开始调整"><a href="#开始调整" class="headerlink" title="开始调整"></a>开始调整</h2><ol><li><p>重启电脑，将系统更换成 Windows 10。</p></li><li><p>在【磁盘管理】处压缩 NTFS 卷/分区，释放已分配空间给予 Ubuntu 使用，这里我共计在 <code>/dev/sda2</code> 处压缩并腾出了共计 30G 的未分配空间。（本步骤不多作阐述，具体可参考：<a href="https://support.microsoft.com/zh-cn/help/944248" target="_blank" rel="noopener">如何在 Windows 中对硬盘进行分区</a>）</p></li><li><p>因为途中涉及根分区前后移动，因此必须要让本身处于 busy（忙碌） 状态的根分区先 <code>unmount</code> （卸载分区），否则会一直锁定着，无法移动。制作对应 Ubuntu 版本的 LiveCD（USB启动盘）。</p></li><li><p>重启电脑并插入刚刚制作好的 USB，切换系统到 USB 搭载的 Ubuntu 系统上。</p></li><li><p>进入系统后。于命令行内手动输入 <code>sudo umount /dev/sda10</code>，把我们的目标分区卸载掉，同时需要将扩展分区内的 Swap Space（交换空间）关闭掉：<code>sudo swapoff -a</code>。</p></li><li><p>然后使用 <code>sudo fdisk /dev/sda</code> 进入 fdisk 命令交互界面以调整分区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> a9032676@90-Ubuntu  ~  sudo fdisk /dev/sda</span><br><span class="line">[sudo] password for a9032676: </span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.31.1).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m for help):</span><br></pre></td></tr></table></figure></li><li><p>然后我们使用 <code>p</code> 指令查询分区情况，虽然上面已经查询过，但为了安全起见还是先确认一遍。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): p</span><br><span class="line">Disk /dev/sda: 232.9 GiB, 250059350016 bytes, 488397168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0xdefb6f09</span><br><span class="line"></span><br><span class="line">Device     Boot     Start       End   Sectors   Size Id Type</span><br><span class="line">/dev/sda1  *         2048   1126399   1124352   549M  7 HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda2         1126400 320622591 319496192 152.4G  7 HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda3       383539198 488396799 104857602    50G  5 Extended</span><br><span class="line">/dev/sda5       383539200 383928319    389120   190M 83 Linux</span><br><span class="line">/dev/sda6       383930368 387928063   3997696   1.9G 82 Linux swap / Solaris</span><br><span class="line">/dev/sda7       387930112 397928447   9998336   4.8G 83 Linux</span><br><span class="line">/dev/sda8       397930496 401928191   3997696   1.9G 83 Linux</span><br><span class="line">/dev/sda9       401930240 441927679  39997440  19.1G 83 Linux</span><br><span class="line">/dev/sda10      441929728 488396799  46467072  22.2G 83 Linux</span><br></pre></td></tr></table></figure><p>可以看到在 <code>/dev/sda2</code> 的扇尾 <code>320622591</code> 与 <code>/dev/sda3</code> 的扇头 <code>383539198</code> 之间差了 <code>62916607</code> 个 Blocks，刚好 30G，也就是我们之前在 Windows 上腾出来的空间。</p><ol start="8"><li>接下来这一步很关键，由于在我们上面的分区里面，没分配空间是处于扩展分区 <code>/dev/sda3</code> 以及 <code>/dev/sda10</code> 的前面（左侧），而我们需要先将其移动到靠近我们的 <code>/dev/sda10</code> 分区右侧（也就是把 free space 移动到整个盘最后面）方可与 <code>/dev/sda10</code> 逻辑分区进行合并，因此我们需要用到 <code>dd</code> 这条指令去操作分区移动：</li></ol><p>待补充</p><ol start="9"><li>但由于我们这里的例子 <code>/dev/sda10</code> 本身已经处于整个盘的最后方，因此可以直接使用 fdisk 的 <code>d</code> 与 <code>n</code> 指令直接合并已经移动到 <code>/dev/sda10</code> 左侧旁的 free space，而省去了最后的从 <code>/dev/sda10</code> 左侧移动到其的右侧。</li></ol><p>待补充</p><ol start="10"><li>在一轮操作完成之后，再输入 <code>p</code> 查询分区表究竟是否有误，再三确认后输入 <code>w</code> 保存变更并退出。</li></ol><p>待补充</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近因为要开发一个 Android 项目，因此需要在系统上安装 AndroidStudio，安装途中却提示我 &lt;code&gt;java.io.IOException: No space left on device&lt;/code&gt;，立刻就意识到分区空间不足了，因此进行了该次扩容。
      
    
    </summary>
    
    
      <category term="Ubuntu" scheme="http://blog.e7mc.com/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="http://blog.e7mc.com/tags/Linux/"/>
    
      <category term="Partition" scheme="http://blog.e7mc.com/tags/Partition/"/>
    
  </entry>
  
  <entry>
    <title>在 Kotlin 上让你的代码更加优雅</title>
    <link href="http://blog.e7mc.com/2018/11/22/Kotlin_code_design_more_beautiful/"/>
    <id>http://blog.e7mc.com/2018/11/22/Kotlin_code_design_more_beautiful/</id>
    <published>2018-11-21T17:20:36.000Z</published>
    <updated>2018-11-25T13:04:56.938Z</updated>
    
    <content type="html"><![CDATA[<p>相信近年来，也许有这么一批人会认为 Java 语法过于保守及传统，代码写起来就显得有点臃肿了，不直观也不方便，而相对于 Java 而言，Kotlin 虽然与 Java 同属 JVM 平台衍生出来的计算机语言，Kotlin 的语法却比起 Java 来讲有更大的语法自由度（这里仅从语法角度分析），因此我们得以很好地实现某些看起来更简洁更方便的写法，就如同我们今天要讲的主题：在 Kotlin 上让你的代码更加优雅。</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>System：Ubuntu 18.04<br>IDE：IntelliJ IDEA 2018.2.5<br>JDK version：1.8.0_181（Java 8）<br>Kotlin version：1.3.10（Kotlin 1.3）</p><h2 id="DSL-是什么？"><a href="#DSL-是什么？" class="headerlink" title="DSL 是什么？"></a>DSL 是什么？</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>阅读本篇文章要求读者应清晰地认识 DSL 的概念，以及 Kotlin Lambda 的思想。<br>关于 DSL 可参考我择写的另外一篇文章：<a href="/2018/11/21/DSL_explain_and_goals/" title="DSL：解释与设计目的">DSL：解释与设计目的</a></p><h3 id="对于-Kotlin-而言，DSL-的思维究竟可以对代码有什么实际帮助？"><a href="#对于-Kotlin-而言，DSL-的思维究竟可以对代码有什么实际帮助？" class="headerlink" title="对于 Kotlin 而言，DSL 的思维究竟可以对代码有什么实际帮助？"></a>对于 Kotlin 而言，DSL 的思维究竟可以对代码有什么实际帮助？</h3><p>如果你已经阅读过上面的文章，应该能够明白到 DSL 应在特定领域发挥作用的重要性，而在 Kotlin 上也是如此。如果你是使用 <code>IntelliJ IDEA</code> 作为你的 IDE，那么在你学习 Kotlin 的时候肯定会使用到内置的 <code>Java to Kotlin converter（J2KC）</code>，也就是把复制后的 Java 的代码粘贴到 <code>.kt</code> 文件后自动转换成 Kotlin 代码，如下面 JavaFX 创建布局的示例：</p><p>原本的 Java 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void create() &#123;</span><br><span class="line">    Label label = new Label(&quot;This is label&quot;);</span><br><span class="line">    label.setStyle(&quot;-fx-font-weight: bold;&quot;);</span><br><span class="line">    label.setTextFill(Color.web(&quot;0069B1&quot;));</span><br><span class="line"></span><br><span class="line">    Rectangle rectangle = new Rectangle(46.0, 18.0);</span><br><span class="line">    rectangle.setArcHeight(10.0);</span><br><span class="line">    rectangle.setArcWidth(10.0);</span><br><span class="line">    rectangle.setFill(Color.web(&quot;#CCEEFF&quot;));</span><br><span class="line">    rectangle.setPadding(new Insets(2.0, 3.0, 2.0, 3.0));</span><br><span class="line"></span><br><span class="line">    StackPane stack = new StackPane();</span><br><span class="line">    stack.setHgap(10);</span><br><span class="line">    stack.setVgap(10);</span><br><span class="line">    stack.children.addAll(rectangle, label);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>透过 <code>J2KC</code> 之后自动转换的 Kotlin 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun create() &#123;</span><br><span class="line">    val label = Label(&quot;This is label&quot;)</span><br><span class="line">    label.style(&quot;-fx-font-weight: bold;&quot;)</span><br><span class="line">    label.textFill(Color.web(&quot;0069B1&quot;))</span><br><span class="line"></span><br><span class="line">    val rectangle = Rectangle(46.0, 18.0)</span><br><span class="line">    rectangle.arcHeight(10.0)</span><br><span class="line">    rectangle.arcWidth(10.0)</span><br><span class="line">    rectangle.fill(Color.web(&quot;#CCEEFF&quot;))</span><br><span class="line">    rectangle.padding(Insets(2.0, 3.0, 2.0, 3.0))</span><br><span class="line"></span><br><span class="line">    val stack = StackPane()</span><br><span class="line">    stack.hgap(10)</span><br><span class="line">    stack.vgap(10)</span><br><span class="line">    stack.children.addAll(rectangle, label)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来回顾下上面代码的转化过，首先 <code>J2KC</code> 分别自动将函数标签从 <code>public void create()</code> 简化成了 <code>fun create()</code>，而因为在 Java 里返回值为 <code>void</code> 而在 Kotlin 里的后置类型声明 <code>fun create(): Unit</code> 可以直接被简化掉。除此以外还有包含对局部变量类型声明直接简化成 <code>var</code> <code>val</code> 以及在创建新实例时把 <code>new</code> 关键词直接去除。当然 <code>J2KC</code> 还有很聪明的一点，也就是能够识别出以 <code>get</code> <code>set</code> 为开头的函数名，直接将其简化成像是对一个字段进行赋值一样，而且也将以 <code>;</code> 为行结尾的符号也去掉了，看起来已经相当不错了。</p><h3 id="美中不足"><a href="#美中不足" class="headerlink" title="美中不足"></a>美中不足</h3><p>转换过程虽然简单，但也足够粗暴，我们再来观察一下转换后的结果，可以看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val stack = StackPane()</span><br><span class="line">stack.hgap(10)</span><br><span class="line">stack.vgap(10)</span><br><span class="line">stack.children.addAll(rectangle, label)</span><br></pre></td></tr></table></figure><p><code>stack.xxx</code> 像这样的操作实在太繁琐，每设置一个值都得事先输入 <code>stack.</code>，而且看上去代码也会显得特别密集，怎么办呢？这部分就是接下来便是我们要解决的问题了。</p><h2 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h2><h3 id="善用-apply-与-also-函数"><a href="#善用-apply-与-also-函数" class="headerlink" title="善用 apply() 与 also() 函数"></a>善用 apply() 与 also() 函数</h3><p>像是上面这种情况，我们可以透过 Kotlin 上一个叫 <code>apply()</code> 的函数解决！这个函数位于 Kotlin 标准库内的 <code>Standard.kt</code> 文件里，下面我直接把这一段源码贴上来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Calls the specified function [block] with `this` value as its receiver and returns `this` value.</span><br><span class="line"> */</span><br><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>对于何为扩展函数与泛型本篇并不多作阐述，具体可参考官方文档：<br><a href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="noopener">Kotlin - Extensions</a><br><a href="https://kotlinlang.org/docs/reference/generics.html" target="_blank" rel="noopener">Kotlin - Generics</a></p><p>这个函数很简单，我们首先先看函数标签：<code>public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T</code>，意思大概就是一个带有型参 T <a href="https://kotlinlang.org/docs/reference/inline-functions.html" target="_blank" rel="noopener">内联函数</a>，并以这个型参作为扩展函数 <code>apply</code> 的目标，并且接受一个 <code>T.() -&gt; Unit</code> 的 Lambda 类型作为参数传入，最终返回型参实际值 T。可以看到其实最核心的部分其实是 <code>T.() -&gt; Unit</code>，也就是接受一个无参数无返回值的 Lambda，其作用就相当于是一个回调函数，而这个 Lambda 也是基于型参 T 扩展出来的函数。因此我们传入回调函数的时候就可以像这么写：<code>example.apply {}</code>，在 <code>{}</code> 之内的内容就是我们回调函数需要执行的代码了。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val example = Example()</span><br><span class="line"></span><br><span class="line">example.apply &#123;</span><br><span class="line"></span><br><span class="line">    // 这里的 `this` 实际上指向的是 `example` 这个实例</span><br><span class="line">    this</span><br><span class="line"></span><br><span class="line">    // 调用一条被定义在 `Example` 类下的函数实际上可以从</span><br><span class="line">    this.test()</span><br><span class="line">    // 简化成这样，而类下方的字段则也是相同做法</span><br><span class="line">    test()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h4><p>然后我们使用在之前提到的 JavaFX 例子上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun create() &#123;</span><br><span class="line">    val label = Label(&quot;This is label&quot;).apply &#123;</span><br><span class="line">        style(&quot;-fx-font-weight: bold;&quot;)</span><br><span class="line">        textFill(Color.web(&quot;0069B1&quot;))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val rectangle = Rectangle(46.0, 18.0).apply &#123;</span><br><span class="line">        arcHeight(10.0)</span><br><span class="line">        arcWidth(10.0)</span><br><span class="line">        fill(Color.web(&quot;#CCEEFF&quot;))</span><br><span class="line">        padding(Insets(2.0, 3.0, 2.0, 3.0))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val stack = StackPane().apply &#123;</span><br><span class="line">        hgap(10)</span><br><span class="line">        vgap(10)</span><br><span class="line">        children.addAll(rectangle, label)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉不够？我们还可以改成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun create() &#123;</span><br><span class="line">    val label = </span><br><span class="line">    val rectangle = </span><br><span class="line">    val stack = StackPane().apply &#123;</span><br><span class="line">        hgap(10)</span><br><span class="line">        vgap(10)</span><br><span class="line">        children.addAll(</span><br><span class="line">            Label(&quot;This is label&quot;).apply &#123;</span><br><span class="line">            style(&quot;-fx-font-weight: bold;&quot;)</span><br><span class="line">            textFill(Color.web(&quot;0069B1&quot;))</span><br><span class="line">        &#125;,</span><br><span class="line">        Rectangle(46.0, 18.0).apply &#123;</span><br><span class="line">            arcHeight(10.0)</span><br><span class="line">            arcWidth(10.0)</span><br><span class="line">            fill(Color.web(&quot;#CCEEFF&quot;))</span><br><span class="line">            padding(Insets(2.0, 3.0, 2.0, 3.0))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相信近年来，也许有这么一批人会认为 Java 语法过于保守及传统，代码写起来就显得有点臃肿了，不直观也不方便，而相对于 Java 而言，Kotlin 虽然与 Java 同属 JVM 平台衍生出来的计算机语言，Kotlin 的语法却比起 Java 来讲有更大的语法自由度（这里
      
    
    </summary>
    
    
      <category term="DSL" scheme="http://blog.e7mc.com/tags/DSL/"/>
    
      <category term="Kotlin" scheme="http://blog.e7mc.com/tags/Kotlin/"/>
    
      <category term="Lambda" scheme="http://blog.e7mc.com/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>DSL：解释与设计目的</title>
    <link href="http://blog.e7mc.com/2018/11/21/DSL_explain_and_goals/"/>
    <id>http://blog.e7mc.com/2018/11/21/DSL_explain_and_goals/</id>
    <published>2018-11-21T14:29:41.000Z</published>
    <updated>2018-11-24T03:49:29.870Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来，对于 DSL 这个词大家应该是既熟悉而又陌生，熟悉的是它写起来像啥样，陌生的是他的本质到底是什么，而今天作为第一篇在博客发布的文章就想来探讨一下这个问题。</p><h2 id="DSL-的本质与解释"><a href="#DSL-的本质与解释" class="headerlink" title="DSL 的本质与解释"></a>DSL 的本质与解释</h2><p>首先，我们来看看 Wiki 是怎么解释 DSL 的：</p><blockquote><p>A domain-specific language (DSL) is a computer language specialized to a particular application domain. This is in contrast to a general-purpose language (GPL), which is broadly applicable across domains （原文出处：<a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="noopener">Wiki: Domain-Specific Language</a>）</p></blockquote><p>而把上面择要翻译过来就是：DSL (领域特定语言) 是专注于某个应用程序领域的计算机语言，而对比起 GPL （通用程序设计语言，例如 Java / C / Python…），DSL 能够在特定的应用领域中具有更大的拓展性及其延伸性。看到这里可能还有部分人不明白这到底是怎么一回事，其实简单来说 DSL 就是为解决特定领域的事情而生的，如果曾经作为 Java 程序员，你可能会经常使用 Maven 跟 Gradle 这两款包管理器去管理你的依赖/库，而透过对比两者语法上更是大相径庭，例如 Maven 采用的是 XML 语法的标记语言，因此我们先来看一下在 Maven 引用依赖部分是怎么写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;group&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;project&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>而 Gradle 则是像这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile group: &quot;group&quot;, name: &quot;project&quot;, version: 1.0.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述看到的两种包管理框架语法差别都很大，而 Gradle 对比起 Maven 而言则要更为简洁，而这是为什么呢？最主要的其实就是这两者各自采用了不同种类的语法，Maven 采用的是基于 GPL 的标记语言： <a href="https://en.wikipedia.org/wiki/General-purpose_markup_language" target="_blank" rel="noopener">GPML (General-purpose markup languages)</a>，而 <code>GPML</code> 还包含了 <code>XML</code> <code>YAML</code> <code>GML</code> 等等。除此以外，我们想要在 Maven 里插入有关构建时执行的代码段（或是Task）是非常困难的，其 XML 语法的甚至都大大束缚了代码编写，例如 <code>if</code> <code>switch</code> 这一类流程控制的语法在 XML 上实现就显得非常困难或根本无法实现。由此可见，其实 Maven 虽然用了 XML，但其本身是基于 GPML 的，对于解决特定范畴的问题就显得特别的繁琐了。</p><p>而 Gradle 呢？除了继承自 Groovy 的语法外，其本身还具有一个特性：为解决 Java，Kotlin，Scala 等包问题管理而推出的一种独立框架，也就三基于 DSL 设计思想出来的产物，而相较于 Maven，Gradle 其本身就是为了解决特定领域的问题而生的，其本身语法上导入包更简洁，而且可以比 Maven 更方便解决插入构建期的代码段，解决了 Maven 一直以来难以实现的地方。</p><h2 id="DSL-的设计目标"><a href="#DSL-的设计目标" class="headerlink" title="DSL 的设计目标"></a>DSL 的设计目标</h2><p>DSL 的设计理应十分谨慎，在软件工程上，DSL 总是负责解决领域相关问题及应用于特定领域。一个良好的 DSL 语法设计可以有助于在特定领域更方便地使用，以至于提升开发效率。</p><p>以下给出在 Wiki 给出的三个设计重点的定义，而且均是有别于 GPL 的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">domain-specific languages are less comprehensive.</span><br><span class="line">domain-specific languages are much more expressive in their domain.</span><br><span class="line">domain-specific languages should exhibit minimal redundancy.</span><br></pre></td></tr></table></figure><ul><li>DSL 相较于 GPL 而言范用性要低，因为需要专注于单个特定领域</li><li>DSL 理应在特定领域上比基于 GPL 发挥的作用更大更广</li><li>DSL 应该要尽可能地将（语法设计）冗余部分最小化，更为简单</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总括而言，虽然 GPL 出来的产物可以广泛地应用在不同领域上，例如序列化，上述的 Maven 包管理等，有些时候这类语言在解决某些领域上的特定问题就很困难。而 DSL 则可以解决某些特定领域的问题，而且提出该领域应用更优的解决方案，就如同上述的 Gradle，SQL 等。</p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="noopener">Domain-specific language - Wikipedia</a></li><li><a href="https://stackoverflow.com/questions/809574/what-is-domain-specific-language-anybody-using-it-and-in-what-way" target="_blank" rel="noopener">What is domain specific language? Anybody using it? And in what way? - StackOverflow</a></li><li><a href="https://www.jetbrains.com/mps/concepts/domain-specific-languages/" target="_blank" rel="noopener">Domain-Specific Languages - Jetbrains</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直以来，对于 DSL 这个词大家应该是既熟悉而又陌生，熟悉的是它写起来像啥样，陌生的是他的本质到底是什么，而今天作为第一篇在博客发布的文章就想来探讨一下这个问题。&lt;/p&gt;
&lt;h2 id=&quot;DSL-的本质与解释&quot;&gt;&lt;a href=&quot;#DSL-的本质与解释&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="DSL" scheme="http://blog.e7mc.com/tags/DSL/"/>
    
      <category term="Code Design" scheme="http://blog.e7mc.com/tags/Code-Design/"/>
    
  </entry>
  
</feed>
