<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>9032676&#39;s Blog</title>
  
  <subtitle>为探索而生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://a9032676.github.io/"/>
  <updated>2021-01-25T18:10:33.003Z</updated>
  <id>https://a9032676.github.io/</id>
  
  <author>
    <name>9032676</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Yoneda Lemma 的证明</title>
    <link href="https://a9032676.github.io/2021/01/22/Yoneda-Lemma/"/>
    <id>https://a9032676.github.io/2021/01/22/Yoneda-Lemma/</id>
    <published>2021-01-21T16:29:00.000Z</published>
    <updated>2021-01-25T18:10:33.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读须知">阅读须知</h2><ul><li>本篇文章面向人群是接触过 Category theory (范畴论) 以及 函数式编程，但未曾接触过 Yoneda Lemma (米田引理) 的读者食用。</li><li>通篇对于范畴论内的专有名词一律采用了英文词汇的形式表达，以防中文翻译各类型文章不统一，可能存在误导性。</li><li>文章中可能会存在一些 Agda 或 Haskell 语言的代码。没有相关知识不要紧，这只是给予相关领域的朋友一个直觉，用以辅助说明的。</li><li>这是我在知乎发布的第一篇文章，如对文章本身抱有任何疑问或是纠错欢迎提出，在此感谢各位！</li></ul><h2 id="前言">前言</h2><p><a href="https://en.wikipedia.org/wiki/Yoneda_lemma" target="_blank" rel="noopener">Yoneda Lemma (米田引理)</a> 是范畴论里面一个有关函子的态射实质上可被映射至固定对象上的重要结论，使我们得以透过该引理去推导出更多的定理出来，或者透过该引理观察某些结构上的微妙联系，而对应到计算机编程上亦可擦出火花，比如 Yoneda-embedding 与 CPS 变换 的关系等等。当然，本篇文章主要目的皆指在于引导读者一步步地推导出 Yoneda Lemma，以及给予相应的直觉。</p><p>由于 Yoneda Lemma 涉及到一些范畴论上的前置知识，因此在介绍 Yoneda Lemma 之前，首先从 hom-set 开始讲起。</p><h2 id="hom-set-hom-集合">Hom-set (Hom-集合)</h2><p>就函数而言，比方说从 <span class="math inline">\(\Bbb{Z}\)</span> 到 <span class="math inline">\(\Bbb{Z}\)</span> 之间的映射存在的可能不止有仅仅一条函数，它可能还存在着很多不同的函数，诸如 <span class="math inline">\(f,\ g,\ h, ... : \Bbb{Z} \to \Bbb{Z}\)</span> 等等。而由这一束函数所组成的集合，在范畴论中则被称之为 hom-set，即由 morphism(s) 所组成的集合。</p><p>由集合作为 object 所组成的 category 则被称之为 category of sets (集合范畴)，它们之间的 morphism(s) 即是 hom-set(s)，因此也可被称为 locally small category (局部小范畴)。</p><h3 id="定义">定义</h3><p>给定 object <span class="math inline">\(x,\ y\)</span> 于 locally small category <span class="math inline">\(C\)</span> 内，hom-set 则是所有从 object <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的 morphisms 所形成的搜集，记为 <span class="math inline">\(Hom_C(x,\ y)\)</span> （这里的 <span class="math inline">\(C\)</span> 为 category 的名字，或是 <span class="math inline">\(C(x,\ y)\)</span>，并且可省略地记为 <span class="math inline">\(Hom(x,\ y)\)</span>）。</p><h3 id="例子">例子</h3><p>设有 category <span class="math inline">\(C\)</span>，并且有： <br> 1. Objects：<span class="math inline">\(a,\ b \in obj(C)\)</span> <br> 2. Morphisms：<span class="math inline">\(f : a \to b\)</span>，<span class="math inline">\(g : a \to b\)</span>，<span class="math inline">\(h : a \to b\)</span></p><p><span class="math display">\[\xymatrix{a \ar@{-&gt;}[r]|-{f} \ar@/^1pc/@{-&gt;}[r]|-{g} \ar@/_1pc/@{-&gt;}[r]|-{h} &amp; b}\]</span></p><p>那么对于所有从 object <span class="math inline">\(a\)</span> 到 <span class="math inline">\(b\)</span> 的 morphisms，则记为 <span class="math inline">\(Hom_C(a,\ b)\)</span>，因此 <span class="math inline">\(f,\ g,\ h \in Hom_C(a,\ b)\)</span> 。</p><h2 id="hom-functor-hom-函子">Hom-functor (Hom-函子)</h2><p>由于 Yoneda Lemma 涉及到 hom-functor 的概念，因此 hom-set 肯定是不足够表达 Yoneda Lemma 含义的，我们还需要事先定义一下何为 hom-functor。而 hom-functor 共分为三种，分别是 covariant，contravariant 以及 mixed-variant hom-functor。</p><h3 id="covariant-hom-functor-协变-hom-函子">Covariant Hom-functor (协变 Hom-函子)</h3><p>我们都知道在 object 之间的 morphism(s) 所组成的集合是 hom-set。而对于 hom-functor 而言，通俗的说即是把 object 从原来的 category 中映射为 hom-set，并且把 morphisms 映射为 hom-sets 之间的 morphisms，进而建立 (covariant) hom-functor 的概念。</p><p>那么该如何构造出这一概念？对于这一疑问，我们可以先假设有 locally small category <span class="math inline">\(C\)</span> 以及一些 object，例如 <span class="math inline">\(X, A, B \in obj(C)\)</span>，然后 对于所有 <span class="math inline">\(X\)</span> 将作为 fixed object，并且分别有 <span class="math inline">\(X\)</span> 到 <span class="math inline">\(A\)</span> 以及 <span class="math inline">\(X\)</span> 到 <span class="math inline">\(B\)</span> 的 hom-sets。那么 (covariant) hom-functor 的样子是这样的：</p><p><span class="math display">\[\xymatrix{X \ar@/_/@{-&gt;}[r] \ar@{-&gt;}[rd] \ar@/^/@{-&gt;}[r] \ar@/_/@{-&gt;}[rd] \ar@/^/@{-&gt;}[rd] \ar@{-&gt;}[r] &amp; A \ar@/^/@{-&gt;}[rr]^{Covariant\ Hom-functor} &amp;  &amp; Hom(X,\ A) \\ &amp; B \ar@/^/@{-&gt;}[rr]^{Covariant\ Hom-functor} &amp;  &amp; Hom(X,\ B)}\]</span></p><p>从上图可见，当把 <span class="math inline">\(X\)</span> 给固定住后，object <span class="math inline">\(A\)</span> 将会映射为一个 <span class="math inline">\(Hom(X,\ A)\)</span>，<span class="math inline">\(B\)</span> 则被映射为 <span class="math inline">\(Hom(X,\ B)\)</span>，所以说只要把其中一边给固定住了 (这里固定了 hom-set 的左侧，而右侧可变的位置是协变位，因此称为 covariant hom-functor)，对于任何可变的 object (这里则指 <span class="math inline">\(A\)</span> 或 <span class="math inline">\(B\)</span>)，便可透过 (covariant) hom-functor 被映射成 hom-set 了。</p><p>当然，除了 object 以外，我们还需设想 morphisms 的情况。<br> 现在设 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 之间存在 morphism <span class="math inline">\(f\)</span>，那么对于 morphisms 而言，被映射至 <span class="math inline">\(Set\)</span> 之后便是这样：</p><p><span class="math display">\[\xymatrix{X \ar@/_/@{-&gt;}[r] \ar@{-&gt;}[rd] \ar@/^/@{-&gt;}[r] \ar@/_/@{-&gt;}[rd] \ar@/^/@{-&gt;}[rd] \ar@{-&gt;}[r] &amp; A \ar@/^/@{-&gt;}[rr]^{Covariant\ Hom-functor} \ar@{-&gt;}[d]^{f} &amp;  &amp; Hom(X,\ A) \ar@{-&gt;}[d]^{Hom(X,\ f)} \\ &amp; B \ar@/^/@{-&gt;}[rr]^{Covariant\ Hom-functor} &amp;  &amp; Hom(X,\ B)}\]</span></p><p>即 morphism <span class="math inline">\(f\)</span> 将被映射成 <span class="math inline">\(Hom(X,\ f)\)</span> (这里可以理解为 <span class="math inline">\(Hom(id_X,\ f)\)</span>)。</p><p>那么便可总结出规律，想要定义出 hom-functor 的概念，必须要知道到底 objects 是应该怎样被映射的，morphisms 亦应怎么被映射的，并且证明其满足 functor laws，最终便可定义出 covariant hom-functor 了。</p><h3 id="定义-1">定义</h3><p>设有 locally small category <span class="math inline">\(C\)</span>，固定 <span class="math inline">\(C\)</span> 下的 object <span class="math inline">\(X\)</span> 为 fixed object，有：<br> 1. Objects：<span class="math inline">\(A, B \in obj(C)\)</span>，<span class="math inline">\(Hom(X,\ A), Hom(X,\ B) \in obj(Set)\)</span><br> 2. Morphisms：<span class="math inline">\(f : A \to B, g : X \to A \in mor(C)\)</span>，<span class="math inline">\(Hom(X,\ f) \in mor(Set)\)</span></p><p>则 <span class="math inline">\(Hom(X, -) : C \to Set\)</span> 被称为 covariant hom-functor，并有如下图表：</p><p><span class="math display">\[\xymatrix{X \ar@{-&gt;}[r]^{g} \ar@{-&gt;}[rd]_{f \circ g} &amp; A \ar@{-&gt;}[d]^{f} \ar@/^/@{-&gt;}[rr]|-{Hom(X,-)} &amp;  &amp; Hom(X, A) \ar@{-&gt;}[d]_{Hom(X, f)} &amp; g \ar@{|-&gt;}[d] \\ &amp; B \ar@/^/@{-&gt;}[rr]|-{Hom(X,-)} &amp;  &amp; Hom(X, B) &amp; f \circ g}\]</span></p><p>而 covariant hom-functor 由以下两部分组成：<br> <span class="math inline">\(obj(C) \to obj(Set)\)</span>：<span class="math inline">\(\forall A \in obj(C)，有 A \mapsto Hom(X,\ A)\)</span><br> <span class="math inline">\(mor(C) \to mor(Set)\)</span>：<span class="math inline">\(\forall f \in A \to B\)</span>，<span class="math inline">\(g : Hom(X,\ A)\)</span>，有 <span class="math inline">\(g \mapsto f \circ g\)</span></p><p>Covariant hom-functor 本身结构是 <span class="math inline">\(F : C \to Set\)</span>，因此也可被称为 representable functor (可表函子) 。</p><h3 id="证明">证明</h3><p>Identity laws：<span class="math inline">\(Hom(X, id_A) = id_A\)</span><br> Composition laws：<span class="math inline">\(Hom(X,\ g \circ f) = Hom(X,\ g) \circ Hom(X,\ f)\)</span></p><p>由此可见 covariant hom-functor 满足 functor laws，因此它是一个 functor。</p><h3 id="contravariant-hom-functor-逆变-hom-函子">Contravariant Hom-functor (逆变 Hom-函子)</h3><p>而 contravariant hom-functor，只需把 covariant hom-functor 中的可变参数从协变改为逆变位置，即是 <span class="math inline">\(Hom(-, X)\)</span>，那么我们会得到一个 opposite category (因为把 morphisms 反转了)，那么即有：</p><p><span class="math display">\[\xymatrix{X &amp; A \ar@/^/@{-&gt;}[l] \ar@/^/@{-&gt;}[rr]^{Hom(-,X)} \ar@/_/@{-&gt;}[l] \ar@{-&gt;}[l] \ar@{-&gt;}[d]^{f} &amp;  &amp; Hom(A,\ X) \ar@{-&gt;}[d]^{Hom(f,\ X)} \\ &amp; B \ar@{-&gt;}[lu] \ar@/^/@{-&gt;}[rr]^{Hom(-,X)} \ar@/^/@{-&gt;}[lu] \ar@/_/@{-&gt;}[lu] &amp;  &amp; Hom(B,\ X)}\]</span></p><h3 id="定义-2">定义</h3><p>设有 locally small category <span class="math inline">\(C^{op}\)</span>，固定 <span class="math inline">\(C\)</span> 下的 object <span class="math inline">\(X\)</span> 为 fixed object，并且有：<br> 1. Objects：<span class="math inline">\(A, B \in Obj(C^{op})\)</span><br> 2. Morphisms：<span class="math inline">\(f : A \to B\)</span><br> 现在设 <span class="math inline">\(g : B \to X\)</span>，因此能够得出如下图表：</p><p><span class="math display">\[\xymatrix{X &amp; A \ar@{-&gt;}[l]_{g \circ f} \ar@{-&gt;}[d]^{f} \ar@/^/@{-&gt;}[rr]^{Hom(-,\ X)} &amp;  &amp; Hom(A,\ X) &amp; g \circ f \\ &amp; B \ar@{-&gt;}[lu]^{g} \ar@/^/@{-&gt;}[rr]^{Hom(-,\ X)} &amp;  &amp; Hom(B,\ X) \ar@{-&gt;}[u]^{Hom(f,\ X)} &amp; g \ar@{|-&gt;}[u]}\]</span></p><p>便能得出性质：<span class="math inline">\(Hom(f,\ X)(g) = g \circ f\)</span>。而由于 contravariant hom-functor 本身结构是 <span class="math inline">\(F : C^{op} \to Set\)</span>，因此于拓扑里有另外一个名字，称之为 presheaf (预层) 。</p><h3 id="mixed-variant-hom-functor-双变-hom-函子">Mixed-variant Hom-functor (双变 Hom-函子)</h3><p>Mixed-variant hom-functor 相较于上述的 covariant 及 contravariant hom-functor，最大的区别是它能同时接受两个变元，即 <span class="math inline">\(Hom(-, -) : C^{op} \times C \to Set\)</span>，因此被称为 mixed-variant hom-functor，该functor是一个 <span class="math inline">\(Id_C\)</span> 的 profunctor，亦可被视为是一个 bifunctor 的结构。</p><h3 id="定义-3">定义</h3><p>设有 locally small category <span class="math inline">\(C\)</span> 并且有 <span class="math inline">\(C\)</span> 的 opposite category <span class="math inline">\(C^{op}\)</span><br> Objects：<span class="math inline">\(A, A&#39; \in Obj(C^{op})\)</span>，<span class="math inline">\(B, B&#39; \in Obj(C)\)</span><br> Morphisms：<span class="math inline">\(f : A&#39; \to A\)</span>，<span class="math inline">\(h : B \to B&#39;\)</span><br> Functors：<span class="math inline">\(Hom(-, X) : C^{op} \to Set\)</span>，<span class="math inline">\(Hom(X, -) : C \to Set\)</span></p><p>那么即有图：</p><p><span class="math display">\[\xymatrix{A \ar@{-&gt;}[rr]^{Hom(-,X)} &amp;  &amp; Hom(A,\ B) \ar@{-&gt;}[rd]^{Hom(f,\ h)} &amp;  \\A&#39; \ar@{-&gt;}[u]^{f} \ar@{-&gt;}[rrr]^{Hom(-,X)} &amp;  &amp;  &amp; Hom(A&#39;,\ B&#39;) \\ &amp;  &amp;  &amp;  \\ &amp;  &amp; B \ar@{-&gt;}[r]_{h} \ar@{-&gt;}[uuu]|-{Hom(X,-)} &amp; B&#39; \ar@{-&gt;}[uu]|-{Hom(X,-)}}\]</span></p><p>而由于 <span class="math inline">\(Hom(X, -)\)</span> 以及 <span class="math inline">\(Hom(-, X)\)</span> 二者皆是从某个 category 中 morphism 至 <span class="math inline">\(Set\)</span>，因此该处可构成一 product category (乘积范畴)，即 <span class="math inline">\(C^{op} \times C\)</span>，所以有functor <span class="math inline">\(Hom(-, -) : C^{op} \times C \to Set\)</span>：</p><p><span class="math display">\[\xymatrix{ &amp;  &amp; Hom(A,\ B) \ar@{-&gt;}[rd]|-{Hom(f,\ h)} &amp;  \\A \ar@{-&gt;}[r] &amp; (A,\ B) \ar@{-&gt;}[rd]|-{(f,\ h)} \ar@{-&gt;}[ru]|-{Hom(-,\ -)} &amp;  &amp; Hom(A&#39;, \ B&#39;) \\A&#39; \ar@{-&gt;}[u]^{f} \ar@{-&gt;}[rr] &amp;  &amp; (A&#39;,\ B&#39;) \ar@{-&gt;}[ru]|-{Hom(-,\ -)} &amp;  \\ &amp; B \ar@{-&gt;}[r]_{h} \ar@{-&gt;}[uu] &amp; B&#39; \ar@{-&gt;}[u] &amp; }\]</span></p><p>而对于 <span class="math inline">\(Set\)</span> 中 <span class="math inline">\(Hom(f,\ h) : Hom(A,\ B) \to Hom(A&#39;,\ B&#39;)\)</span>，假设固定任意一边的变元为 <span class="math inline">\(id\)</span>，那么 morphisms 则为：<span class="math inline">\(Hom(id_A,\ h) : Hom(A, B) \to Hom(A, B&#39;)\)</span>，<span class="math inline">\(Hom(f,\ id_B) : Hom(A,\ B) \to Hom(A&#39;,\ B)\)</span>，<span class="math inline">\(Hom(id_{A&#39;},\ h) : Hom(A&#39;, B) \to Hom(A&#39;, B&#39;)\)</span>，<span class="math inline">\(Hom(f,\ id_{B&#39;}) : Hom(A,\ B&#39;) \to Hom(A&#39;,\ B&#39;)\)</span>，所以会有图：</p><p><span class="math display">\[\xymatrix{Hom(A,\ B) \ar@{-&gt;}[rr]^{Hom(A,\ h)} \ar@{-&gt;}[dd]_{Hom(f,\ B)} &amp;  &amp; Hom(A,\ B&#39;) \ar@{-&gt;}[dd]^{Hom(f,\ B&#39;)} \\ &amp;  &amp;  \\Hom(A&#39;,\ B) \ar@{-&gt;}[rr]_{Hom(A&#39;,\ h)} &amp;  &amp; Hom(A&#39;,\ B&#39;)}\]</span></p><p>为了证明该图可交换，现在假设有 <span class="math inline">\(g \in Hom(A,\ B)\)</span>，那么有：</p><p><span class="math display">\[\xymatrix{Hom(A,\ B) \ar@{-&gt;}[rrr]^{Hom(A,\ h)} \ar@{-&gt;}[ddd]_{Hom(f,\ B)} &amp;  &amp;  &amp; Hom(A,\ B&#39;) \ar@{-&gt;}[ddd]^{Hom(f,\ B&#39;)} \\ &amp; g \ar@{|-&gt;}[r] \ar@{|-&gt;}[d] &amp; h \circ g \ar@{|-&gt;}[d] &amp;  \\ &amp; g \circ f \ar@{|-&gt;}[r] &amp; h \circ g \circ f &amp;  \\Hom(A&#39;,\ B) \ar@{-&gt;}[rrr]_{Hom(A&#39;,\ h)} &amp;  &amp;  &amp; Hom(A&#39;,\ B&#39;)}\]</span></p><p>最终得出结论：<span class="math inline">\(g \mapsto h \circ g \circ f : Hom(A,\ B) \to Hom(A&#39;,\ B&#39;)\)</span>，因此该图可交换。</p><h2 id="yoneda-lemma">Yoneda Lemma</h2><p>在把上述的 hom-set，hom-functor 等概念定义完毕后，现在我们终于可以开始来谈谈何为 Yoneda Lemma 了，首先我们从它的定义开始。</p><h3 id="定义-4">定义</h3><ol type="1"><li>设 <span class="math inline">\(C\)</span> 为任意的 locally small category 以及有 category <span class="math inline">\(Set\)</span></li><li>固定某个 object <span class="math inline">\(X \in Obj(C)\)</span></li><li>Functors：<span class="math inline">\(Hom(X, -) : C \to Set\)</span>，一个任意的 functor <span class="math inline">\(F : C \to Set\)</span></li></ol><p>而 Yoneda Lemma 所描述的即设有任一的对于 <span class="math inline">\(Hom(X, -)\)</span> 与 <span class="math inline">\(F\)</span> 之间的 natural transformation (自然变换) <span class="math inline">\(\alpha\)</span>，它与 <span class="math inline">\(x \in F(X)\)</span> 即可视为是 isomorphic 的。换句话说即对于集合 <span class="math inline">\(F(X)\)</span>，它必定能够一对一地把 objects 从 <span class="math inline">\(F(X)\)</span> bijection 至 <span class="math inline">\(Hom(Hom(X, -),\ F)\)</span> 集合上的 functor。</p><p>米田引理的形式化定义如下：</p><p><span class="math display">\[ [C,\ Set](Hom(X, -),\ F) \cong F(X) \]</span></p><p>其中 <span class="math inline">\([C,\ Set]\)</span> 是一 functor category (函子范畴)，object 为 functor，morphisms 则为 natural transformations。 有些时候我们也能把 functor category 替换成 <span class="math inline">\(Set\)</span>，其含义是一样的，因此有：</p><p><span class="math display">\[ Hom(Hom(X, -),\ F) \cong F(X) \]</span></p><h3 id="co-yoneda">Co-Yoneda</h3><p>而对于 Contravariant Yoneda Lemma，则可以把上述的 <span class="math inline">\(Hom(X,-)\)</span> functor 改为 <span class="math inline">\(Hom(-,X)\)</span>，即是 contravariant hom-functor。因此对于任意的 functor <span class="math inline">\(G\)</span>，我们有：</p><p><span class="math display">\[ [C,\ Set](Hom(-, X),\ G) \cong G(X) \]</span></p><h3 id="透过交换图观察米田引理的结构">透过交换图观察米田引理的结构</h3><p>由于文字叙述往往不是很直观，因此让我们从交换图的角度来观察一下米田引理：</p><p>首先定义 <span class="math inline">\(A, B \in Obj(C)\)</span>，且有态射 <span class="math inline">\(f : A \to B\)</span>，以及一个任意的 object <span class="math inline">\(X\)</span>，因此对于范畴 <span class="math inline">\(C\)</span>，我们有：</p><p><span class="math display">\[\xymatrix{X \ar@{--&gt;}[r]^{-} \ar@{--&gt;}[rd]_{f \circ -} &amp; A \ar@{-&gt;}[d]^{f} \\ &amp; B}\]</span></p><p>因此对于任意 <span class="math inline">\(X\)</span>，我们可以定义出 morphism <span class="math inline">\(- : X \to A\)</span> 以及 <span class="math inline">\(f \circ - : X \to B\)</span>。</p><p>而后考虑到有functor <span class="math inline">\(Hom(X,\ -) : C \to Set\)</span> 和 <span class="math inline">\(F : C \to Set\)</span>，以及有一自然变换 <span class="math inline">\(\alpha : Hom(X, -) \to F\)</span>，我们能够得出如下图：</p><p><span class="math display">\[\xymatrix{X \ar@{--&gt;}[r]^{-} \ar@{--&gt;}[rd]_{f \circ -} &amp; A \ar@{-&gt;}[d]^{f} \ar@/^/@{-&gt;}[rrdd]|-{Hom(X,-)} \ar@/^/@{-&gt;}[rrrrdd]|-{F} &amp;  &amp;  &amp;  &amp;  \\ &amp; B \ar@/^/@{-&gt;}[rrddd]|-{Hom(X,-)} \ar@/^/@{-&gt;}[rrrrddd]|-{F} &amp;  &amp;  &amp;  &amp;  \\ &amp;  &amp;  &amp; Hom(X,\ A) \ar@{-&gt;}[dd]^{Hom(X,\ f)} \ar@{-&gt;}[rr]^{\alpha_A} &amp;  &amp; F(A) \ar@{-&gt;}[dd]^{F\ f} \\ &amp;  &amp;  &amp;  &amp;  &amp;  \\ &amp;  &amp;  &amp; Hom(X,\ B) \ar@{-&gt;}[rr]_{\alpha_B} &amp;  &amp; F(B)}\]</span></p><p>所以在 <span class="math inline">\(Set\)</span> 范畴内，我们有如下态射：<span class="math inline">\(Hom(X,\ f) : Hom(X,\ A) \to Hom(X,\ B)\)</span>，<span class="math inline">\(F\ f : F(A) \to F(B)\)</span>，以及自然变换：<span class="math inline">\(\alpha_A : Hom(X,\ A) \to F(A)\)</span>，<span class="math inline">\(\alpha_B : Hom(X,\ B) \to F(B)\)</span>。</p><p>对于范畴 <span class="math inline">\(Set\)</span>，由于 <span class="math inline">\((F\ f) \circ \alpha_A = \alpha_B \circ Hom(X,\ f)\)</span>，因此该图可交换。</p><h2 id="证明-1">证明</h2><p>为了证明米田引理，我们可以把 <span class="math inline">\(Hom(X,\ A)\)</span> 的态射变为 <span class="math inline">\(id_X\)</span>，即有 <span class="math inline">\(Hom(X,\ X)\)</span>，所以我们可以把上图改为：</p><p><span class="math display">\[\xymatrix{X \ar@{--&gt;}[r]^{id} \ar@{--&gt;}[rd] &amp; X \ar@{-&gt;}[d]^{f} \ar@/^/@{-&gt;}[rrdd]|-{Hom(X,-)} \ar@/^1pc/@{-&gt;}[rrrrrdd]|-{F} &amp;  &amp;  &amp;  &amp;  &amp;  \\ &amp; B \ar@/^/@{-&gt;}[rrdddd]|-{Hom(X,-)} \ar@/^1pc/@{-&gt;}[rrrrrdddd]|-{F} &amp;  &amp;  &amp;  &amp;  &amp;  \\ &amp;  &amp;  &amp; Hom(X,\ X) \ar@{-&gt;}[ddd]^{Hom(X,\ f)} \ar@{-&gt;}[rrr]^{\alpha_X} &amp;  &amp;  &amp; F(X) \ar@{-&gt;}[ddd]^{F\ f} \\ &amp;  &amp;  &amp;  &amp; id_X \ar@{-&gt;}[r] \ar@{-&gt;}[d] &amp; u \ar@{-&gt;}[d] &amp;  \\ &amp;  &amp;  &amp;  &amp; f \ar@{-&gt;}[r] &amp; \alpha_B\ f = (F\ f)\ u &amp;  \\ &amp;  &amp;  &amp; Hom(X,\ B) \ar@{-&gt;}[rrr]_{\alpha_B} &amp;  &amp;  &amp; F(B)}\]</span></p><h4 id="于-agda-中的表达">于 Agda 中的表达</h4><h4 id="于-haskell-中表达">于 Haskell 中表达</h4><h3 id="co-yoneda-lemma">Co-Yoneda Lemma</h3><h2 id="米田嵌入-yoneda-embedding">米田嵌入 (Yoneda embedding)</h2><h2 id="与-cps-变换的关系">与 CPS 变换的关系</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读须知&quot;&gt;阅读须知&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;本篇文章面向人群是接触过 Category theory (范畴论) 以及 函数式编程，但未曾接触过 Yoneda Lemma (米田引理) 的读者食用。&lt;/li&gt;
&lt;li&gt;通篇对于范畴论内的专有名词一律采用了英文
      
    
    </summary>
    
    
      <category term="范畴论" scheme="https://a9032676.github.io/tags/%E8%8C%83%E7%95%B4%E8%AE%BA/"/>
    
      <category term="函数式编程" scheme="https://a9032676.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Dotty Scala 上的依赖类型</title>
    <link href="https://a9032676.github.io/2020/11/03/Scala-Depedent-Types/"/>
    <id>https://a9032676.github.io/2020/11/03/Scala-Depedent-Types/</id>
    <published>2020-11-03T01:24:00.000Z</published>
    <updated>2020-11-03T02:11:54.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>最近由于正在研究直觉类型论以及同伦类型论, 因此特意挑选了 Scala 的 Dotty 编译器作为研究对象, 而由于 Dotty 所设计的依赖类型相较于 Coq, Agda, Idris 之类的语言来讲十分不直观, 导致写出一些带有大量依赖类型的函数则显得较为绕口, 因此本篇文章主要目的是找出一套通用的编码方式, 亦即找寻出 Scala 与 直觉类型论 之间的对应关系.</p><h2 id="在-dotty-中-scala-是如何编码依赖类型的">在 Dotty 中, Scala 是如何编码依赖类型的？</h2><p>首先让我们从最简单的例子开始, 假设有一依赖函数类型 <span class="math inline">\(depfun\)</span>:</p><p><span class="math display">\[ depfun : \underset{(A : U)}{\Pi} \underset{(C : A \to U)}{\Pi} \underset{(x : A)}{\Pi} C(x) \]</span></p><p>且其表达式为:</p><p><span class="math display">\[ depfun_{A, C}(x) = x \]</span></p><p>然后现在我们能于 Scala 中写出这么一段代码: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trait C &#123; type A; val x : A &#125;</span><br><span class="line">type PiType = (c : C) =&gt; c.A</span><br><span class="line">val depfun : PiType = c =&gt; c.x</span><br></pre></td></tr></table></figure></p><p>于这段代码里, 使用了 <code>trait</code>, <code>type</code> 以及 <code>val</code> 以描述依赖函数类型 <code>depfun</code>， 而 <code>val depfun : PiType = c =&gt; c.x</code> 的 <code>PiType</code> 则代表着一个依赖函数类型 (<span class="math inline">\(\Pi\)</span>-类型), <code>(c : C) =&gt; c.x</code> 部分则为一项 (表达式).</p><h2 id="为什么-scala-编码复杂的依赖类型显得如此困难">为什么 Scala 编码复杂的依赖类型显得如此困难？</h2><h3 id="没有全类多态的依赖类型">没有全类多态的依赖类型</h3><h3 id="语法设计的问题">语法设计的问题</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;最近由于正在研究直觉类型论以及同伦类型论, 因此特意挑选了 Scala 的 Dotty 编译器作为研究对象, 而由于 Dotty 所设计的依赖类型相较于 Coq, Agda, Idris 之类的语言来讲十分不直观, 导致写出一些带有大
      
    
    </summary>
    
    
      <category term="直觉类型论" scheme="https://a9032676.github.io/tags/%E7%9B%B4%E8%A7%89%E7%B1%BB%E5%9E%8B%E8%AE%BA/"/>
    
      <category term="Dotty" scheme="https://a9032676.github.io/tags/Dotty/"/>
    
      <category term="Scala" scheme="https://a9032676.github.io/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>奇妙的依赖类型 (上): 全类, $\Pi$-类型 以及 乘积类型</title>
    <link href="https://a9032676.github.io/2020/10/28/Dependent-Function-Types/"/>
    <id>https://a9032676.github.io/2020/10/28/Dependent-Function-Types/</id>
    <published>2020-10-27T17:51:00.000Z</published>
    <updated>2020-10-31T09:54:25.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>于 <a href="https://en.wikipedia.org/wiki/Intuitionistic_type_theory" target="_blank" rel="noopener">直觉类型论 (Intuitionistic type theory, 或 Martin-Löf's type theory)</a> 中, 定义了一些于经典类型论中没有的高阶类型: <span class="math inline">\(\Pi\)</span>-类型 (依赖函数类型, Dependent function types) 以及 <span class="math inline">\(\Sigma\)</span>-类型 (依赖乘积类型, Dependent pair types), 该种类型系统可被对应到 <span class="math inline">\(\lambda\)</span>立方体 中的 <span class="math inline">\(\lambda P\)</span> 上. 本篇章大部分内容均来自于对 <a href="https://hott.github.io/book/nightly/hott-ebook-1272-ga50f9bd.pdf" target="_blank" rel="noopener">Hott Book</a> 的理解与翻译, 再稍加改动并引入 Agda 作举例用途. 在此推荐读者配合其中 第一章 Foundations 的 1.4 ~ 1.7 节 进行阅读. 由于篇幅过长, 文章将会分为上下两节, 而本篇将先行介绍 全类, <span class="math inline">\(\Pi\)</span>-类型 以及 乘积类型 的概念.</p><h2 id="全类-universes">全类 (Universes)</h2><h3 id="全类多态-universe-polymorphism">全类多态 (Universe polymorphism)</h3><p>于经典类型论中, 一般会非形式化地称 "<span class="math inline">\(A\)</span> 是一个类型", 但为了更准确的形式化地定义出这种关系, 以及描述类型与项之间的关系, 我们需要引入一个全新的概念: 全类 (Universes). 全类的意思就相当于 "整个宇宙" 一般, 其是这个宇宙中所有类型的类型, 一般地会写为 <span class="math inline">\(U_\infty\)</span>. 而当我们试着从集合论出发去定义全类时, 由于 <span class="math inline">\(U_\infty\)</span> 能够包含自身, 即 <span class="math inline">\(U_\infty : U_\infty\)</span>, 但此处将会引发一个非常严重的问题, 即集合论上这么定义是 <a href="https://en.wikipedia.org/wiki/Soundness" target="_blank" rel="noopener">不可靠的 (Unsound)</a> , 这将直接导致罗素悖论 (Russell's paradox) 的出现. 为了避免这种情况的发生, 我们需要独立且不依赖集合论的情况下重新定义出全类的层级:</p><p><span class="math display">\[ U_0 : U_1 : U_1 :\ ... \]</span></p><p>一般地我们会写为 <span class="math inline">\(U_i\)</span> (这里的 <span class="math inline">\(i\)</span> 为全类的层级), 而每个 <span class="math inline">\(U_i\)</span> 都是 <span class="math inline">\(U_{i+1}\)</span> 的元素 (也就是一个大宇宙内包含着一个小宇宙). 而我们称这种分层是 可累加的 (Cumulative), 即对于所有于 <span class="math inline">\(i^{th}\)</span> 全类内的元素亦都是 <span class="math inline">\((i + 1)^{st}\)</span> 内的元素, 例如有 <span class="math inline">\(A : U_i\)</span>, 即亦有 <span class="math inline">\(A : U_{i+1}\)</span>, 而这种概念可被称为 <a href="https://ncatlab.org/nlab/show/universe+polymorphism" target="_blank" rel="noopener">全类多态 (Universe polymorphism)</a> .</p><h3 id="隐式层级-implicit-level">隐式层级 (Implicit level)</h3><p>而于大部分的情况下, 并不需要显式地标记出全类的层级 <span class="math inline">\(i\)</span>, 而亦可将其隐藏起来, 因此可以写成 <span class="math inline">\(U : U\)</span> (其含义与 <span class="math inline">\(U_i : U_{i+1}\)</span> 等价), 这种写法称之为 <code>Typical ambiguity</code>. 这种写法虽然较为便捷, 但还是会略带点危险性, 因为其将允许我们写出看似合法的, 但实质可能会诱发各种自引用悖论的证明. 不过在这里其实也无需太过担心, 于 Agda 或者 Coq 这些语言上, 其全类层级都是可以自动推导得出的.</p><h3 id="小类型-small-types">小类型 (Small types)</h3><p>由于全类多态的出现, 允许了我们编写出表达能力极强的类型系统, 除了类型本身外, 不仅仅可以定义出 "类型的类型", 即 <span class="math inline">\(Kind\)</span> (类型构造器), 还可以定义出类型的类型的类型, 类型的类型的类型的类型, 即 $Type_1 : Type_2 : Type_3 : ... $ 等等. 然后假设现在有 <span class="math inline">\(U\)</span>, 而所有归属于该 <span class="math inline">\(U\)</span> 的元素 (类型) 均可被称之为 <span class="math inline">\(U\)</span> 的 <code>小类型 (Small types)</code>.</p><h3 id="类型族-families-of-types">类型族 (Families of types)</h3><p>为了使类型也能够被参数化, 把一个类型当作函数看待是被允许的. 例如设有类型 <span class="math inline">\(A\)</span>, 然后有一函数 <span class="math inline">\(B : A \to U\)</span>, 其接受 <span class="math inline">\(A\)</span> 作为参数, 返回 <span class="math inline">\(B\)</span> 这个类型, 而陪域上则是 <span class="math inline">\(U\)</span>. 这种函数我们一般称为 类型族 (有时候可被视为依赖类型).</p><p>例如当我们想要模拟出模数取模时, 定义出有限集合 <span class="math inline">\(\{ m\ |\ m &lt; n \}\)</span> 有利于以循环群的形式进行运算, 而该集合则可定义为 Fin : <span class="math inline">\(\Bbb{N} \to U\)</span>, Fin(<span class="math inline">\(n\)</span>) 的 <span class="math inline">\(n\)</span> 则表示了其集合的边界位置, 对应到 Agda 中 <code>Data.Fin.Base</code> 的定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data Fin : ℕ → Set where</span><br><span class="line">  zero : &#123;n : ℕ&#125; → Fin (suc n)</span><br><span class="line">  suc  : &#123;n : ℕ&#125; (i : Fin n) → Fin (suc n)</span><br></pre></td></tr></table></figure><p>而最直观的且非常重要的例子就非 <code>Constant type</code> 莫属了, 其定义如 <span class="math inline">\((\lambda (x : A). B) : A \to U\)</span>, 由于这个类型族无论参数如何变化, 其永远返回的都将是 <span class="math inline">\(B\)</span>, 则其可被视为为 <span class="math inline">\(B : U\)</span> .</p><h3 id="agda-上的定义">Agda 上的定义</h3><p>于 Agda 上, Set 类型对应的就是全类的概念, 而 Set <span class="math inline">\(\ell\)</span> 中的 <span class="math inline">\(\ell\)</span> 则是全类的层级. 而全类层级于 module <code>Agda.Primitive</code> 中的定义如下: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">infixl 6 _⊔_</span><br><span class="line"></span><br><span class="line">postulate</span><br><span class="line">  Level : Set</span><br><span class="line"></span><br><span class="line">postulate</span><br><span class="line">  lzero : Level</span><br><span class="line">  lsuc  : (ℓ : Level) → Level</span><br><span class="line">  _⊔_   : (ℓ₁ ℓ₂ : Level) → Level</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>该层级的定义实际上是个内置于 Agda 中的自然数, 并非直接使用的 <code>Data.Nat</code> (<span class="math inline">\(\Bbb{N}\)</span>) 类型.</p><h2 id="pi-类型-pi-type"><span class="math inline">\(\Pi\)</span>-类型 (<span class="math inline">\(\Pi\)</span>-Type)</h2><p><span class="math inline">\(\Pi\)</span>-类型, 又称为 <code>依赖函数类型 (Dependent function type)</code>, 是依赖类型的一种. 其于陪域的类型将依赖于传入的值, 即到达域的值而作出改变. 而之所以称为 <span class="math inline">\(\Pi\)</span>-类型 是因为这种类型可以被视为是在类型之上的笛卡儿积.</p><h3 id="定义">定义</h3><p>形式化地, 假设现在有类型 <span class="math inline">\(A : U\)</span> 以及类型族 <span class="math inline">\(B : A \to U\)</span>, 我们便能够构造一个依赖函数类型 <span class="math inline">\(\Pi_{(x : A)} B(x) : U\)</span>. 当然还有许多种不同的写法可供选择, 例如以下这些:</p><p><span class="math display">\[ \Pi_{(x : A)} B(x) \qquad \underset{(x : A)}{\Pi} B(x) \qquad \Pi (x : A), B(x) \]</span></p><p>而对应到 Agda 中的类型标签则如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ : ∀ (A : Set) &#123;x : A&#125; &#123;B : A → Set&#125; → B x</span><br></pre></td></tr></table></figure><p>而在一个特殊情况下, 当 <span class="math inline">\(B\)</span> 是一个 <code>Constant family</code> 时, 即 <span class="math inline">\(B\)</span> 并没有依赖于 <span class="math inline">\(x : A\)</span>, 则依赖函数类型将 "坍塌" 成一普通函数:</p><p><span class="math display">\[ \Pi_{(x : A)} B \equiv (A \to B) \]</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ : ∀ (A : Set) &#123;x : A&#125; &#123;B : Set&#125; → B</span><br></pre></td></tr></table></figure><p>在上面给到的例子以及定义中, 类型标签本身是没有名字的 (即 Agda 中的 <code>_</code>), 实际上我们无论于形式化的定义上, 还是 Agda 中, 都可以给予相应的名字, 如: <span class="math inline">\(f : \Pi_{(x : A)} B(x)\)</span>, 即 <span class="math inline">\(f\)</span> 是为一依赖函数的名字, 使得他们是 <code>显式定义 (Explicit definitions)</code> 的. 而除了类型外, 一个依赖函数若果带有诸如表达式 <span class="math inline">\(\Phi : B(x)\)</span> 而涉及到 <span class="math inline">\(x : A\)</span> 的话, 可被描述为:</p><p><span class="math display">\[ f(x) :\equiv \Phi \qquad 对于 x : A \]</span></p><p>当然亦可替代成使用 <span class="math inline">\(\lambda\)</span>-abstraction 的形式进行定义:</p><p><span class="math display">\[ \lambda x. \Phi : \underset{x : A}{\Pi} B(x) \]</span></p><h3 id="全类上的多态">全类上的多态</h3><p>多态能够应用于给定的全类上, 这是又一依赖函数类型至关重要的特性. 用通俗的话来说即是假设现在有 <span class="math inline">\(id : \Pi_{(A : U)} A \to A\)</span> 这么一个依赖函数类型, 而此处则可以像类型族一般, 接受一个类型作为参数, 然后作用于类型 <span class="math inline">\(A\)</span> 的表达式上, 就如同 <span class="math inline">\(id :\equiv \lambda (A : U). \lambda (x : A). x\)</span> 一样.</p><p>而另一个多态函数的例子 <code>swap</code> (或 <code>flip</code>) 函数, 相信大家都非常熟悉的了, 我们可以观察一下它是怎么定义的:</p><p><span class="math display">\[ swap : \underset{(A : U)}{\Pi} \underset{(B : U)}{\Pi} \underset{(C : U)}{\Pi} (A \to B \to C) \to (B \to A \to C) \]</span></p><p>且其表达式为:</p><p><span class="math display">\[ swap(A, B, C, g) :\equiv \lambda b. \lambda a. g(a)(b) \]</span></p><p>当然地, 我们在表达式上并无需要使用到 <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span> 时, 则可以将其隐藏起来, 如:</p><p><span class="math display">\[ swap_{A, B, C}(g)(b, a) :\equiv g(a)(b) \]</span></p><p>但不要忘记, <code>swap</code> 仅仅还只是个普通的多态函数而已！ 我们现在需要做的是定义出一个基于依赖函数类型的多态函数 <code>swap'</code>, 例如:</p><p><span class="math display">\[ swap&#39; : \underset{(A : U)}{\Pi} \underset{(B : U)}{\Pi} \underset{(C : A \to B \to U)}{\Pi} (\underset{(x : A)}{\Pi} \underset{(y : B)}{\Pi} C(x, y)) \to (\underset{(y : B)}{\Pi} \underset{(x : A)}{\Pi} C(x, y)) \]</span></p><p>而对于上面的 <span class="math inline">\(C(x, y)\)</span>, 实际上等同于 <span class="math inline">\(C(x)(y)\)</span>, 即相当于柯里化. 下面则为 Agda 于 <code>Function.Core</code> 下的对照版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flip : ∀ &#123;A : Set a&#125; &#123;B : Set b&#125; &#123;C : A → B → Set c&#125; →</span><br><span class="line">       ((x : A) (y : B) → C x y) → ((y : B) (x : A) → C x y)</span><br><span class="line">flip f = λ y x → f x y</span><br></pre></td></tr></table></figure><p>再来一个 <code>_∘_</code> (Compose) 的例子:</p><p>非依赖类型的情况下是:</p><p><span class="math display">\[ comp : \underset{(A, B, C : U)}{\Pi} (B \to C) \to (A \to B) \to (A \to C) \]</span></p><p>而使用了依赖函数类型定义的则是:</p><p><span class="math display">\[ comp : \underset{(A, B, C : U)}{\Pi} \underset{(B : A \to U)}{\Pi} \underset{(C : \underset{(x : A)}{\Pi} B(x) \to U)}{\Pi} (\underset{(x : A)}{\Pi} \underset{(y : B(x))}{\Pi} C(y)) \to \underset{(g : \underset{(x : A)}{\Pi} B(x))}{\Pi} (\underset{(x : A)}{\Pi} C(g(x))) \]</span></p><p>Agda 上的定义则是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_∘_ : ∀ &#123;A : Set a&#125; &#123;B : A → Set b&#125; &#123;C : &#123;x : A&#125; → B x → Set c&#125; →</span><br><span class="line">      (∀ &#123;x&#125; (y : B x) → C y) → (g : (x : A) → B x) →</span><br><span class="line">      ((x : A) → C (g x))</span><br><span class="line">f ∘ g = λ x → f (g x)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;于 &lt;a href=&quot;https://en.wikipedia.org/wiki/Intuitionistic_type_theory&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;直觉类型论 (Intuitioni
      
    
    </summary>
    
    
      <category term="类型论" scheme="https://a9032676.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%AE%BA/"/>
    
      <category term="直觉类型论" scheme="https://a9032676.github.io/tags/%E7%9B%B4%E8%A7%89%E7%B1%BB%E5%9E%8B%E8%AE%BA/"/>
    
      <category term="Agda" scheme="https://a9032676.github.io/tags/Agda/"/>
    
  </entry>
  
  <entry>
    <title>Church-Rosser 定理证明</title>
    <link href="https://a9032676.github.io/2020/10/11/Church-Rosser-Theorem/"/>
    <id>https://a9032676.github.io/2020/10/11/Church-Rosser-Theorem/</id>
    <published>2020-10-10T22:08:00.000Z</published>
    <updated>2020-10-12T12:27:42.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>于理论计算机科学中, Church-Rosser 定理 讲述了当我们尝试给任意 <span class="math inline">\(\lambda\)</span>-表达式 的变体应用 <span class="math inline">\(reduction\)</span> 规则时, 不管所规约排序如何, 也定不会影响到最终的运行结果. 该定理由 <a href="https://en.wikipedia.org/wiki/Alonzo_Church" target="_blank" rel="noopener">Alonzo Church</a> 与 <a href="https://en.wikipedia.org/wiki/J._Barkley_Rosser" target="_blank" rel="noopener">J. Barkley Rosser</a> 于 1936 年时证明得出, 并以他们的名称所命名.</p><h2 id="beta-范式-beta-normal-form-beta-nf"><span class="math inline">\(\beta\)</span>-范式 (<span class="math inline">\(\beta\)</span>-normal form, <span class="math inline">\(\beta\)</span>-nf)</h2><h3 id="定义">定义</h3><ol type="1"><li><span class="math inline">\(\beta\)</span>-redex 的项是类似于 (<span class="math inline">\(\lambda x. M)\ N\)</span> 这样的表达式, 而这个例子中 <span class="math inline">\(M[x := N]\)</span> 则是其的 <span class="math inline">\(contractum\)</span>.</li><li>一个 <span class="math inline">\(\lambda\)</span>-项 <span class="math inline">\(M\)</span> 被称为 <span class="math inline">\(\beta\)</span>-nf 若其没有 <span class="math inline">\(\beta\)</span>-redex 作为子表达式.</li><li>对于 <span class="math inline">\(\exists N\)</span>, 若有项 <span class="math inline">\(M =_{\beta} N\)</span> 且 <span class="math inline">\(N\)</span> 本身存在 <span class="math inline">\(\beta\)</span>-nf, 则 <span class="math inline">\(M\)</span> 亦有 <span class="math inline">\(\beta\)</span>-nf.</li></ol><p>例如 <span class="math inline">\((\lambda x. xx)\ y\)</span> 本身并不是一个 <span class="math inline">\(\beta\)</span>-nf, 但于 <span class="math inline">\(\beta\)</span>-规约 之后存在项 <span class="math inline">\(yy\)</span>, 这便是一个 <span class="math inline">\(\beta\)</span>-nf 了.</p><h3 id="引理">引理</h3><p>设有 <span class="math inline">\(M, M&#39;, N, L \in \Lambda\)</span>.</p><ol type="1"><li><p>设 <span class="math inline">\(M\)</span> 为 <span class="math inline">\(\beta\)</span>-nf, 则有 <span class="math inline">\(M \twoheadrightarrow_{\beta} N \implies N \equiv M\)</span>.</p></li><li><p>若 <span class="math inline">\(M \to_{\beta} M&#39;\)</span>, 则有 <span class="math inline">\(M[x := N] \to_{\beta} M&#39;[x := N]\)</span></p></li></ol><h3 id="证明">证明</h3><ol type="1"><li><p>由于 <span class="math inline">\(M\)</span> 是 <span class="math inline">\(\beta\)</span>-nf, 定不存在任何的 <span class="math inline">\(\beta\)</span>-redex, 所以永远都不会有 <span class="math inline">\(M \to_{\beta} N\)</span> 的情况出现. 因此即使有 <span class="math inline">\(M \twoheadrightarrow_{\beta} N\)</span>, 也势必是 <span class="math inline">\(M \equiv N\)</span>.</p></li><li><p>直接应用 <span class="math inline">\(\to_{\beta}\)</span> 的规则进行规约亦能得出同样的结果.</p></li></ol><h2 id="church-rosser-定理">Church-Rosser 定理</h2><h3 id="定义-1">定义</h3><p>若果 <span class="math inline">\(M \twoheadrightarrow_{\beta} N_1, M \twoheadrightarrow_{\beta} N_2\)</span>, 则存在某些 <span class="math inline">\(N_3\)</span> 有 <span class="math inline">\(N_1 \twoheadrightarrow_{\beta} N_3\)</span> 且 <span class="math inline">\(N_2 \twoheadrightarrow_{\beta} N_3\)</span>, 如图:</p><p><span class="math display">\[\xymatrix{ &amp; M \ar@{-&gt;&gt;}[ld] \ar@{-&gt;&gt;}[rd] &amp;  \\N_1 \ar@{.&gt;&gt;}[rd] &amp;  &amp; N_2 \ar@{.&gt;&gt;}[ld] \\ &amp; N_3 &amp; }\]</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;于理论计算机科学中, Church-Rosser 定理 讲述了当我们尝试给任意 &lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt;-表达式 的变体应用 &lt;span class=&quot;math inli
      
    
    </summary>
    
    
      <category term="类型论" scheme="https://a9032676.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%AE%BA/"/>
    
      <category term="逻辑" scheme="https://a9032676.github.io/tags/%E9%80%BB%E8%BE%91/"/>
    
      <category term="证明" scheme="https://a9032676.github.io/tags/%E8%AF%81%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>MPS 系列 第一章：为 Java 增加 do-notation 语法</title>
    <link href="https://a9032676.github.io/2020/10/09/MPS-do-notation/"/>
    <id>https://a9032676.github.io/2020/10/09/MPS-do-notation/</id>
    <published>2020-10-09T03:07:00.000Z</published>
    <updated>2020-10-10T22:35:37.531Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    <summary type="html">
    
      
      
        

      
    
    </summary>
    
    
      <category term="函数式编程" scheme="https://a9032676.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="DSL" scheme="https://a9032676.github.io/tags/DSL/"/>
    
      <category term="Java" scheme="https://a9032676.github.io/tags/Java/"/>
    
      <category term="语义工程" scheme="https://a9032676.github.io/tags/%E8%AF%AD%E4%B9%89%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>不动点组合子的原理与定理证明</title>
    <link href="https://a9032676.github.io/2020/09/27/FIxed-Point-Theorem-Proof-And-Derivation/"/>
    <id>https://a9032676.github.io/2020/09/27/FIxed-Point-Theorem-Proof-And-Derivation/</id>
    <published>2020-09-26T18:28:00.000Z</published>
    <updated>2020-12-02T06:40:56.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p><a href="https://en.wikipedia.org/wiki/Fixed-point_combinator" target="_blank" rel="noopener">不动点组合子 (Fixed-Point Combinator)</a> 是一种计算其他函数 不动点 (Fixed-Point) 的高阶函数. 有函数 <span class="math inline">\(f\)</span> 其输入值 <span class="math inline">\(x\)</span> 若与返回值相同 (同样是返回 <span class="math inline">\(x\)</span>, 即 <span class="math inline">\(f(x) = x\)</span>), 则称之为函数 <span class="math inline">\(f\)</span> 上的不动点为 <span class="math inline">\(x\)</span>. 例如现在有 <span class="math inline">\(f(x) = x ^ 2\)</span>, 则其不动点是 <span class="math inline">\(f(0) = 0 ^ 2 \equiv 0\)</span> 以及 <span class="math inline">\(f(1) = 1 ^ 2 \equiv 1\)</span>. 而对于高阶函数 <span class="math inline">\(f\)</span>, 其拥有 <span class="math inline">\(g\)</span> 作为不动点使得 <span class="math inline">\(f(g) = g\)</span>.</p><h3 id="递归于-lambda-演算-上的矛盾">递归于 <span class="math inline">\(\lambda\)</span>-演算 上的矛盾</h3><p>现在假设我们有一阶乘函数 <span class="math inline">\(fact\)</span>:</p><p><span class="math display">\[\begin{aligned}    if\_then\_else &amp; := \lambda p. \lambda a. \lambda b. p a b \\    fact &amp; := \lambda x. if\ (x &gt; 0)\ then\ (x * (fact\ (x - 1)))\ else\ 1\end{aligned}\]</span></p><p>而我们从定义中得知 <span class="math inline">\(fact\)</span> 于递归时将调用自身, 例如:</p><p><span class="math display">\[\begin{aligned}    fact\ 5 &amp; = (\lambda x. if\ (x &gt; 0)\ then\ (x * (fact\ (x - 1)))\ else\ 1)\ 5 \\    &amp; \to_{\beta} 5 * (fact\ 4) \\    &amp; \to_{\beta} 5 * (4 * (fact\ 3)) \\    &amp; \to_{\beta} 5 * (4 * (3 * (fact\ 2))) \\    &amp; \to_{\beta} 5 * (4 * (3 * (2 * (fact\ 1)))) \\    &amp; \to_{\beta} 5 * (4 * (3 * (2 * 1))) \\    &amp; \twoheadrightarrow_{\beta} 120\end{aligned}\]</span></p><p>但实际在 <span class="math inline">\(\lambda\)</span>-演算 中, 所有 <span class="math inline">\(\lambda\)</span>-表达式 本质上是都应该是闭合的, 即无 <code>自由变量 (Free Variable, FV)</code> 的介入, 因此又称 <code>匿名函数 (Anonymous function)</code>. 但上述例子中 <span class="math inline">\(fact \in FV\)</span>, 此处便会引发一个问题: 若果参数并非被绑定的 (即 <span class="math inline">\(M[\alpha := fact]\)</span>, M 为具体的 <span class="math inline">\(\lambda\)</span>-表达式), 即我们无法直接透过 <span class="math inline">\(fact\ x\)</span> 调用自身, 即无法达到递归的效果.</p><h3 id="解决方案">解决方案</h3><p>但我们对此真的一点办法都没有了吗？ 仔细琢磨其实并不, 我们可以在该函数本身多增加一个参数 <span class="math inline">\(\lambda f\)</span>, 并将自身作为值被传入至 <span class="math inline">\(\lambda f\)</span> 上, 例如:</p><p><span class="math display">\[ \lambda f. (\lambda x. if\ (x &gt; 0)\ then\ (x * (f (x - 1)))\ else\ 1) \]</span></p><p>并给该函数起个别名 <span class="math inline">\(fact&#39;\)</span></p><p><span class="math display">\[ fact&#39; := \lambda f. (\lambda x. if\ (x &gt; 0)\ then\ (x * (f (x - 1)))\ else\ 1) \]</span></p><p>然后调用:</p><p><span class="math display">\[\begin{aligned}    fact&#39;\ fact&#39;\ 5 &amp; = (\lambda f. (\lambda x. if\ (x &gt; 0)\ then\ (x * (f\ (x - 1)))\ else\ 1))\ fact&#39;\ 5 \\    &amp; \to_{\beta} (\lambda x. if\ (x &gt; 0)\ then\ (x * (fact&#39;\ (x - 1)))\ else\ 1)\ 5\end{aligned}\]</span></p><p>此时意外发生了！ 仔细观察 <span class="math inline">\(fact&#39;\ (x - 1)\)</span> 的位置, 实际上 <span class="math inline">\(fact&#39;\)</span> 接受的是两个参数, 分别是 <span class="math inline">\(\lambda f\)</span> 以及 <span class="math inline">\(\lambda x\)</span>, 但于函数内部的这个 <span class="math inline">\(fact&#39;\)</span> 却只传入了一个 <span class="math inline">\((x - 1)\)</span> 的值而导致出错. 因此我们把 <span class="math inline">\(fact&#39;\)</span> 的定义修改为:</p><p><span class="math display">\[ fact&#39; := \lambda f. (\lambda x. if\ (x &gt; 0)\ then\ (x * (f\ f\ (x - 1)))\ else\ 1) \]</span></p><p>然后再次调用:</p><p><span class="math display">\[\begin{aligned}    fact&#39;\ fact&#39;\ 5 &amp; = (\lambda f. (\lambda x. if\ (x &gt; 0)\ then\ (x * (f\ f\ (x - 1)))\ else\ 1))\ fact&#39;\ 5 \\    &amp; \to_{\beta} (\lambda x. if\ (x &gt; 0)\ then\ (x * (fact&#39;\ fact&#39;\ (x - 1)))\ else\ 1)\ 5 \\    &amp; \to_{\beta} 5 * (fact&#39;\ fact&#39;\ 4) \\    &amp; \to_{\beta} 5 * (4 * (fact&#39;\ fact&#39;\ 3)) \\    &amp; \to_{\beta} 5 * (4 * (3 * (fact&#39;\ fact&#39;\ 2))) \\    &amp; \to_{\beta} 5 * (4 * (3 * (2 * (fact&#39;\ fact&#39;\ 1)))) \\    &amp; \to_{\beta} 5 * (4 * (3 * (2 * 1))) \\    &amp; \twoheadrightarrow_{\beta} 120\end{aligned}\]</span></p><p>由此可见, 该方法的语义与递归是完全一致的, <span class="math inline">\(\lambda\)</span>-演算 的计算能力并没有因此而被削弱, 反而见到其强大的一面！</p><h3 id="引出不动点">引出不动点</h3><p>虽然我们已经成功地写出一个替代递归的解决方案, 但该方案并不太完美, 于 <span class="math inline">\(fact&#39; fact&#39; (x - 1)\)</span> 的部分, 这里会多传一个值 <span class="math inline">\(fact&#39;\)</span> 作为 <span class="math inline">\(fact&#39;\)</span> 的参数, 就好像重复了两次一样, 那有没有什么办法让这个 <span class="math inline">\(fact&#39;\)</span> 函数只接受一个整数参数 <span class="math inline">\(x\)</span> 且达到类似的效果? 现在当我们回想一下递归函数的定义 <span class="math inline">\(fact := \lambda x. if\ (x &gt; 0)\ then\ (x * (fact\ (x - 1)))\ else\ 1\)</span>, 这不正正就是接受一个参数的函数嘛, 于是乎我们可以试图将其定义改回去再寻找新办法:</p><p><span class="math display">\[ fact&#39; = \lambda f. (\lambda x. if\ (x &gt; 0)\ then\ (x * (f\ (x - 1)))\ else\ 1) \]</span></p><p>然后再传入参数:</p><p><span class="math display">\[\begin{aligned}    fact&#39;\ fact\ 5 &amp; = (\lambda f. (\lambda x. if\ (x &gt; 0)\ then\ (x * (f\ (x - 1)))\ else\ 1))\ fact\ 5 \\    &amp; \to_{\beta} (\lambda x. if\ (x &gt; 0)\ then\ (x * (fact\ (x - 1)))\ else\ 1)\ 5\end{aligned}\]</span></p><p>在 <span class="math inline">\(\beta-reduction\)</span> 之后的这一步, 我们会惊奇的发现 当中的 <span class="math inline">\((\lambda x. if\ (x &gt; 0)\ then\ (x * (fact\ (x - 1)))\ else\ 1)\)</span> 其定义与 <span class="math inline">\(fact\)</span> 完全一致, 而当尝试只传入一个参数 <span class="math inline">\(fact\)</span> 进行 <code>部分求值 (Partial evaluation)</code> 时, 即:</p><p><span class="math display">\[\begin{aligned}    fact&#39;\ fact\ &amp; = (\lambda f. (\lambda x. if\ (x &gt; 0)\ then\ (x * (f\ (x - 1)))\ else\ 1))\ fact\ \\    &amp; \to_{\beta} (\lambda x. if\ (x &gt; 0)\ then\ (x * (fact\ (x - 1)))\ else\ 1) \\    &amp; = fact\end{aligned}\]</span></p><p>这里我们会发现 <span class="math inline">\(fact&#39;\)</span> 于传入 <span class="math inline">\(fact\)</span> 时, 则会返回 <span class="math inline">\(fact\)</span>, 即 <span class="math inline">\(fact\)</span> 为 <span class="math inline">\(fact&#39;\)</span> 的不动点！</p><h3 id="构造-y-组合子">构造 Y-组合子</h3><p>最终于知道不动点的性质之后, 我们尝试去构造出一个真正能使用的 <span class="math inline">\(Y\)</span>-组合子 吧！ 首先设有一递归函数 <span class="math inline">\(r\)</span> :</p><p><span class="math display">\[ r = r\ r\ r...\ r \]</span></p><p>然后由于 <span class="math inline">\(\lambda\)</span>-演算 中递归引发出自由变量的问题, 现在把递归函数作为参数传入, 因此将定义改为:</p><p><span class="math display">\[\begin{aligned}    Y &amp; = \underbrace{(\lambda r. r\ r\ r\ ...\ r)}_{f}\ f \\    &amp; = \underbrace{(\lambda r. r\ r\ r\ ...\ r)}_{f} \underbrace{(\lambda r. r\ r\ r\ ...\ r)}_{f}\end{aligned}\]</span></p><p>但此处的 <span class="math inline">\(r\)</span> 的第一个参数应为自身, 正如上面 <span class="math inline">\(fact&#39;\)</span> 的例子一样, 修正为:</p><p><span class="math display">\[ Y = \underbrace{(\lambda r. (rr)\ (rr)\ (rr)\ ...\ (rr))}_{f&#39;} \underbrace{(\lambda r. (rr)\ (rr)\ (rr)\ ...\ (rr))}_{f&#39;} \]</span></p><p>虽然到此步时, 该定义已经能用了, 但始终每一个 <span class="math inline">\(rr\)</span> 都将重复传入而不够完美 (具体参照 <span class="math inline">\(fact&#39;\)</span> 的例子), 我们可再将其化简为:</p><p><span class="math display">\[ Y = (\underbrace{(\lambda r. r\ r\ r\ ...\ r)}_{f} (xx)) (\underbrace{(\lambda r. r\ r\ r\ ...\ r)}_{f} (xx)) \]</span></p><p>最后我们把递归函数的部分改成 <span class="math inline">\(f\)</span> 并作为参数传入, 则其定义最终为:</p><p><span class="math display">\[ Y := \lambda f. (\lambda x. f (xx)) (\lambda x. f (xx)) \]</span></p><h2 id="定义">定义</h2><h3 id="常规的形式化定义">常规的形式化定义</h3><span class="math display">\[ \forall F \exists X. F X = X \]</span><center>对于所有的 <span class="math inline">\(F \in \Lambda\)</span>, 存在 <span class="math inline">\(X \in \Lambda\)</span> 使得 <span class="math inline">\(F X = X\)</span>.</center><span class="math display">\[ fix\ f = f\ (fix\ f) \]</span><center>展开则为 <span class="math inline">\(fix\ f = f\ (f\ (...\ f\ (fix\ f)\ ...))\)</span>.</center><h3 id="y-组合子的定义"><span class="math inline">\(Y\)</span>-组合子的定义</h3><span class="math display">\[ Y \equiv \lambda f. (\lambda x. f(xx)) (\lambda x. f(xx)) \]</span><center>这里的 <span class="math inline">\(f\)</span> 为任意需要被找出一个或多个不动点的函数, 而其中 <span class="math inline">\(x\)</span> 必定为一高阶函数.</center><p><br></p><h2 id="不动点定理-fixed-point-theorem-的证明">不动点定理 (Fixed Point Theorem) 的证明</h2><p>首先应用实际函数 <span class="math inline">\(F\)</span> 到 <span class="math inline">\(Y\)</span>-组合子 上:</p><p><span class="math display">\[ Y F \equiv (\lambda f. (\lambda x. f(xx)) (\lambda x. f(xx)))\ F = (\lambda x. F(xx)) (\lambda x. F(xx)) \]</span></p><p>现在假设 <span class="math inline">\(W\)</span> 与 <span class="math inline">\(X\)</span> 组合子以辅助证明, 例如:</p><p><span class="math display">\[W \equiv \lambda x. F(xx) \\X \equiv WW\]</span></p><p>开始证明:</p><p><span class="math display">\[ X \equiv WW \equiv (\lambda x. F(xx))\ W = F(WW) \equiv F X \]</span></p><p>然后可得 <span class="math inline">\(X \equiv F X\)</span>, 而因为:</p><p><span class="math display">\[Y F = (\lambda x. F(xx)) (\lambda x. F(xx)) \equiv WW \equiv X\]</span></p><p>因此 <span class="math inline">\(X \equiv Y F\)</span>, 所以可以把 <span class="math inline">\(X\)</span> 替换成 <span class="math inline">\(Y F\)</span>, 最终得到:</p><p><span class="math display">\[ Y F \equiv F (Y F) \]</span></p><p>从证明的结论中得知 $ Y F = F (Y F) $, <span class="math inline">\(F\)</span> 这个函数将会不断地自我递归:</p><p><span class="math display">\[ Y F \equiv F (Y F) \equiv F (F (Y F)) \equiv (F (F ... F (Y F) ...)) \]</span></p><h2 id="应用">应用</h2><h3 id="实际例子">实际例子</h3><h4 id="阶乘函数">阶乘函数</h4><p><span class="math display">\[\begin{aligned}    fact &amp; := \lambda f\ x. if\ (x &gt; 0)\ then\ (x * (f\ (x - 1)))\ else\ 1 \\    Y\ fact\ 5 &amp; = (\lambda f. (\lambda x. f\ (xx)) (\lambda x. f\ (xx)))\ fact\ 5 \\    &amp; \to_{\beta} ((\lambda x. fact\ (xx)) (\lambda x. fact\ (xx)))\ 5 \\    &amp; \to_{\beta} (fact\ ((\lambda x. fact\ (xx)) (\lambda x. fact\ (xx))))\ 5 \\    &amp; \to_{\beta} ((\lambda f\ x. if\ (x &gt; 0)\ then\ (x * (f\ (x - 1)))\ else\ 1)\ ((\lambda x. fact\ (xx)) (\lambda x. fact\ (xx))))\ 5 \\    &amp; \to_{\beta} (\lambda x. if\ (x &gt; 0)\ then\ (x * (((\lambda x. fact\ (xx)) (\lambda x. fact\ (xx)))\ (x - 1)))\ else\ 1)\ 5 \\    &amp; \to_{\beta} 5 * (((\lambda x. fact\ (xx)) (\lambda x. fact\ (xx)))\ 4) \\    &amp; \twoheadrightarrow_{\beta} 5 * (4 * (((\lambda x. fact\ (xx)) (\lambda x. fact\ (xx)))\ 3)) \\    &amp; \twoheadrightarrow_{\beta} 5 * (4 * (3 * (((\lambda x. fact\ (xx)) (\lambda x. fact\ (xx)))\ 2))) \\    &amp; \twoheadrightarrow_{\beta} 5 * (4 * (3 * (2 * (((\lambda x. fact\ (xx)) (\lambda x. fact\ (xx)))\ 1)))) \\    &amp; \twoheadrightarrow_{\beta} 5 * (4 * (3 * (2 * 1))) \\    &amp; \twoheadrightarrow_{\beta} 120\end{aligned}\]</span></p><h3 id="编程上的应用">编程上的应用</h3><h4 id="不动点函数">不动点函数</h4><p>由于在实际编程中, 绝大多数带静态类型的语言均不支持 <code>递归类型 (Recursive Type)</code>, 就如 Haskell 等, 因此就无法避免于函数应用于自身时所带来的函数类型无限递归引致停机问题, 因此于实现 <span class="math inline">\(Y\)</span>-组合子 (不动点组合子) 时我们多采用了编程语言本身的特性, 例如 Haskell 的 <span class="math inline">\(fix\)</span> 函数定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fix :: (a -&gt; a) -&gt; a</span><br><span class="line">fix f = let x = f x in x</span><br></pre></td></tr></table></figure><h4 id="recursive-scheme">Recursive Scheme</h4><p>透过不动点的概念定义出 Recursive Scheme, 我们不仅仅能够于项上定义出不动点, 同样地亦可于类型上定义出来, 例如透过 Free monad, Catamorphism, Anamorphism 等等的抽象结构, 可以站在高处以俯视的角度宏观地看待某些问题, 例如在处理抽象语法树时, 可利用该种方式消除 <code>模板代码 (boilerplate)</code> 等等.</p><h2 id="外部链接">外部链接</h2><p>本文部分内容参考或引用至下列网页，也可供作为额外的延伸资源帮助阅读：</p><ul><li><a href="http://mindhacks.cn/2006/10/15/cantor-godel-turing-an-eternal-golden-diagonal/" target="_blank" rel="noopener">康托尔、哥德尔、图灵——永恒的金色对角线</a></li><li><a href="https://ttic.uchicago.edu/~dreyer/course/papers/barendregt.pdf" target="_blank" rel="noopener">Lambda Calculi With Types - Henk Barendregt</a></li><li><a href="https://en.wikibooks.org/wiki/Haskell/Fix_and_recursion" target="_blank" rel="noopener">Haskell/Fix and recursion</a></li><li><a href="https://cs.stackexchange.com/questions/9604/clear-intuitive-derivation-of-the-fixed-point-combinator-y-combinator" target="_blank" rel="noopener">Clear, intuitive derivation of the fixed-point combinator (Y combinator)?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fixed-point_combinator&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不动点组合子 (Fixed-Point Com
      
    
    </summary>
    
    
      <category term="函数式编程" scheme="https://a9032676.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="类型论" scheme="https://a9032676.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%AE%BA/"/>
    
      <category term="逻辑" scheme="https://a9032676.github.io/tags/%E9%80%BB%E8%BE%91/"/>
    
      <category term="证明" scheme="https://a9032676.github.io/tags/%E8%AF%81%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>Lambda 立方体 与 类型系统 简记</title>
    <link href="https://a9032676.github.io/2020/09/21/Lambda-Cube-Intro/"/>
    <id>https://a9032676.github.io/2020/09/21/Lambda-Cube-Intro/</id>
    <published>2020-09-21T07:45:00.000Z</published>
    <updated>2020-11-01T05:12:28.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>在数学 (尤其指数理逻辑分支) 与类型论的世界, Lambda 立方体 是由 <a href="https://en.wikipedia.org/wiki/Henk_Barendregt" target="_blank" rel="noopener">Henk Barendregt</a> 提出的一个框架, 用以探索及研究 简单类型 <span class="math inline">\(\lambda\)</span>-演算 于不同维度上扩展出来对应的 类型系统, 其也阐述了处于不同维度上的 类型系统 中 类型 (Type) 与值 (Term) 的依赖关系 究竟是怎样的, 简单来说我们可以以三种不同方向的箭头 (维度) 定义出不同类型系统之间是怎样扩展开来的.</p><center><embed id="lambda-cube" src="/images/Lambda_Cube_img.svg" type="image/svg+xml"></center><h3 id="三种不同的维度分别代表的含义">三种不同的维度分别代表的含义</h3><ul><li>Y轴 (<span class="math inline">\(\uparrow\)</span>): 值依赖于类型, 可被对应到 <code>多态 (Polymorphism)</code> 的概念</li><li>X轴 (<span class="math inline">\(\to\)</span>): 类型依赖于值, 可被对应到 <code>依赖类型 (Dependent types)</code> 的概念</li><li>Z轴 (<span class="math inline">\(\nearrow\)</span>): 类型依赖于类型, 可被对应到 <code>类型构造器 (Type operators)</code> 的概念</li></ul><h2 id="类型系统">类型系统</h2><p>于 Lambda 立方体中, 我们会定义出不同形式的类型系统用以描述各自不同系统之间的作用与规则, 下面将会略举一些例子:</p><h3 id="lambdato-简单类型-lambda-演算">(<span class="math inline">\(\lambda\to\)</span>) 简单类型 Lambda 演算</h3><p>简单类型 Lambda 演算是 Lambda 立方体中最为简单的类型系统, 其只能够透过 <code>值依赖于值 (a term depend on a term)</code> 的方式构造出来</p><h4 id="类型推导规则">类型推导规则</h4><p>简单类型 Lambda 演算 使用了以下的<a href="https://en.wikipedia.org/wiki/Type_rule" target="_blank" rel="noopener">类型推导规则</a>:</p><ol type="1"><li><p><font size="5"><span class="math inline">\({\frac { x\ :\ \sigma\ \in\ \Gamma }{ \Gamma\ \vdash\ x\ :\ \sigma }}\)</span></font>(<span class="math inline">\(start\ rule\)</span>) <br> 假设<a href="https://en.wikipedia.org/wiki/Typing_environment" target="_blank" rel="noopener">上下文 (Typing environment)</a> <span class="math inline">\(\Gamma\)</span> 中存在 <span class="math inline">\(x\)</span> 的类型为 <span class="math inline">\(\sigma\)</span>, 则可推导出 <span class="math inline">\(x\)</span> 的类型为 <span class="math inline">\(\sigma\)</span> .</p></li><li><p><font size="5"><span class="math inline">\({\frac { \Gamma\ \vdash\ M\ :\ (\sigma\ \to\ \tau)\quad\Gamma\ \vdash\ N\ :\ \sigma }{ \Gamma\ \vdash\ (M\ N)\ :\ \tau }}\)</span></font>(<span class="math inline">\(\to-elimination\)</span>) <br> 给定上下文 <span class="math inline">\(\Gamma\)</span>, 其能推导出 <span class="math inline">\(M\)</span> 的类型为 <span class="math inline">\(\sigma \to \tau\)</span> 且 <span class="math inline">\(N\)</span> 的类型为 <span class="math inline">\(\sigma\)</span>, 则可推导出 <span class="math inline">\(M\ N\)</span> 的类型为 <span class="math inline">\(\tau\)</span> .</p></li><li><p><font size="5"><span class="math inline">\({\frac { \Gamma\ ,\ x\ :\ \sigma\ \vdash\ M\ :\ \tau }{ \Gamma\ \vdash\ (\lambda x.\ M)\ :\ (\sigma\ \to\ \tau) }}\)</span></font>(<span class="math inline">\(\to-introduction\)</span>) <br> 有 <span class="math inline">\(\Gamma\)</span> 并且有 <span class="math inline">\(x\)</span> 的类型为 <span class="math inline">\(\sigma\)</span> 该两个上下文, 假设 <span class="math inline">\(\Gamma\)</span> 能够推导出 <span class="math inline">\(M\)</span> 的类型为 <span class="math inline">\(\tau\)</span>, 则亦可推导出 <span class="math inline">\(\lambda x. M\)</span> 的类型为 <span class="math inline">\(\sigma \to \tau\)</span> .</p></li></ol><h4 id="lambdato_curry-与-lambdato_church-的差异"><span class="math inline">\(\lambda\to_{Curry}\)</span> 与 <span class="math inline">\(\lambda\to_{Church}\)</span> 的差异</h4><p><span class="math inline">\(\lambda\to_{Curry}\)</span> 与 <span class="math inline">\(\lambda\to_{Church}\)</span> 这两种系统均能表达 <span class="math inline">\(\lambda\to\)</span> 的含义, 而上述的推导规则是使用了 <span class="math inline">\(Curry\)</span> 版本编写的, 而两者的不同点则在于:</p><ul><li><span class="math inline">\(Curry\)</span> 版本的推导规则为: <span class="math inline">\(\vdash_{Curry} (\lambda x.x) : (\sigma \to \sigma)\)</span></li><li><span class="math inline">\(Church\)</span> 版本的推导规则为: <span class="math inline">\(\vdash_{Church} (\lambda x : \sigma .x) : (\sigma \to \sigma)\)</span></li></ul><p>可见一般在 <span class="math inline">\(Curry\)</span> 中的一个值 <span class="math inline">\(\lambda x. x\)</span> 将会被 <span class="math inline">\(Church\)</span> 标记为 <span class="math inline">\(: \sigma\)</span>, 即显式地标记参数 <span class="math inline">\(x\)</span> 的类型为 <span class="math inline">\(\sigma\)</span>. 由于我们能够显式地标记值上参数的类型, 因此我们就能够根据该参数的类型直接决定 (Decide) 某个值上究竟是什么类型, 而对于某些使用 <span class="math inline">\(Curry\)</span> 系统定义的规则, 在某些问题上他们是不可决定的 (Undecidable).</p><h3 id="lambda-2-系统-f">(<span class="math inline">\(\lambda 2\)</span>) 系统 F</h3><p>系统 F 相较于 简单类型 <span class="math inline">\(\lambda\)</span> 演算 只能够透过 值依赖于值 的方式去构造出一个抽象 (Abstraction), 其也能够 <code>依赖于类型的值 (terms to depend on types)</code>.</p><h4 id="类型推导规则-1">类型推导规则</h4><p>系统 F 使用的推导规则除了包含 简单类型 <span class="math inline">\(\lambda\)</span> 演算的 <span class="math inline">\(start\ rule\)</span>, <span class="math inline">\(\to-elimination\)</span> 以及 <span class="math inline">\(\to-introduction\)</span> 规则外, 额外新增了:</p><ol type="1"><li><p><font size="5"><span class="math inline">\({\frac { \Gamma\ \vdash\ M\ :\ (\forall\alpha.\ \sigma) }{ \Gamma\ \vdash\ M\ :\ (\sigma[\alpha\ :=\ \tau]) }}\)</span></font>, <span class="math inline">\(\tau \in \Bbb{T}\)</span> (<span class="math inline">\(\forall-elimination\)</span>) <br> 给定上下文 <span class="math inline">\(\Gamma\)</span>, 其能推导出 值 <span class="math inline">\(M\)</span> 有类型 <span class="math inline">\(\forall\alpha. \sigma\)</span>, 则亦可推导出 <span class="math inline">\(M\)</span> 的类型为 <span class="math inline">\(\sigma[\alpha := \tau]\)</span> (在这里 <span class="math inline">\(\tau\)</span> 为实际的类型, <span class="math inline">\(\alpha\)</span> 为类型参数, 也就是 类型 <span class="math inline">\(\sigma\)</span> 依赖于 <span class="math inline">\(\alpha\)</span> 的值, 即 <span class="math inline">\(\tau\)</span>).</p></li><li><p><font size="5"><span class="math inline">\({\frac { \Gamma\ \vdash\ M\ :\ \sigma }{ \Gamma\ \vdash\ (\Lambda \alpha. M)\ :\ (\forall\alpha.\sigma) }}\)</span></font>,<span class="math inline">\({\ \alpha \notin FV(\Gamma)}\)</span> (<span class="math inline">\(\forall-introduction\)</span>) <br> 给定上下文 <span class="math inline">\(\Gamma\)</span> 且 <span class="math inline">\(\alpha\)</span> 不是 <span class="math inline">\(\Gamma\)</span> 的 自由变量, 其能推导出 <span class="math inline">\(M\)</span> 有类型 <span class="math inline">\(\sigma\)</span>, 则该上下文亦可推导出 <span class="math inline">\(M\)</span> 有类型 <span class="math inline">\(\forall\alpha. \sigma\)</span> (值上的 <span class="math inline">\(\Lambda \alpha\)</span> 可显式指定 <span class="math inline">\(\alpha\)</span> 的类型).</p></li></ol><h5 id="进一步的扩展规则">进一步的扩展规则</h5><p>除了上述的两条规则外, 由于系统 F, 即 <span class="math inline">\(\lambda 2\)</span>, 与 <span class="math inline">\(\lambda\mu\)</span> 以及 <span class="math inline">\(\lambda P\)</span> <span class="math inline">\((\lambda\cap)\)</span>, 均是由 <span class="math inline">\(\lambda\to\)</span> 延伸出来的, 这些系统都能够加入 <span class="math inline">\(equality\ rule\ (EQ)\)</span> 与 <span class="math inline">\(approximation\ rule\ (A)\)</span> 作推导, 亦能够相互组合出诸如 <span class="math inline">\(\lambda 2\mu\)</span> 或 <span class="math inline">\(\lambda\mu\cap\)</span> 等更强的系统.</p><ol type="1"><li><p><font size="5"><span class="math inline">\({\frac { M\ :\ \sigma \quad M\ =_{\beta} \ N }{ N\ :\ \sigma }}\)</span></font>(<span class="math inline">\(EQ\)</span>) <br> 设有值 <span class="math inline">\(M : \sigma\)</span> 且已知 <span class="math inline">\(M = N\)</span>, 则可推导出 <span class="math inline">\(N\)</span> 的类型为 <span class="math inline">\(\sigma\)</span> .</p></li><li><p><font size="5"><span class="math inline">\({\frac { \Gamma\ \vdash\ P\ :\ \sigma\ for\ all\ P\ \in\ A(M) }{ \Gamma\ \vdash\ M\ :\ \sigma }}\)</span></font>(<span class="math inline">\(A\)</span>)</p></li><li><p><font size="5"><span class="math inline">\({\frac {}{ \Gamma\ \vdash\ \bot\ :\ \sigma }}\)</span></font>(<span class="math inline">\(A\)</span>)</p></li></ol><h4 id="编程上的例子">编程上的例子</h4><p>该规则的定义恰恰对应到了许多编程语言中 <code>多态化参数 (Parametric polymorphism)</code> 的特性, 例如于 Haskell 中 <code>id</code>, <code>const</code>, <code>justInt</code> 以及 <code>intOrStr</code> 的定义实际为: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">id :: forall a. a -&gt; a</span><br><span class="line">id x = x</span><br><span class="line"></span><br><span class="line">const :: forall a b. a -&gt; b -&gt; a</span><br><span class="line">const x y = x</span><br><span class="line"></span><br><span class="line">justInt :: Maybe Int</span><br><span class="line">justInt = Just 123</span><br><span class="line"></span><br><span class="line">intOrStr :: Either Int String</span><br><span class="line">intOrStr = Right &quot;foo&quot;</span><br></pre></td></tr></table></figure></p><p>我们能够透过 <code>forall a.</code> 与 <code>forall a b.</code> 以显式捕获这些函数的多态参数.</p><p>而我们可以将上述例子对应到推导的表达式, 正如: <span class="math inline">\((\Lambda a. \lambda x. x) : (\forall a. a \to a) \vdash_{\lambda 2} (\lambda x. x) : ((a \to a)[a := \tau])\)</span> <span class="math inline">\((\Lambda a\ b. \lambda x\ y. x) : (\forall a\ b. a \to b \to a) \vdash_{\lambda 2} (\lambda x\ y. x) : ((a \to b \to a)[a := \tau_1, b := \tau_2])\)</span> <span class="math inline">\((Just\ 123) : (Maybe\ Int) \vdash_{\lambda 2} (Just\ 123) : Maybe[\alpha := Int]\)</span> <span class="math inline">\((Right\ &quot;foo&quot;) : (Either\ Int\ String) \vdash_{\lambda 2} (Right\ &quot;foo&quot;) : Either[\alpha := Int, \beta := String]\)</span></p><h3 id="lambdaunderlineomega-系统-lambdaunderlineomega">(<span class="math inline">\(\lambda\underline{\omega}\)</span>) 系统 <span class="math inline">\(\lambda\underline{\omega}\)</span></h3><p>系统 <span class="math inline">\(\lambda\underline{\omega}\)</span> 相较于 简单类型 <span class="math inline">\(\lambda\)</span> 演算 只能够透过 值依赖于值 的方式以构造出一个抽象, 其允许了 <code>类型依赖于类型 (types to depend on types)</code> 的情况出现.</p><h4 id="kind-的引入">Kind (<span class="math inline">\(*\)</span>) 的引入</h4><p>由于 <span class="math inline">\(\lambda\underline{\omega}\)</span> 需要表达出类型依赖于类型的概念, 正如 <span class="math inline">\(\alpha \to \alpha\)</span> 一样, <span class="math inline">\(\alpha\)</span> (即函数的协变位置) 依赖于 <span class="math inline">\(\alpha\)</span> (函数的逆变位置), 因此我们需要引入 <span class="math inline">\(Kind\)</span>, 即 <code>类型的类型</code> 的概念. 例如把一个 <span class="math inline">\(Kind\)</span> 的表达式定义为 <span class="math inline">\(\alpha, \beta \in \Bbb{T} \implies (\alpha \to \beta) : \Bbb{T}\)</span>, 这里不难看出 <span class="math inline">\(\alpha, \beta, (\alpha \to \beta) \in \Bbb{T}\)</span>, 因此 <span class="math inline">\(\Bbb{T}\)</span> 亦可被称之为类型的类型, 即 <span class="math inline">\(Kind\)</span>, 形式化地整句表达式可被定义为 <span class="math inline">\(\alpha : *, \beta : * \vdash (\alpha \to \beta) : *\)</span> (使用 <span class="math inline">\(\sigma : *\)</span> 取代了 <span class="math inline">\(\sigma \in \Bbb{T}\)</span>).</p><h4 id="kind-集合-bbbk-与-kind-构造器-类型构造器">Kind 集合 (<span class="math inline">\(\Bbb{K}\)</span>) 与 <span class="math inline">\(Kind\)</span> 构造器 (类型构造器)</h4><p>由于 <span class="math inline">\(Kind\)</span> 的表达式, 如 <span class="math inline">\(f \equiv \lambda\alpha : *. \alpha \to \alpha\)</span> 中, <span class="math inline">\(f\)</span> 既不处于值上, 亦不是居留在类型上, 因此我们需要定义出一个新的集合负责存储起这些 <span class="math inline">\(kinds\)</span> : <span class="math display">\[\Bbb{K} = *\ |\ \Bbb{K} \to \Bbb{K}\]</span> 即有 <span class="math inline">\(\Bbb{K} = \lbrace *, * \to *, * \to * \to *, ... \rbrace\)</span>. 若果 <span class="math inline">\(\vdash k : \Box\)</span> 且 <span class="math inline">\(\vdash F : k\)</span> (这里的 <span class="math inline">\(k : \Box\)</span> 实际上对应了 <span class="math inline">\(k \in \Bbb{K}\)</span>), 则 <span class="math inline">\(F\)</span> 被称之为 <span class="math inline">\(kind\ k\)</span> 的构造器 (类型构造器).</p><h4 id="类型推导规则-2">类型推导规则</h4><ol type="1"><li><p><span class="math inline">\(&lt;&gt; \vdash * : \Box\)</span> (<span class="math inline">\(axiom\)</span>) 空的上下文总能被推导出 <span class="math inline">\(* : \Box\)</span></p></li><li><p><font size="5"><span class="math inline">\({\frac{ \Gamma\ \vdash\ A\ :\ s }{ \Gamma,\ x\ :\ A\ \vdash\ x\ :\ A }}\)</span></font>, <span class="math inline">\(x \notin \Gamma\)</span> (<span class="math inline">\(start\ rule\)</span>)</p></li><li><p><font size="5"><span class="math inline">\({\frac{ \Gamma\ \vdash\ A\ :\ B \quad \Gamma\ \vdash\ C\ :\ s }{ \Gamma,\ x\ :\ C\ \vdash\ A\ :\ B }}\)</span></font>, <span class="math inline">\(x \notin \Gamma\)</span> (<span class="math inline">\(weakening\ rule\)</span>)</p></li><li><p><font size="5"><span class="math inline">\({\frac{ \Gamma\ \vdash\ A\ :\ s \quad \Gamma\ \vdash\ B\ :\ s }{ \Gamma\ \vdash\ (A\ \to\ B)\ :\ s }}\)</span></font>(<span class="math inline">\(type/kind\ formation\)</span>) <br> 这里的 <span class="math inline">\(formation-rule\)</span> 指的是怎样把某一个 <span class="math inline">\(kind\)</span> (这里是 <span class="math inline">\(s\)</span>) 构建成一个类型, 例如这里则是当有 <span class="math inline">\(A\)</span> 以及 <span class="math inline">\(B\)</span> 皆为类型时, 则能构筑表达式 <span class="math inline">\(A \to B\)</span> 是一接受 <span class="math inline">\(A\)</span> 类型并且返回 <span class="math inline">\(B\)</span> 类型的函数.</p></li><li><p><font size="5"><span class="math inline">\({\frac{ \Gamma\ \vdash\ F\ :\ (A\ \to\ B) \quad \Gamma\ \vdash\ a\ :\ A }{ \Gamma\ \vdash\ Fa\ :\ B }}\)</span></font>(<span class="math inline">\(application\ rule\)</span>)</p></li><li><p><font size="5"><span class="math inline">\({\frac{ \Gamma,\ x\ :\ A\ \vdash\ b\ :\ B \quad \Gamma\ \vdash\ (A\ \to\ B)\ :\ s }{ \Gamma\ \vdash\ (\lambda x\ :\ A.\ b)\ :\ (A\ \to\ B) }}\)</span></font>(<span class="math inline">\(abstraction\ rule\)</span>)</p></li><li><p><font size="5"><span class="math inline">\({\frac{ \Gamma\ \vdash\ A\ :\ B \quad \Gamma\ \vdash\ B&#39;\ :\ s \quad B\ =_{\beta}\ B&#39; }{ \Gamma\ \vdash\ A\ :\ B&#39; }}\)</span></font>(<span class="math inline">\(conversion\ rule\)</span>)</p></li></ol><h4 id="编程上的例子-1">编程上的例子</h4><p>于 Haskell 中, 我们得知一个 <code>Functor (f :: * -&gt; *)</code> 其本身是一类型构造器, 现在则可利用 <span class="math inline">\(\lambda\to\)</span> 以及 <span class="math inline">\(\lambda\underline{\omega}\)</span> 的规则, 对 <code>fmap (*2) [1..10]</code> (或 <code>(*2) &lt;$&gt; [1..10]</code>) 进行简单的类型推导:</p><p><font size="1"><span class="math display">\[\dfrac    {        \dfrac            {                \dfrac                    {                        \begin{aligned}                            \vdots                        \end{aligned}                    }                    { \Gamma, l : [a] \vdash fmap\ (*2) : [b] }                \quad                \dfrac                    {                        \dfrac                            { \Gamma \vdash [] : (* \to *) \quad \Gamma \vdash a : * }                            { \Gamma \vdash [a] : * }                            (\lambda\underline{\omega}\ app.)                        \quad                        \dfrac                            { \Gamma \vdash [] : (* \to *) \quad \Gamma \vdash b : * }                            { \Gamma \vdash [b] : * }                            (\lambda\underline{\omega}\ app.)                    }                    { \Gamma \vdash ([a] \to [b]) : * }                    (\lambda\underline{\omega}\ form.)            }            { \Gamma \vdash \lambda l. fmap\ (*2) : ([a] \to [b]) }            (\lambda\underline{\omega}\ abst.)        \quad        \dfrac            {                \begin{align}                \vdots \\                \end{align}            }            { \Gamma \vdash [1..10] : [a] }    }    { \Gamma \vdash fmap\ (*2)\ [1..10] : [b] }    (\lambda\to elim.)\]</span></font></p><h3 id="lambda-p-lambda-p">(<span class="math inline">\(\lambda P\)</span>) Lambda-P</h3><p>系统 <span class="math inline">\(\lambda P\)</span> 相较于 简单类型 <span class="math inline">\(\lambda\)</span> 演算 只能够透过 值依赖于值 的方式以构造出一个抽象, 亦可于类型上以值作为参数, 正如一个直观的例子 <span class="math inline">\(A^n \to B\)</span> 阐述了 <span class="math inline">\(n\)</span> 实际上是一个值 (例如一个自然数), <span class="math inline">\(A\)</span> 与 <span class="math inline">\(B\)</span> 是类型, 而我们需要构造 <span class="math inline">\(B\)</span> 的时候则必须传入一个值, 因此可被描述为 <code>依赖于值的类型 (types to depend on terms)</code>.</p><h4 id="类型推导规则-3">类型推导规则</h4><p>系统 <span class="math inline">\(\lambda P\)</span> 使用了如下规则进行推导 (其中 <span class="math inline">\(*\)</span> 与 <span class="math inline">\(\Box\)</span> 为 <span class="math inline">\(\lambda P\)</span> 表达式中的常量):</p><ol type="1"><li><p><span class="math inline">\(&lt;&gt;\ \vdash * : \Box\)</span> (<span class="math inline">\(axiom\)</span>) 空的上下文总能被推导出 <span class="math inline">\(* : \Box\)</span></p></li><li><p><font size="5"><span class="math inline">\({\frac { \Gamma\ \vdash\ A\ :\ s }{ \Gamma,\ x\ :\ A\ \vdash\ x\ :\ A }}\)</span></font>, <span class="math inline">\(x \notin \Gamma\)</span> (<span class="math inline">\(start\ rule\)</span>)</p></li><li><p><font size="5"><span class="math inline">\({\frac { \Gamma\ \vdash\ A\ :\ B \quad \Gamma\ \vdash\ C\ :\ s }{ \Gamma,\ x\ :\ C\ \vdash\ A\ :\ B }}\)</span></font>, <span class="math inline">\(x \notin \Gamma\)</span> (<span class="math inline">\(weakening\ rule\)</span>)</p></li><li><p><font size="5"><span class="math inline">\({\frac { \Gamma\ \vdash\ A\ :\ * \quad \Gamma,\ x\ :\ A\ \vdash\ B\ :\ s }{ \Gamma\ \vdash\ (\Pi x\ :\ A.\ B)\ :\ s }}\)</span></font>(<span class="math inline">\(type/kind\ formation\)</span>)</p></li><li><p><font size="5"><span class="math inline">\({\frac{ \Gamma\ \vdash\ F\ :\ (\Pi x\ :\ A.\ B) \quad \Gamma\ \vdash\ a\ :\ A }{ \Gamma\ \vdash\ Fa\ :\ B[x\ :=\ a] }}\)</span></font>(<span class="math inline">\(application\ rule\)</span>)</p></li><li><p><font size="5"><span class="math inline">\({\frac{ \Gamma,\ x\ :\ A\ \vdash\ b\ :\ B \quad \Gamma\ \vdash\ (\Pi x\ :\ A.\ B)\ :\ s }{ \Gamma\ \vdash\ (\lambda x\ :\ A.\ b)\ :\ (\Pi x\ :\ A.\ B) }}\)</span></font>(<span class="math inline">\(abstraction\ rule\)</span>)</p></li><li><p><font size="5"><span class="math inline">\({\frac{ \Gamma\ \vdash\ A\ :\ B \quad \Gamma\ \vdash\ B&#39;\ :\ s \quad B\ =_{\beta}\ B&#39; }{ \Gamma\ \vdash\ A\ :\ B&#39; }}\)</span></font>(<span class="math inline">\(conversion\ rule\)</span>)</p></li></ol><h3 id="lambdaomega-系统-lambdaomega">(<span class="math inline">\(\lambda\omega\)</span>) 系统 <span class="math inline">\(\lambda\omega\)</span></h3><p>系统 <span class="math inline">\(\lambda\omega\)</span> 结合了 <span class="math inline">\(\lambda 2\)</span> 的 <span class="math inline">\(\Lambda\)</span> 构造器, <span class="math inline">\(\lambda\underline{\omega}\)</span> 的 类型构造器 与他们各自的推导规则, 其允许了 <code>依赖于类型的值 (terms to depend on types)</code> 以及 <code>类型依赖于类型 (types to depend on types)</code> 同时存在, 因此从计算的角度来看, 其表达能力非常强, 同时亦被认为具备编程语言所需达到的基础.</p><h3 id="lambda-c-系统-lambda-c">(<span class="math inline">\(\lambda C\)</span>) 系统 <span class="math inline">\(\lambda C\)</span></h3><p>系统 <span class="math inline">\(\lambda C\)</span> 位于 Lambda 立方 的最右上角, 其包含了来自于 <span class="math inline">\(\lambda P\)</span> 逻辑谓词的表达能力 与 <span class="math inline">\(\lambda\omega\)</span> 的计算能力, 因此无论是从逻辑或是计算的角度考量, 均被视为极度具备强大能力的一套类型系统.</p><h2 id="与逻辑系统的关系">与逻辑系统的关系</h2><p>透过 <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence" target="_blank" rel="noopener">Curry-Howard 同构</a>, 我们得以将 Lambda 立方体 中的类型系统与逻辑系统一一对应起来, 如下表:</p><table><thead><tr class="header"><th style="text-align: center;">类型系统</th><th style="text-align: center;">逻辑系统</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\lambda\to\)</span></td><td style="text-align: center;">(一阶) <a href="https://en.wikipedia.org/wiki/Propositional_calculus" target="_blank" rel="noopener">命题逻辑</a></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\lambda 2\)</span></td><td style="text-align: center;"><a href="https://en.wikipedia.org/wiki/Second-order_propositional_logic" target="_blank" rel="noopener">二阶命题逻辑</a></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\lambda\underline{\omega}\)</span></td><td style="text-align: center;">弱高阶命题逻辑</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\lambda\omega\)</span></td><td style="text-align: center;"><a href="https://en.wikipedia.org/wiki/Higher-order_logic" target="_blank" rel="noopener">高阶命题逻辑</a></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\lambda P\)</span></td><td style="text-align: center;"><a href="https://en.wikipedia.org/wiki/First-order_logic" target="_blank" rel="noopener">一阶谓词逻辑</a></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\lambda P2\)</span></td><td style="text-align: center;"><a href="https://en.wikipedia.org/wiki/Second-order_logic" target="_blank" rel="noopener">二阶谓词逻辑</a></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\lambda P\underline{\omega}\)</span></td><td style="text-align: center;">弱高阶谓词逻辑</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\lambda C\)</span></td><td style="text-align: center;"><a href="https://en.wikipedia.org/wiki/Calculus_of_constructions" target="_blank" rel="noopener">构造演算</a></td></tr></tbody></table><h2 id="外部链接">外部链接</h2><p>本文部分内容参考或引用至下列网页，也可供作为额外的延伸资源帮助阅读：</p><ul><li><a href="https://en.wikipedia.org/wiki/Lambda_cube" target="_blank" rel="noopener">Lambda Cube - Wikipedia</a></li><li><a href="https://ttic.uchicago.edu/~dreyer/course/papers/barendregt.pdf" target="_blank" rel="noopener">Lambda Calculi With Types - Henk Barendregt</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;在数学 (尤其指数理逻辑分支) 与类型论的世界, Lambda 立方体 是由 &lt;a href=&quot;https://en.wikipedia.org/wiki/Henk_Barendregt&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
    
      <category term="函数式编程" scheme="https://a9032676.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="类型论" scheme="https://a9032676.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%AE%BA/"/>
    
      <category term="逻辑" scheme="https://a9032676.github.io/tags/%E9%80%BB%E8%BE%91/"/>
    
      <category term="计算机编程理论" scheme="https://a9032676.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>一个 Haskeller 的范畴论入坑笔记 第四章：始对象，终对象与零对象</title>
    <link href="https://a9032676.github.io/2019/09/29/Category-Theory-4/"/>
    <id>https://a9032676.github.io/2019/09/29/Category-Theory-4/</id>
    <published>2019-09-29T14:19:24.000Z</published>
    <updated>2020-09-21T07:31:53.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>上一章介绍了除集合范畴以外一些其他范畴的例子，而对于任意范畴而言，往往是由态射把不同对象链接在一起形成某些关系。而既然我们已经知道了一些不同种类态射与范畴，当然对象也不会例外，透过对对象种类的划分，我们同样地可以得出一些不同的结论出来，因此我们今天就来探讨下关于范畴内对象的一些关系吧。</p><h2 id="泛构造universal-construction">泛构造（Universal Construction）</h2><p>在范畴论的语言中，我们常常都会把对象之间透过态射连接起来，但我们从来都没有 "谈对象"，例如在使用 <span class="math inline">\(Commuting-diagram\)</span> 构造一个 <span class="math inline">\(C_{Set}\)</span> 的范畴时我们从来就没有关心过集合里面究竟是由啥具体的整数被映射至啥具体的整数，如：1 / 2 / 3 等等，他们通常只会在具体的例子中出现，而不会在构造时被搬上台面。所以要知道在范畴论上，我们通常谈的是一个被抽象出来的泛概念，对于任何对象我们不会谈对象的本身，而只会把对象与态射连接起来，给定一些特性或特质，然后我们可以给满足某些特性的对象分类，于是乎我们会说："哦！原来满足这些特征那就是一个始对象，而满足这些特征那就是终对象！"。</p><h3 id="范性质universal-property">范性质（Universal Property）</h3><h2 id="对象的种类type-of-objects">对象的种类（Type of Objects）</h2><p>透过泛构造，我们可以在不提及对象是什么的情况下，给定不同的规则，形成不同种类的对象，下面则会列出一些常见的对象类型。</p><h3 id="始对象initial-object">始对象（Initial Object）</h3><p>始对象有着初始，开始的意思，其在范畴中那意味着最初始的那个对象，任何一切都是由此处开始，当然地这个对象也只能够由其本身存在的唯一态射给映射到别的对象中，公理化的性质可描述为： - 当 <span class="math inline">\(I\)</span> 作为始对象时，<span class="math inline">\(\forall X \in C, Hom_C(I, X)\)</span> 当中仅存在唯一态射（Unique morphism） - 当 <span class="math inline">\(I\)</span> 作为始对象时，<span class="math inline">\(\forall X \in C, |C(I, X)| = 1\)</span></p><p>下面是不同范畴作为始对象的一些例子： - 对于 <span class="math inline">\(C_{Set}\)</span>，始对象则是空集合，因为对于集合来说，存在唯一态射的元素（对象）则只有空集合。（下设 <span class="math inline">\(I\)</span> 作为始对象，当我们存在映射 <span class="math inline">\(f : I \to X\)</span> 时，把其作为笛卡儿积 <span class="math inline">\(I \times X \in f\)</span> 来看待，这时候它仅存在唯一元素，也就是 <span class="math inline">\(\varnothing \to X\)</span>，这正正符合了满射函数的定律，我们称之为空函数。） - 对于 <span class="math inline">\(C_{Group}\)</span>，始对象是平凡群（Trivial Group）。（由单元素组成的群，其运算只有 <span class="math inline">\(e + e = e\)</span>）</p><h3 id="终对象terminal-object">终对象（Terminal Object）</h3><p>做人要有始有终，那范畴论当然也不例外！而对于终对象，其与始对象的性质完全相反，公理化的性质可描述为： - 当 <span class="math inline">\(T\)</span> 作为终对象时，<span class="math inline">\(\forall X \in C, Hom_C(X, T)\)</span> 当中仅存在唯一态射 - 当 <span class="math inline">\(T\)</span> 作为终对象时，<span class="math inline">\(\forall X \in C, |C(X, T)| = 1\)</span></p><p>下面是不同范畴作为终对象的一些例子： - 对于 <span class="math inline">\(C_{Set}\)</span>，终对象则是单元素集合（Singleton Set），因为对于集合来说，我们没办法从非空集合态射到一个空集合（试想一下若果培域是空集，那么就不存在任何态射从定义域映射到值域了），存在唯一态射的元素（对象）则只有单元素集合。 - 对于 <span class="math inline">\(C_{Group}\)</span>，终对象也是平凡群。</p><h3 id="零对象zero-objector-null-object">零对象（Zero Object（or Null Object））</h3><p>当一个对象，它同时是始对象以及终对象时，那么我们把它称为零对象。因此它的性质可被描述为： - 当 <span class="math inline">\(0\)</span> 作为零对象时，<span class="math inline">\(\forall 0 \in C, 有 \exists! f \exists! g. f : A \to 0 \land g : 0 \to A\)</span></p><p>下面是不同范畴作为零对象的一些例子： - 由于平凡群同时是始对象与终对象，因此它自然是一个零对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;上一章介绍了除集合范畴以外一些其他范畴的例子，而对于任意范畴而言，往往是由态射把不同对象链接在一起形成某些关系。而既然我们已经知道了一些不同种类态射与范畴，当然对象也不会例外，透过对对象种类的划分，我们同样地可以得出一些不同的结论出来
      
    
    </summary>
    
    
      <category term="范畴论" scheme="https://a9032676.github.io/tags/%E8%8C%83%E7%95%B4%E8%AE%BA/"/>
    
      <category term="函数式编程" scheme="https://a9032676.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一个 Haskeller 的范畴论入坑笔记 第三章：排序关系，幺半群与 Thin 和 Kleisli 范畴</title>
    <link href="https://a9032676.github.io/2019/08/26/Category-Theory-3/"/>
    <id>https://a9032676.github.io/2019/08/26/Category-Theory-3/</id>
    <published>2019-08-25T16:04:44.000Z</published>
    <updated>2020-10-16T03:35:06.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>为什么上两篇范畴论笔记大多数都是针对范畴与函数的关系，难道其他关系不能抽象成一个范畴吗？这个答案当然是否定的，前两篇是借助了函数的概念以更好地理解复合或同态究竟是些什么东西，因此而从本篇开始，我们来说一些与函数关系不大的一些知识吧！</p><h2 id="概念">概念</h2><p>既然范畴论里面我们要讨论的东西无非就是各种态射复合（Morphism composition），就连排序关系也不例外，在第一章时就已讲述了相关概念，这里就不再重提。而我们现在要知道的是除了第二章提及的函数关系外，我们究竟还可以拿复合来研究些什么，而排序就是一个很好例子了。</p><p>例如我们有时候会说 <span class="math inline">\(a\)</span> 小于或等于 <span class="math inline">\(b\)</span>，而 <span class="math inline">\(b\)</span> 小于或等于 <span class="math inline">\(c\)</span>，那么必然蕴含了 <span class="math inline">\(a \leq c\)</span>（传递性），这里不难看出实际上排序关系其实也是一个简单的复合，只不过我们把对应的态射给替换成具体我们定义的二元关系 <span class="math inline">\(\leq\)</span> 罢了。 <span class="math display">\[a \xrightarrow[\leq]{} b \xrightarrow[\leq]{} c \\\\a \xrightarrow[\leq]{} c\]</span></p><h2 id="排序关系order-relationship">排序关系（Order Relationship）</h2><p>排序关系是对排序在直觉上的自然诠释，同样是属于一种二元关系，它们各自有不同的特性，下面将会介绍一些较为常见的排序关系。</p><h3 id="预序preorderquasiorder">预序（Preorder（Quasiorder））</h3><p>预序关系满足了自反性（Reflexive）及传递性（Transitive），作为排序关系来讲预序可以将其概念进一步推广至等价关系以及非严谨（Non-Strict）的偏序关系。而由预序关系所组成的集合被称为预序集合（Preordered set or Proset）</p><p>现在设 <span class="math inline">\(\leq\)</span> 是 P 上的二元关系，若果满足下列性质，则称这是一个预序关系，例如： - 自反性：<span class="math inline">\(\forall a \in P, a \leq a\)</span> - 传递性：<span class="math inline">\(\forall a, b, c \in P\)</span>，若 <span class="math inline">\(a \leq b\)</span> 且 <span class="math inline">\(b \leq c\)</span>，则 <span class="math inline">\(a \leq c\)</span></p><h3 id="偏序partial-order">偏序（Partial order）</h3><p>如果我们将预序进行推广，并加上反对称性（Anti-symmetric）作为约束，那么我们说这个二元关系就是偏序关系。</p><p>现在设 <span class="math inline">\(\leq\)</span> 是 P 上的二元关系，若果满足下列性质，则称这是一个偏序关系，例如： - 自反性：<span class="math inline">\(\forall a \in P, a \leq a\)</span> - 传递性：<span class="math inline">\(\forall a, b, c \in P\)</span>，若 <span class="math inline">\(a \leq b\)</span> 且 <span class="math inline">\(b \leq c\)</span>，则 <span class="math inline">\(a \leq c\)</span> - 反对称性：<span class="math inline">\(\forall a, b \in P\)</span>，若 <span class="math inline">\(a \leq b\)</span> 且 <span class="math inline">\(b \leq a\)</span>，则蕴含了 <span class="math inline">\(a = b\)</span></p><h3 id="全序total-order">全序（Total order）</h3><p>同样地，我们甚至可以再将预序关系进一步推广，设 <span class="math inline">\(R\)</span> 为二元关系，限制某一个序的二元关系为 <span class="math inline">\(aRb \lor bRa\)</span>，即完全性（Connex）作为约束，那么得出来的这个关系就叫做全序关系。</p><p>现在设 <span class="math inline">\(\leq\)</span> 是 P 上的二元关系，若果满足下列性质，则称这是一个全序关系，例如： - 传递性：<span class="math inline">\(\forall a, b, c \in P\)</span>，若 <span class="math inline">\(a \leq b\)</span> 且 <span class="math inline">\(b \leq c\)</span>，则 <span class="math inline">\(a \leq c\)</span> - 反对称性：<span class="math inline">\(\forall a, b \in P\)</span>，若 <span class="math inline">\(a \leq b\)</span> 且 <span class="math inline">\(b \leq a\)</span>，则蕴含了 <span class="math inline">\(a = b\)</span> - 完全性：<span class="math inline">\(\forall a, b \in P, a \leq b \lor b \leq a\)</span> （但注意其已蕴含了自反关系，因为 <span class="math inline">\(\forall a, b \in P, a \leq a \lor b \leq b\)</span>）</p><h2 id="排序在范畴论上的关系order-in-category-theory">排序在范畴论上的关系（Order in Category Theory）</h2><p>对于上面的排序关系，如果把它们的性质在范畴论中呈现出来又是怎么样的呢？其实也是很简单的，因为上面所提及到的排序关系其实天然就是一种范畴，比如在开头时我们举过的例子：对于最基础的排序关系，也就是预序关系，我们可以很轻易地把它对应到范畴论上的概念，就如同把二元关系（<span class="math inline">\(\leq\)</span>）替换成态射（<span class="math inline">\(\to\)</span>）一样，这就已经满足了传递性质了。</p><p>那么自反性呢？对于自反这一概念，由于我们上面已经得知自反的定义，其实不难发现其实也就是范畴上恰巧有一个态射的跟自反性的概念一模一样，那就是单位元态射（Identity morphism）了（因为同样地可以把 <span class="math inline">\(\leq\)</span> 替换成单位元态射 <span class="math inline">\(id_a\)</span>，例如：$ a  a $）。</p><h3 id="hom-集合hom-set">Hom-集合（Hom-set）</h3><p>我们的范畴并不总是只有一个态射在其内，而是可以存在很多态射由不同的对象映射到范畴内的其他对象去，例如在范畴 <span class="math inline">\(C\)</span> 内我们有 <span class="math inline">\(a\)</span> 与 <span class="math inline">\(b\)</span> 这两个对象，存在态射 <span class="math inline">\(f, g, h\)</span>，它们均是由 <span class="math inline">\(a\)</span> 被态射至对象 <span class="math inline">\(b\)</span> 上，因此这些态射本身可以组成一个由 <span class="math inline">\(a\)</span> 态射至 <span class="math inline">\(b\)</span> 的 Hom-集合，一般写作 <span class="math inline">\(C(a, b)\)</span> 或 <span class="math inline">\(hom_C (a, b)\)</span>。</p><h4 id="与态射复合的关系relationship-with-composition">与态射复合的关系（Relationship with composition）</h4><p>态射复合对于 Hom-集合 来讲也是可以被公理化地写出来的，例如存在对象 <span class="math inline">\(a, b, c\)</span>，对于态射 <span class="math inline">\(f \in hom(a, b)\)</span> 以及 <span class="math inline">\(g \in hom(b, c)\)</span>，我们可以写成这样： <span class="math display">\[ hom(a, b) \times hom(b, c) \implies hom(a, c) \]</span></p><h3 id="小范畴与大范畴small-and-large-category">小范畴与大范畴（Small and large category）</h3><h3 id="thin-范畴thin-categoryor-posetal-category">Thin 范畴（Thin Category（or Posetal category））</h3><p>当然地，满足了上述性质的范畴当然有个名字，被称为 Thin 范畴，含义即 “瘦” 的意思，也就是当一个范畴内当且仅当存在唯一态射，那么这个范畴就会 “瘦” 到只剩这么一个了。</p><p>设有 <span class="math inline">\(hom_C (a, b)\)</span>，分别由 <span class="math inline">\(f\)</span> 与 <span class="math inline">\(g\)</span> 从 <span class="math inline">\(a\)</span> 被态射至 <span class="math inline">\(b\)</span>，则蕴含了 <span class="math inline">\(f = g\)</span>，形式化定义为： <span class="math display">\[ a \overset{f}{\underset{g}\rightrightarrows} b \implies f=g \]</span></p><h4 id="是或不是一个-thin-范畴is-or-not-a-thin-category">是或不是一个 Thin 范畴？（Is or not a Thin category?）</h4><p>有时候一些范畴看着并不像是一个 Thin 范畴，假设有范畴 <span class="math inline">\(C\)</span>，且存在对象 <span class="math inline">\(a, b, c, d\)</span>，而在 <span class="math inline">\(Commutative-Diagram\)</span> 上如下：</p><p><span class="math display">\[ \array{&amp; a &amp; \overset{f}\rightarrow &amp; b &amp; \\\\            f&#39; &amp; \downarrow &amp;&amp;\downarrow &amp; g \\\\           &amp;c &amp; \underset{g&#39;}\rightarrow&amp; d &amp; \\\\} \]</span></p><p>我们可以注意到在这个例子中 <span class="math inline">\(hom(a, d)\)</span> 上都看似存在着两条路径，貌似直觉上告诉我们这不是一个 Thin 范畴，因为 “当且仅当存在唯一态射” 这句话告诉了我们如果多于一个态射，那它就不算是 Thin 范畴。</p><p>但事实真是这样吗？要知道范畴最重要的概念之一就是态射复合，而当我们把 <span class="math inline">\(f \circ g\)</span> 之后它的态射实际会相等于 <span class="math inline">\(f&#39; \circ g&#39;\)</span>，因为： <span class="math display">\[ hom(a, b) \times hom(b, d) = hom(a, c) \times hom(c, d) \implies hom(a, d) \]</span></p><p>所以实际上透过态射复合后，这两条路径在交换图上的态射将被视为等价的，亦即只被视为存在唯一态射，而不是两个态射，因此这也是属于 Thin 范畴。</p><h4 id="与预序集合的关系relationship-with-proset">与预序集合的关系（Relationship with proset）</h4><p>我们常常会把预序集合在范畴论上视作为 Thin 范畴，当然它天生也就是一个 Thin 范畴，但这又怎么去解释呢？现在先假设我们要去比较一个自然数，且他们，例如我们要整除 <span class="math inline">\(6\)</span> 这个数，并将整除结果由预序关系排列出来，可得：<span class="math inline">\(3 \leq 6\)</span>，<span class="math inline">\(2 \leq 6\)</span>，<span class="math inline">\(1 \leq 6\)</span>，可见无论是先 <span class="math inline">\(1 \leq 3 \leq 6\)</span> 或是 <span class="math inline">\(1 \leq 2 \leq 6\)</span>，最终的结果都会是 <span class="math inline">\(1 \leq 6\)</span>。这里就是一个态射复合后，它们的结果始终相同的一个例子，而最终 <span class="math inline">\(\leq\)</span> 在态射复合后始终都只有存在唯一态射，而不像函数那样大多数情况均有很多态射从定义域被映射到值域，因此这符合了 Thin 范畴的定义，并且天然是一个 Thin 范畴了。</p><h4 id="与偏序集合的关系relationship-with-poset">与偏序集合的关系（Relationship with poset）</h4><p>一般来说既然我们可以对预序集合和 Thin 范畴产生联系，那么按理来说偏序集合与 Thin 范畴也是可以对应得上的。而这里得知偏序实际只比预序关系多了反对称的特性，但这并没有使得偏序集合上会多于唯一的态射，它该是一个还是只有一个，因此偏序集合自然地也是 Thin 范畴了。</p><p>而反对称性我们又怎么在 Thin 范畴上描述出来呢？我们知道当存在反对称性（即 <span class="math inline">\(a \leq b \leq a \implies a = b\)</span>），那么这个关系肯定是可互逆（Inverse）的，而现在我们对同构关系进行观察发现，实际上同构关系恰巧就是描述了这种关系，因此我们可以将其定义形式化地写成这样（亦即同构关系）： <span class="math display">\[ a \overset{f}{\underset{g}\leftrightarrows} b \implies f=g \]</span></p><h4 id="推广至同构与等价关系up-to-isomorphism-and-equivalence">推广至同构与等价关系（Up to Isomorphism and Equivalence）</h4><p>Thin 范畴与预序以及偏序集合的关系上面已经有了个大致的描述了，总括而言只要我们将 Thin 范畴推广至等价关系，亦即态射是并行且相等的，那么它们就是预序了。而偏序关系上面也已经提及到了，对于一个态射可以逆转回去，那么这就变成一个偏序关系了。</p><h2 id="群group">群（Group）</h2><h3 id="概念-1">概念</h3><p>群这个概念本身是在群论（Group Theory）中出现的，它以集合论为基础，即群本身存在一个集合，且由一个二元关系所组成的代数结构，其必须满足所谓的 “群公理”，即包含了封闭性、结合律、单位元以及逆元这四种性质。</p><p>实际上群与我们日常生活中有着很紧密的联系，就如同日常都可能用到的加法般，我们把两个正整数相加，透过正整数集合与 <span class="math inline">\(+\)</span> 我们可构成一个加法群，记为 <span class="math inline">\(G(\mathbb Z{+}, +)\)</span>，其满足了群公理： - 封闭性：<span class="math inline">\(\forall a, b \in G\)</span>，其运算结果也落入 <span class="math inline">\(G\)</span> 中 - 结合律：<span class="math inline">\(\forall a, b, c \in G, (a · b) · c = a · (b · c)\)</span> - 单位元：<span class="math inline">\(\forall a, \exists e \in G, e · a = a · e = a\)</span> - 逆元：<span class="math inline">\(\forall a, \exists b, e \in G, a · b = b · a = e\)</span></p><p>由于群论并不是我们主要的讨论对象，因此这部分并不会举出很多的例子，而在这仅会讨论幺半群的前置知识。</p><h3 id="半群semi-group">半群（Semi-group）</h3><p>有时候群公理在把关系进一步推广出去的时候，未必要加入额外的一些规则，反而我们可以通过放松一些条件来构成一个新的代数结构。比方说我们可以把一般群公理的单位元与逆元给拿掉，剩下封闭性，结合律这两条公理，随之被称为半群，这就是一个很好的例子。</p><h3 id="幺半群monoid">幺半群（Monoid）</h3><p>当然地，从抽象代数来讲半群也可以再次被推广成幺半群，所谓的 “么” 指的其实就是 “单位元（么元，Identity element）” 的意思，也就是只需要对半群给补上单位元的规则就可以了。</p><p>对于范畴 <span class="math inline">\(C\)</span> 内的对象 <span class="math inline">\(x\)</span>，我们都知道存在单位元态射 <span class="math inline">\(id_f\)</span>，但这种单位元态射难道就只能存在一个了吗？当然不是，我们甚至可以有多个单位元态射，例如 <span class="math inline">\(id_f, id_g, id_h, ... \in hom(x, x)\)</span>，将它们透过态射复合将会亦将得到： <span class="math display">\[x \circ id_f = x \\\\ x \circ id_f \circ id_g = x \\\\x \circ id_f \circ id_g \circ id_h = x \\\\x \circ id_f \circ id_g \circ id_h \circ ... = x\]</span></p><p>即其实单位元态射可存在无穷多个的，而对于这种一直都存在多个单位元态射且态射至自身的结构（封闭结构）我们就称之为幺半群。</p><p>而幺半群实际上对于计算机编程来说也是至关重要的概念，比方说我们日常能接触到的 <code>String</code>，即字符串，其实也是一个幺半群的结构，这时可以把编程语言的类型视为集合，例如： - 封闭性：<code>"foo" &lt;&gt; "bar" = "foobar"</code> 在运算后的结果都是 <code>String</code> 类型 - 结合律：<code>("foo" &lt;&gt; "bar") &lt;&gt; "foo" = "foo" &lt;&gt; ("bar" &lt;&gt; "foo") = "foobarfoo"</code> - 单位元：<code>"" &lt;&gt; "any" = "any" &lt;&gt; "" = "any"</code></p><h4 id="在-haskell-上的体现works-with-haskell">在 Haskell 上的体现（Works with Haskell）</h4><h5 id="定义">定义</h5><p>首先我们来看一下在 Haskell 上 <code>Data.Monoid</code> 下的的源码定义究竟是怎样的： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Semigroup a =&gt; Monoid a where</span><br><span class="line">    -- | Identity of &apos;mappend&apos;</span><br><span class="line">    -- | 以 &apos;mappend&apos; 作为二元关系时，以 &apos;mempty&apos; 作为单位元</span><br><span class="line">    mempty  :: a</span><br><span class="line"></span><br><span class="line">    -- | An associative operation</span><br><span class="line">    -- | 结合律公理</span><br><span class="line">    --</span><br><span class="line">    -- __NOTE__: This method is redundant and has the default</span><br><span class="line">    -- implementation @&apos;mappend&apos; = &apos;(&lt;&gt;)&apos;@ since /base-4.11.0.0/.</span><br><span class="line">    mappend :: a -&gt; a -&gt; a</span><br><span class="line">    mappend = (&lt;&gt;)</span><br><span class="line">    &#123;-# INLINE mappend #-&#125;</span><br><span class="line"></span><br><span class="line">    -- | Fold a list using the monoid.</span><br><span class="line">    -- | 使用幺半群折叠一个 List</span><br><span class="line">    --</span><br><span class="line">    -- For most types, the default definition for &apos;mconcat&apos; will be</span><br><span class="line">    -- used, but the function is included in the class definition so</span><br><span class="line">    -- that an optimized version can be provided for specific types.</span><br><span class="line">    mconcat :: [a] -&gt; a</span><br><span class="line">    mconcat = foldr mappend mempty</span><br></pre></td></tr></table></figure></p><h5 id="应用">应用</h5><p>除了上述提及到字符串就是一个幺半群之外，我们也可以利用幺半群的定律对其进行一些操作，例如说使用 <code>mappend</code> (或 <code>&lt;&gt;</code>）拼接两个字符串，又或者说可以使用 <code>mconcat</code> 把一个幺半群结构给折叠起来，例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; mconcat [[1],[2],[3],[4]]</span><br><span class="line">[1,2,3,4]</span><br></pre></td></tr></table></figure></p><h2 id="kleisli-范畴kleisli-category">Kleisli 范畴（Kleisli Category）</h2><p>待填坑...</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;为什么上两篇范畴论笔记大多数都是针对范畴与函数的关系，难道其他关系不能抽象成一个范畴吗？这个答案当然是否定的，前两篇是借助了函数的概念以更好地理解复合或同态究竟是些什么东西，因此而从本篇开始，我们来说一些与函数关系不大的一些知识吧！&lt;
      
    
    </summary>
    
    
      <category term="范畴论" scheme="https://a9032676.github.io/tags/%E8%8C%83%E7%95%B4%E8%AE%BA/"/>
    
      <category term="函数式编程" scheme="https://a9032676.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>星际蜗牛折腾记 第三章：部署 Docker</title>
    <link href="https://a9032676.github.io/2019/08/09/J1900-Tossing-3/"/>
    <id>https://a9032676.github.io/2019/08/09/J1900-Tossing-3/</id>
    <published>2019-08-09T08:33:25.000Z</published>
    <updated>2019-08-11T10:51:14.928Z</updated>
    
    <content type="html"><![CDATA[<p>在折腾完 RAID 之后，为了让作为 NAS 的 ArchLinux 发挥可用作应用服务器的作用，所以今天则要开始弄 Docker 了，废话不多说直接开始吧！</p><h2 id="简介">简介</h2><h2 id="安装-docker">安装 Docker</h2><p>安装 Docker 的途径有两种，第一种是透过 pacman 直接安装 docker 官方包，而另一种则是透过 <a href="https://wiki.archlinux.org/index.php/Arch_User_Repository" target="_blank" rel="noopener">Arch 用户软件仓库</a>（Arch User Repository，AUR）第三方用户仓库中生成并安装开发版本 <a href="https://aur.archlinux.org/packages/docker-git/" target="_blank" rel="noopener">docker-git</a>，下面使用 pacman 演示安装流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># pacman -S docker</span><br><span class="line"># systemctl start docker</span><br><span class="line"># systemctl enable docker</span><br><span class="line"># docker info</span><br></pre></td></tr></table></figure><ol type="1"><li>使用 <code>pacman -S docker</code> 下载并安装 docker</li><li>使用 <code>systemctl start docker</code> 与 <code>systemctl enable docker</code> 使 docker 服务启动与开机自启。</li><li>使用 <code>docker info</code> 查询 docker 当前运行状态，确保 docker 顺利安装并启动。</li></ol><h2 id="配置-docker">配置 Docker</h2><h3 id="为用户添加使用-docker-命令权限">为用户添加使用 docker 命令权限</h3><p>为了让非 root 用户能正常使用 docker 命令，我们需要把目标用户添加到 <code>docker</code> 组内（如果组别不存在，你可以使用 <code>groupadd docker</code> 创建）： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># usermod -a -G docker a9032676</span><br></pre></td></tr></table></figure></p><p>并且登出账号重新登陆，输入 <code>docker</code> 确认是否已拥有权限使用。</p><h3 id="配置-daemon.json-文件">配置 daemon.json 文件</h3><p>daemon.json 文件是 docker 守护进程的运行配置</p><h4 id="创建文件">创建文件</h4><p>首先使用 nano / vim 之类文本编辑器创建文件 <code>/etc/docker/daemon.json</code>。</p><h4 id="镜像加速服务">镜像加速服务</h4><p>首先鉴于地区网络质量差异问题，在远程使用 <code>docker pull</code> 拉取镜像的时候可能会较慢，因此我们可以选择性地配置 docker 的镜像服务器加速下载： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">&quot;https://registry.docker-cn.com&quot;,</span><br><span class="line">&quot;https://dockerhub.azk8s.cn&quot;,</span><br><span class="line">&quot;https://docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">&quot;https://hub-mirror.c.163.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重启 docker 使配置生效： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl restart docker</span><br></pre></td></tr></table></figure></p><h3 id="迁移本地镜像目录">迁移本地镜像目录</h3><p>在安装完成之后默认的镜像存放位置是位于 <code>/var/lib/docker</code> 目录下方的，而我们需要透过添加 <code>systemd</code> 的配置以更改 docker 的镜像储存位置：</p><p>首先使用 <code>mkdir</code> 新增 <code>docker.service.d</code> 目录： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /etc/systemd/system/docker.service.d/</span><br></pre></td></tr></table></figure></p><p>然后在目录下新建 <code>docker-storage.conf</code> 文件，并添加下列内容： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart= </span><br><span class="line">ExecStart=/usr/bin/dockerd --data-root=/path/to/new/location/docker -H fd://</span><br></pre></td></tr></table></figure></p><p>把 <code>--data-root</code> 选项更改成你目标的目录并保存即可，再将 <code>/var/lib/docker</code> 内的内容复制到你的目录上。</p><p>完成之后我们需要使用如下命令重启下 <code>docker.service</code> 服务： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></p><p>最后可使用 <code>systemctl status docker</code> 查询服务是否成功启动。</p><h2 id="相关应用推荐">相关应用推荐</h2><h3 id="portainer">Portainer</h3><h4 id="简介-1">简介</h4><p>由于 docker 日常都需要使用命令行管理各种容器 / 镜像与网络设置等等这些东西，有没有一个方法能够可视化地编辑及部署容器呢？那当然是有的，答案就是 <a href="https://www.portainer.io/" target="_blank" rel="noopener">Portainer</a> 啦！</p><h4 id="仓库地址">仓库地址</h4><p><a href="https://hub.docker.com/r/portainer/portainer" target="_blank" rel="noopener">portainer/portainer</a></p><h4 id="部署容器">部署容器</h4><p>这里仅演示 Linux 平台的安装与方式，我们需要创建一个卷，并命名为 <code>portainer</code> 即可。另外容器本身需要两个端口运作，因此需要把任意两个外部端口映射成 <code>8000</code> 与 <code>9000</code> 即可： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker volume create portainer_data</span><br><span class="line"># docker run -d -p 8000:8000 -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</span><br></pre></td></tr></table></figure></p><p>在正式跑起来之后进入网页后台 <code>http://[your_address]:9000</code> 创建新账号并登陆即可。</p><h3 id="samba">Samba</h3><h4 id="简介-2">简介</h4><p>Samba 提供了安全，可靠且快速的文件共享系统，且透过 SMB / CIFS 协议传输数据，并且完全兼容 DOS 与 Windows，OS/2，Linux 与其他更多的系统。</p><h4 id="仓库地址-1">仓库地址</h4><p><a href="https://hub.docker.com/r/dperson/samba" target="_blank" rel="noopener">dperson/samba</a></p><h4 id="部署容器-1">部署容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># docker run -it --name samba -p 139:139 -p 445:445 \</span><br><span class="line">  -v /path/to/directory:/mount \</span><br><span class="line">  -d dperson/samba</span><br></pre></td></tr></table></figure><h3 id="ariang">AriaNg</h3><h4 id="简介-3">简介</h4><p>很好用很方便的一个 Aria2 下载工具，自带网页可视化管理且完全兼容 Linux / 群晖 / FreeNAS 等系统。</p><h4 id="仓库地址-2">仓库地址</h4><p><a href="https://hub.docker.com/r/auska/docker-aria2" target="_blank" rel="noopener">auska/docker-aria2</a></p><h4 id="创建容器">创建容器</h4><p>由于需要填写的变量以及选项较多，推荐直接于 Portainer 内直接下载并新建容器，当然这里也只讲述下命令行启动的方法： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># docker create --name=aria2_web \</span><br><span class="line">  -v /home/a9032676/downloads:/mnt \</span><br><span class="line">  -v /home/a9032676/.aria2_conf:/config \</span><br><span class="line">  -e PGID=1000 -e PUID=1000 -e SECRET=PASSWORD \</span><br><span class="line">  -p 6800:6800 -p 80:80 \</span><br><span class="line">  auska/docker-aria2</span><br></pre></td></tr></table></figure></p><p>参数说明： - <code>--name=&lt;CONTAINER_NAME&gt;</code> 设置容器名字。 - <code>-v &lt;DOWN_PATH&gt;:/mnt</code> 把容器内的 <code>/mnt（默认下载存放位置）</code> 目录映射到卷上，或可选择在宿主机（Host）上指定的目录挂载。 - <code>-v &lt;CONF_PATH&gt;:/config</code> 同上，只不过这个是配置文件目录。 - <code>-e PGID=1000 -e PUID=1000 -e SECRET=&lt;PASSWORD&gt;</code> 这里指定三个环境变量（Environment）参数，第一二个参数请使用 <code>id USER</code> 命令获取，而第三个为你的 RPC 服务器密钥，请自行更改。 - <code>-p &lt;HOST_PORT&gt;:6800 -p &lt;HOST_PORT&gt;:80</code> 由于该容器需要两个端口，<code>6800</code> 为 RPC 服务监听端口，而 <code>80</code> 则为 Aria2 网页下载管理端口，请按照自己宿主机的端口进行映射。</p><h3 id="transmission">Transmission</h3><p>相信使用过 Transmission 下载 BT 文件的对它都不陌生，它的配置简洁，而且下载高效，且开源的性质，相信也吸引了很多人使用。而在 docker 上也有相关的第三方实现。</p><h4 id="仓库地址-3">仓库地址</h4><p><a href="https://hub.docker.com/r/linuxserver/transmission/" target="_blank" rel="noopener">linuxserver/transmission</a></p><h4 id="创建容器-1">创建容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># docker create \</span><br><span class="line">  --name=transmission \</span><br><span class="line">  -e PUID=1000 \</span><br><span class="line">  -e PGID=1000 \</span><br><span class="line">  -e TZ=Asia/HongKong \</span><br><span class="line">  -e TRANSMISSION_WEB_HOME=/combustion-release/ `#optional` \</span><br><span class="line">  -p 9091:9091 \</span><br><span class="line">  -p 51413:51413 \</span><br><span class="line">  -p 51413:51413/udp \</span><br><span class="line">  -v path to data:/config \</span><br><span class="line">  -v path to downloads:/downloads \</span><br><span class="line">  -v path to watch folder:/watch \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  linuxserver/transmission</span><br></pre></td></tr></table></figure><p>参数说明： - <code>-e PGID=1000 -e PUID=1000</code> 请使用 <code>id USER</code> 命令获取 PGID 与 PUID。 - <code>-e TZ=Asia/HongKong</code> 时区设置。 - <code>-e TRANSMISSION_WEB_HOME=/combustion-release/</code> 指定 WebUI 的目录位置（可选）。 - <code>-p 9091:9091</code> 为你的 Transmission 下载网页端口 - <code>-p 51413:51413 -p 51413:51413/udp</code> 为 Torrent 的 TCP 与 UDP 端口 - <code>-v path to data:/config</code> 为配置目录 - <code>-v path to downloads:/downloads</code> 为下载目录 - <code>-v path to watch folder:/watch</code> Torrent 文件的 watch 目录</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在折腾完 RAID 之后，为了让作为 NAS 的 ArchLinux 发挥可用作应用服务器的作用，所以今天则要开始弄 Docker 了，废话不多说直接开始吧！&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;h2 id=&quot;安装-docker&quot;&gt;安装 Docker&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="NAS" scheme="https://a9032676.github.io/tags/NAS/"/>
    
      <category term="ArchLinux" scheme="https://a9032676.github.io/tags/ArchLinux/"/>
    
      <category term="Docker" scheme="https://a9032676.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>星际蜗牛折腾记 第二章：组装 RAID</title>
    <link href="https://a9032676.github.io/2019/08/09/J1900-Tossing-2/"/>
    <id>https://a9032676.github.io/2019/08/09/J1900-Tossing-2/</id>
    <published>2019-08-09T01:39:53.000Z</published>
    <updated>2019-08-09T16:33:41.230Z</updated>
    
    <content type="html"><![CDATA[<p>经历昨天一天的奋战，在一边装的同时也把上一章文章写好了。今天的话继续为大家带来如何在纯命令行环境下继续折腾我们的星际蜗牛并为硬盘们组装上冗余磁盘阵列（Redundant Array of Independent Disks，又称 RAID）。</p><h2 id="简介">简介</h2><p>还是经由朋友的推介，我从某宝店家中以 400 块单个的价格搞来了两块 HGST（原日立，据说比较靠谱，就数字来讲的话 <ruby>故障<rp> (</rp><rt>fān chē</rt><rp>) </rp></ruby>率 相较其他品牌依旧最低） 的 4T 监控盘（非 SMR 叠瓦式，这灵车我还真不敢上），而年产日期有点久远，是 2014 年的，疑似翻新盘，因此买回来之后也跑完了对硬盘的各项检测，确保质量没问题并对这两块硬盘组上 软件RAID1（较为注重数据安全性，但储存容量只有一半），硬件 RAID 需要另行购置 RAID 卡。</p><h2 id="硬盘信息">硬盘信息</h2><ul><li>型号: HGST HMS5C4040BLE640</li><li>容量: 4TB（格式化后大约 3.6TB 左右）</li><li>类型：监控盘（连续写入较好，随即读取性能较差）</li></ul><p>详细数据请点<a href="https://documents.westerndigital.com/content/dam/doc-library/en_us/assets/public/western-digital/product/hgst/megascale-4000-series/data-sheet-megascale-dc-4000-b.pdf" target="_blank" rel="noopener">这里</a>查询。</p><h2 id="准备工作">准备工作</h2><h3 id="备份">备份</h3><p>如果硬盘之前存放有重要数据，切记切记要先备份，这个很关键。</p><h3 id="检测硬盘">检测硬盘</h3><p>在组装前请检测硬盘是否存在损坏，坏道，以及对其进行性能测试，确认没有问题之后再开始组装。</p><h2 id="组装-raid">组装 RAID</h2><h3 id="擦除硬盘数据">擦除硬盘数据</h3><p>若果在组装无论是新旧磁盘都必须先格式化，再进行组装。而如果本身硬盘已在之前组装了 RAID 的话，请使用以下步骤将硬盘内数据（包括 RAID 配置数据）擦除掉： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mdadm --misc --zero-superblock /dev/&lt;drive&gt;</span><br></pre></td></tr></table></figure></p><p>或者指定硬盘上的其中一个分区： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mdadm --misc --zero-superblock /dev/&lt;partition&gt;</span><br></pre></td></tr></table></figure></p><h3 id="为硬盘建立分区">为硬盘建立分区</h3><p>建立分区前，这里我使用了 <code>parted -l</code>（或 <code>fdisk -l</code>，选择 parted 无疑是因为较直观一点）命令查询当前硬盘情况： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@archlinux /]# parted -l</span><br><span class="line">Model: ATA C3M-16G (scsi)</span><br><span class="line">Disk /dev/sda: 16.0GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name  Flags</span><br><span class="line"> 1      1049kB  538MB   537MB   fat32              boot, esp</span><br><span class="line"> 2      538MB   16.0GB  15.5GB  ext4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Model: ATA HGST HMS5C4040BL (scsi)</span><br><span class="line">Disk /dev/sdb: 4001GB</span><br><span class="line">Sector size (logical/physical): 512B/4096B</span><br><span class="line">Partition Table: loop</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start  End  Size  File system  Name  Flags</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Model: ATA HGST HMS5C4040BL (scsi)</span><br><span class="line">Disk /dev/sdc: 4001GB</span><br><span class="line">Sector size (logical/physical): 512B/4096B</span><br><span class="line">Partition Table: loop</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start  End     Size    File system  Flags</span><br></pre></td></tr></table></figure></p><p>从上面看出，我们现在有两块 HGST 4TB 的 HDD 在这，分别是 <code>/dev/sdb</code> 以及 <code>/dev/sdc</code>，现在我们使用 <code>fdisk /dev/sdb</code> 以及 <code>fdisk /dev/sdc</code> 对它们建立 RAID 分区：</p><p>在建立分区之前首先要更改硬盘的 <code>disklabel</code> 为 GPT 格式，因此先输入 <code>g</code>： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@archlinux /]# fdisk /dev/sdb</span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.34).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line">The old ext4 signature will be removed by a write command.</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table.</span><br><span class="line">The size of this disk is 3.7 TiB (4000787030016 bytes). DOS partition table format cannot be used on drives for volumes larger than 2199023255040 bytes for 512-byte sectors. Use GUID partition table format (GPT).</span><br><span class="line"></span><br><span class="line">Created a new DOS disklabel with disk identifier 0xfe1551f9.</span><br><span class="line"></span><br><span class="line">Command (m for help): g</span><br><span class="line">Created a new GPT disklabel (GUID: 3171CF65-B466-9347-A082-3AACDD9B9721).</span><br></pre></td></tr></table></figure></p><p>在更改完成之后，现在使用 <code>n</code> 创建新的分区，然后输入 <code>t</code> 更改刚刚创建的新分区类型为 Linux RAID（序号为 <code>29</code>，GUID为 <code>A19D880F-05FC-4D3B-A006-743F0F84911E</code>），最后输入 <code>i</code> 查询创建结果，在确认无误后输入 <code>w</code> 保存并且退出： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): n</span><br><span class="line">Partition number (1-128, default 1): </span><br><span class="line">First sector (2048-7814037134, default 2048): </span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (2048-7814037134, default 7814037134): </span><br><span class="line"></span><br><span class="line">Created a new partition 1 of type &apos;Linux filesystem&apos; and of size 3.7 TiB.</span><br><span class="line"></span><br><span class="line">Command (m for help): t</span><br><span class="line">Selected partition 1</span><br><span class="line">Partition type (type L to list all types): 29</span><br><span class="line">Changed type of partition &apos;Linux filesystem&apos; to &apos;Linux RAID&apos;.</span><br><span class="line"></span><br><span class="line">Command (m for help): i</span><br><span class="line">Selected partition 1</span><br><span class="line">         Device: /dev/sdb1</span><br><span class="line">          Start: 2048</span><br><span class="line">            End: 7814037134</span><br><span class="line">        Sectors: 7814035087</span><br><span class="line">           Size: 3.7T</span><br><span class="line">           Type: Linux RAID</span><br><span class="line">      Type-UUID: A19D880F-05FC-4D3B-A006-743F0F84911E</span><br><span class="line">           UUID: 6885A106-3022-FA4F-966F-EDBA96B4A9D9</span><br><span class="line"></span><br><span class="line">Command (m for help): w</span><br><span class="line">The partition table has been altered.</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br><span class="line"></span><br><span class="line">[root@archlinux /]#</span><br></pre></td></tr></table></figure></p><p>然后重复上述步骤为 <code>/dev/sdc</code> 也创建一遍分区表，保存退出并输入 <code>parted -l</code> 查询最终分区表结果（已省略其他硬盘）： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Model: ATA HGST HMS5C4040BL (scsi)</span><br><span class="line">Disk /dev/sdb: 4001GB</span><br><span class="line">Sector size (logical/physical): 512B/4096B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name  Flags</span><br><span class="line"> 1      1049kB  4001GB  4001GB                     raid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Model: ATA HGST HMS5C4040BL (scsi)</span><br><span class="line">Disk /dev/sdc: 4001GB</span><br><span class="line">Sector size (logical/physical): 512B/4096B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name  Flags</span><br><span class="line"> 1      1049kB  4001GB  4001GB                     raid</span><br></pre></td></tr></table></figure></p><h3 id="建立硬盘阵列">建立硬盘阵列</h3><p>这里我们需要使用到一系列的 <code>mdadm</code> 命令（请使用 <code>pacman -S mdadm</code> 进行安装）创建硬盘阵列： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mdadm --create --verbose --level=1 --metadata=1.2 --raid-devices=2 /dev/md/RAID1 /dev/sdb1 /dev/sdc1</span><br></pre></td></tr></table></figure></p><p>用法：mdadm [选项] 设备 分区... 选项： - <code>--level</code> 是你要组合的 RAID 类型，这里我们是 RAID1 所以就直接填写 1 即可。 - <code>--metadata</code> 默认为 1.2，但若你的启动引导器（Bootloader）使用的是 Syslinux 且版本为 v4.07 的话请将这个变量改为 1.0。 - <code>--raid-devices</code> 指的是你要组成阵列的硬盘数量，我们这里只有两个那就填写 2。- <code>/dev/md/YOUR_RAID_NAME</code> 为命令 <code>mdadm</code> 的第一个必填参数，系统会根据这个路径去创建软链接并指向你创建的 RAID 阵列上（这里我使用 <code>ls -l /dev/md</code> 查询出来的结果是：<code>RAID1 -&gt; ../md127</code>）。 - <code>/dev/sdX1 /dev/sdX1 ...</code> 后续的参数则是你 RAID 的具体分区位置。</p><h3 id="查询-raid-状态">查询 RAID 状态</h3><p>在创建完毕之后，我们可以使用 <code>cat /proc/mdstat</code> 查询 RAID 当前的状态： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@archlinux /]# cat /proc/mdstat</span><br><span class="line">Personalities : [raid1] </span><br><span class="line">md127 : active raid1 sdc1[1] sdb1[0]</span><br><span class="line">      3906885440 blocks super 1.2 [2/2] [UU]</span><br><span class="line">      [&gt;....................]  resync =  0.1% (5158656/3906885440) finish=513.5min speed=126616K/sec</span><br><span class="line">      bitmap: 30/30 pages [120KB], 65536KB chunk</span><br></pre></td></tr></table></figure></p><p>可以发现我们刚组的 RAID 已经在开始在后台同步数据了，这时我们耐心等待同步完毕即可。</p><h3 id="格式化-raid-阵列">格式化 RAID 阵列</h3><p>在等待同步数据的同时，我们可以先对 RAID1 进行格式化（但要注意的是 RAID1 是完全由一个硬盘的所有内容镜像地复制到另外一个硬盘中，因此 RAID1 并没有采用到硬盘条带化（Stripe）技术，所以我们在格式化的时候并不需要手动计算 <code>stripe size</code> <code>stripe width</code> 这些东西，而类似 RAID5 / RAID6 这些则需要特别小心）： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@archlinux md]# mkfs.ext4 /dev/md127</span><br><span class="line">mke2fs 1.45.3 (14-Jul-2019)</span><br><span class="line">Creating filesystem with 976721360 4k blocks and 244187136 inodes</span><br><span class="line">Filesystem UUID: cce6ae47-1d89-4293-a259-318c3b765a0b</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, </span><br><span class="line">4096000, 7962624, 11239424, 20480000, 23887872, 71663616, 78675968, </span><br><span class="line">102400000, 214990848, 512000000, 550731776, 644972544</span><br><span class="line"></span><br><span class="line">Allocating group tables: done                            </span><br><span class="line">Writing inode tables: done                            </span><br><span class="line">Creating journal (262144 blocks): </span><br><span class="line">done</span><br><span class="line">Writing superblocks and filesystem accounting information:            </span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h3 id="挂载-raid-阵列">挂载 RAID 阵列</h3><p>在上述步骤都完成了之后，那现在当然就是挂载 RAID 阵列啦，我们现在使用 <code>mkdir /raid1</code> 创建了一个 <code>raid1</code> 文件夹，并把 <code>/dev/md127</code> 挂载到其上： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@archlinux md]# mkdir /raid1</span><br><span class="line">[root@archlinux md]# mount /dev/md127 /raid1</span><br></pre></td></tr></table></figure></p><p>使用 <code>df -h | grep '/dev/md127'</code> 验证我们是否挂载成功： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@archlinux raid1]# df -h | grep &apos;dev/md127&apos;</span><br><span class="line">/dev/md127      3.6T   89M  3.4T   1% /raid1</span><br></pre></td></tr></table></figure></p><h4 id="设置开机挂载">设置开机挂载</h4><p>在使用 <code>mount</code> 挂载完后并不意味着 RAID 阵列开机就会启动 RAID 以及自动挂载，因此我们可以使用 mdadm 的指令把现行扫描出来的 RAID 阵列自动加到 <code>/etc/mdadm.conf</code> 上，好让系统在开机时自启 RAID 设备： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdadm -D --scan &gt;&gt; /etc/mdadm.conf</span><br></pre></td></tr></table></figure></p><p>或手动编辑 <code>/etc/mdadm.conf</code> 并设定： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DEVICE partitions</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">ARRAY /dev/md/RAID1 metadata=1.2 name=archlinux:RAID1 UUID=72326a38:db8867f1:6d3c072e:2c1a5d06</span><br></pre></td></tr></table></figure></p><p>把你的 RAID 阵列配置加到末尾即可（UUID 可使用 <code>mdadm --detail /dev/mdX</code> 查询）。</p><p>然后编辑 <code>/etc/fstab</code> 并把配置添加到末尾，好让系统开机自动挂载： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"># /dev/md127</span><br><span class="line">/dev/md127 /raid1 ext4 defaults 0 0</span><br></pre></td></tr></table></figure></p><h4 id="重启并验证">重启并验证</h4><p>最后一步就是输入 <code>reboot</code> 重启并使用 <code>df -h | grep raid1</code> 重新验证自动挂载是否成功。</p><h2 id="总结">总结</h2><p>这篇折腾的东西与上一篇其实也差不多，目前的话就差一些作为应有的基础配套与应用集群管理体系了，不然单纯作为存储用也就太浪费了，所以下一篇会集中讲述关于在 ArchLinux 部署 Docker 的安装流程与一些事宜。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经历昨天一天的奋战，在一边装的同时也把上一章文章写好了。今天的话继续为大家带来如何在纯命令行环境下继续折腾我们的星际蜗牛并为硬盘们组装上冗余磁盘阵列（Redundant Array of Independent Disks，又称 RAID）。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;
      
    
    </summary>
    
    
      <category term="NAS" scheme="https://a9032676.github.io/tags/NAS/"/>
    
      <category term="ArchLinux" scheme="https://a9032676.github.io/tags/ArchLinux/"/>
    
      <category term="硬盘分区" scheme="https://a9032676.github.io/tags/%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA/"/>
    
      <category term="RAID" scheme="https://a9032676.github.io/tags/RAID/"/>
    
  </entry>
  
  <entry>
    <title>星际蜗牛折腾记 第一章：安装 ArchLinux</title>
    <link href="https://a9032676.github.io/2019/08/07/J1900-Tossing-1/"/>
    <id>https://a9032676.github.io/2019/08/07/J1900-Tossing-1/</id>
    <published>2019-08-07T08:43:25.000Z</published>
    <updated>2019-08-09T16:32:16.842Z</updated>
    
    <content type="html"><![CDATA[<p>最近本来有打算直接入手一台 Synology 主机的，但经过一个朋友的推介，最终我选择了星际蜗牛搭载 ArchLinux 作为 NAS 使用。</p><h2 id="简介">简介</h2><p>由于收到时店家已经为我预装好 Synology (黑群辉）了，本来不太打算怎么折腾直接使用的，但想了想为了日后更好的可自定义化最终还是使用了数天之后展开了重装的旅程（ArchLinux 真香。</p><h2 id="配置">配置</h2><ul><li>CPU: Intel(R) Celeron(R) CPU J1900 @ 1.99GHZ</li><li>内存: 8G DDR3</li><li>SSD: 16G</li><li>盘位数: 4个</li><li>网口: 2个 (双千兆)</li></ul><p>配置看上去其实差不多也就这样，但查了下发现供电可能是雷区，毕竟如果4个盘满载运行的话稳定性可能成为疑问，但暂且来说目前还只有两个盘那就不管了。</p><h2 id="准备工作">准备工作</h2><h3 id="备份">备份</h3><p>这个就不用多说了，在安装之前有重要数据切记要备份。</p><h3 id="参阅官方安装教程">参阅官方安装教程</h3><p>在安装的同时建议打开 <a href="https://wiki.archlinux.org/index.php/Installation_guide" target="_blank" rel="noopener">官方安装教程</a> 边参考边安装，以免出错。</p><h3 id="制作-livecd-引导盘">制作 LiveCD 引导盘</h3><p>首先前往 ArchLinux 国内镜像站（我这里选用了<a href="https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/" target="_blank" rel="noopener">清华源</a>），然后寻找合适版本的 ArchLinux 镜像文件并使用工具刻录到 USB 上（由于我的电脑系统使用了 Ubuntu 18.04 + gnome 桌面环境，因此我使用了可视化的 Disks 工具进行 LiveCD 制作），该步骤由于网上已有不同环境下制造的教程，因此略过。</p><h2 id="预处理步骤">预处理步骤</h2><h3 id="插入已制作好的-livecd">插入已制作好的 LiveCD</h3><p>现在我们把 LiveCD 插入到星际蜗牛主机上，并且在开机后进入 BIOS 界面，把启动项调整成我们刚插入到主机上的 USB （UEFI 方式），并在 F10 保存之后重新启动。</p><h3 id="擦除-synology-系统数据">擦除 Synology 系统数据</h3><p>在完成上述步骤之后，成功地进入了 ArchLinux 的命令行环境，但由于店家本身已经预装了黑群辉，因此我们需要把残留的数据都给清空掉。</p><ol type="1"><li><p>输入 <code>fdisk -l</code> 查看黑群辉系统所在分区（我这里查出来是 <code>/dev/sda</code>）。</p></li><li><p>使用 <code>dd if=/dev/zero of=/dev/sda</code> 写 0 擦除 <code>/dev/sda</code> 硬盘上的内容，并且在擦除完毕后直接使用 <code>Ctrl+C</code> 退出。</p></li></ol><h3 id="创建分区表">创建分区表</h3><p>现在使用 <code>fdisk</code> 与 <code>parted</code> （官方推荐这两个）等工具对 <code>/dev/sda</code> 建立新的分区表（我这里使用的是 <code>cfdisk /dev/sda</code>）：</p><ol type="1"><li>首先要创建 EFI System Partition (ESP) 并作为引导文件储存用，这里我分出了 512M 给予 <code>/dev/sda1</code> 分区（官方建议 UEFI with GPT 是 260 ～ 512MB）。</li><li>然后的就是把剩余的空间全数分配给 <code>/dev/sda2</code>（这里你也可以预留一些大于 512MB 的空间分配给 <code>/dev/sda3</code> 作为 swap 区使用），并指定分区表类型为 Linux filesystem 即可。</li><li>保存并退出。</li></ol><p>最终分区表如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Device      Start      End  Sectors  Size Type</span><br><span class="line">/dev/sda1    2048  1050623  1048576  512M EFI System</span><br><span class="line">/dev/sda2 1050624 31277198 30226575 14.4G Linux filesystem</span><br></pre></td></tr></table></figure></p><h3 id="格式化分区空间">格式化分区空间</h3><p>完成上述步骤之后，现在我们可以对上面两个分区进行格式化： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkfs.fat -F32 /dev/sda1</span><br><span class="line"># mkfs.ext4 /dev/sda2</span><br></pre></td></tr></table></figure></p><h3 id="创建-swap-分区可选">创建 Swap 分区（可选）</h3><p>如果在创建分区表的步骤上已经为系统创建了 Swap 分区，那么现在可以使用如下指令创建 Swap 区： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mkswap /dev/sda2</span><br><span class="line"># swapon /dev/sda2</span><br></pre></td></tr></table></figure></p><h3 id="挂载分区">挂载分区</h3><p>刚才我们已经对 <code>/dev/sda</code> 建立起了 <code>/dev/sda1</code> 与 <code>/dev/sda2</code> 这两个分区，现在我们开始把它们挂载到对应的位置上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># mount /dev/sda2 /mnt</span><br><span class="line"># cd /mnt</span><br><span class="line"># mkdir boot</span><br><span class="line"># mount /dev/sda1 /boot</span><br></pre></td></tr></table></figure><h2 id="安装系统">安装系统</h2><p>在确认挂载无误之后，我们现在就可以开始安装 ArchLinux 了！让我们看看接下来要干什么吧！</p><h3 id="配置-pacman-镜像源可略过live-模式默认启动所有镜像">配置 Pacman 镜像源（可略过，Live 模式默认启动所有镜像）</h3><p>由于 ArchLinux 采用了 Pacman 作为包管理系统并需要联网以安装一些基础包，而为了提升下载速度，所以在这个激动人心的安装过程之前先配置好我们的镜像列表：</p><ol type="1"><li><p>可以先前往 <a href="https://www.archlinux.org/mirrorlist/" target="_blank" rel="noopener">官方的镜像列表生成器</a> 生成你所在国家或地区的镜像服务器列表。</p></li><li><p>然后将它们复制粘贴到 <code>/etc/pacman.d/mirrorlist</code> 并保存即可。</p></li></ol><h3 id="安装-base-程序包组">安装 base 程序包组</h3><p>在确保联网状态可用的情况下，使用 <code>pacstrap</code> 指令去安装及下载，并且稍稍等待一段时间： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ip link</span><br><span class="line"># ping archlinux.org</span><br><span class="line"># pacstrap /mnt base</span><br></pre></td></tr></table></figure></p><p>不过要注意的是 <code>base</code> 包组在 Live 模式下安装并不包含所有工具，当然你也可以使用 <code>pacstrap /mnt base-devel</code> 安装基础开发者工具包组。</p><h3 id="配置-fstab">配置 fstab</h3><p>对于一些日后可能需要用到的硬盘或者分区，或者哪些分区需要开机的时候自动挂载，我们可能需要在 <code>/etc/fstab</code> 文件中指定出来。现在使用 <code>genfstab</code> 指令简单的生成一个配置文件并用 cat 查询以确认生成结果。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br><span class="line"># cat /mnt/etc/fstab</span><br></pre></td></tr></table></figure></p><h3 id="移动至系统根目录">移动至系统根目录</h3><p>我们当前进程还是以 LiveCD 下的引导系统作为根目录，因此我们需要把根目录移动到我们新创建好的系统中（<code>/mnt</code> 里）再进行操作： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># arch-chroot /mnt</span><br></pre></td></tr></table></figure></p><h3 id="调整系统内的个性化配置可选">调整系统内的个性化配置（可选）</h3><p>这里的配置较为次要，因此不作更详细的说明，详情可前往官方文档参阅：</p><h4 id="时区设置">时区设置</h4><p>创建软链接把 <code>/etc/localtime</code> 指向 <code>/usr/share/zoneinfo/Region/City /etc/localtime</code> 让系统读取： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ln -sf /usr/share/zoneinfo/Asia/Hong_Kong /etc/localtime</span><br><span class="line"># hwclock --systohc</span><br></pre></td></tr></table></figure></p><h4 id="本地化设置">本地化设置</h4><p>创建本地化配置 <code>/etc/locale.conf</code> 并让系统读取，可使用 nano / vi 等方式进行编辑： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure></p><h3 id="配置网络">配置网络</h3><h4 id="配置-hosts-文件">配置 hosts 文件</h4><p>现在我们编辑 <code>/etc/hosts</code> 文件，使 hosts 文件生效，下面是我的配置： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1localhost</span><br><span class="line">::1localhost</span><br><span class="line">127.0.1.190-ArchLinux</span><br></pre></td></tr></table></figure></p><h4 id="添加网卡配置">添加网卡配置</h4><p>我们可以使用在 base 包自带的 <code>netctl</code> 进行有线网络配置：</p><ol type="1"><li>在命令行环境下先输入 <code>ip link</code> 查询未启动或未被分配有 IP 的网卡，我这里查询出来的是 enp1s0 与 enp4s0，因为接了网线的网口是下面的所以盲猜应该是 enp4s0。</li><li>使用 <code>nano /etc/netctl/enp4s0</code> 创建并编辑网卡配置（请把下述所有内容的 enp4s0 替换成你网卡配置的名字）：</li></ol><p>DHCP 动态分配 IP 请使用： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Interface=enp4s0</span><br><span class="line">Connection=ethernet</span><br><span class="line">IP=dhcp</span><br></pre></td></tr></table></figure></p><p>静态分配 IP 请使用： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Interface=enp4s0</span><br><span class="line">Connection=ethernet</span><br><span class="line">IP=static</span><br><span class="line">Address=(&apos;10.1.10.2/24&apos;)</span><br><span class="line">Gateway=&apos;10.1.10.1&apos;</span><br><span class="line">DNS=(&apos;10.1.10.1&apos;)</span><br></pre></td></tr></table></figure></p><ol start="3" type="1"><li>保存并退出，并输入： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netctl start enp4s0</span><br><span class="line">netctl enable enp4s0</span><br><span class="line">netctl status enp4s0</span><br></pre></td></tr></table></figure></li></ol><p><code>netctl start enp4s0</code> 为启动网卡，然后输入 <code>netctl enable enp4s0</code> 确保网卡在开机时启动，最后输入 <code>netctl status enp4s0</code> 查询网卡状态，确保启动成功。</p><h3 id="设置-root-密码">设置 Root 密码</h3><p>设置 Root 密码： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># passwd</span><br></pre></td></tr></table></figure></p><h3 id="设置启动引导">设置启动引导</h3><p>在完成上述所有的步骤之后，现在来到最关键的一步了。在我们把系统配置完成之后，系统本身并不会自行引导并启动系统的，因此我们需要安装启动引导器（Bootloader），而官方给出了一整个 <a href="https://wiki.archlinux.org/index.php/Arch_boot_process#Boot_loader" target="_blank" rel="noopener">启动引导器列表</a> 供我们选择。</p><p>在这里我选用了 Grub 作为我的引导器，因此下面会列出 Grub 的安装流程： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># pacman -S grub efibootmgr os-prober</span><br><span class="line"># grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB</span><br><span class="line"># grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure></p><ol type="1"><li>使用 pacman 下载并安装 grub，efibootmgr 与 os-prober 包</li><li>执行 grub-install 指令安装，我这里使用的是 UEFI 架构，因此设置 <code>--target</code> 为 <code>x86_64-efi</code>，而 efi 路径则设置为上面创建好的 <code>/boot</code> 路径（也为ESP）即可。</li><li>执行 grub-mkconfig 以生成 grub 的默认配置文件</li></ol><h3 id="重启主机进入安装系统">重启主机进入安装系统</h3><p>在完成上述所有流程之后，我们现在可以输入 <code>exit</code> 或按下 <code>Ctrl+D</code> 退出 Chroot 环境，并执行 reboot（不要忘记移除我们搭载 Live 系统的 USB），进入新系统并使用设置好的 root 密码登陆，至此安装完毕！</p><h2 id="总结">总结</h2><p>本篇较详细地讲述了安装 ArchLinux 系统的整个流程，当然相比起其他开箱即食的一键化傻瓜式系统安装要沉长许多，但也有助于进一步了解 Linux 的文件结构，也鼓励喜欢折腾的朋友可以尝试自己去弄一下。而作为 NAS 使用没有组 RAID 阵列怎么行，因此下一篇会为大家带来软件 RAID 阵列的组装。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近本来有打算直接入手一台 Synology 主机的，但经过一个朋友的推介，最终我选择了星际蜗牛搭载 ArchLinux 作为 NAS 使用。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;由于收到时店家已经为我预装好 Synology (黑群辉）了，本来不太打算怎
      
    
    </summary>
    
    
      <category term="NAS" scheme="https://a9032676.github.io/tags/NAS/"/>
    
      <category term="ArchLinux" scheme="https://a9032676.github.io/tags/ArchLinux/"/>
    
      <category term="硬盘分区" scheme="https://a9032676.github.io/tags/%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA/"/>
    
      <category term="系统安装" scheme="https://a9032676.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>一个 Haskeller 的范畴论入坑笔记 第二章：函数与范畴关系</title>
    <link href="https://a9032676.github.io/2019/07/20/Category-Theory-2/"/>
    <id>https://a9032676.github.io/2019/07/20/Category-Theory-2/</id>
    <published>2019-07-20T11:09:41.000Z</published>
    <updated>2020-10-28T01:25:42.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>要说到函数与类型，只要是个写带有类型系统的编程语言，都应该很熟悉，因为我们天天都会接触到。但是对于在范畴论上，或更广义地我们指在数学上的函数，以及类型的概念（因为数学上类型相等于只是集合，下面会提及），他们又或许又有不一样的面貌展现在我们的面前。</p><h2 id="函数function">函数（Function）</h2><p>函数只是一个过程（或者说是一个黑箱），因为它只负责接受某些参数，然后处理，最后返回一些返回值。这或许是大部分写命令式编程语言的人心中对于函数所理解的了，即使是对于使用函数式编程开发的人，函数的概念多多少少与数学上也是有出入的。正因为在不同领域对函数的定义与概念都不一样，因此先让我们定义函数这个概念究竟是什么。</p><h3 id="概念">概念</h3><p>首先我们来回顾一下我在范畴论上一章对于态射（Morphism）与复合（Compose）的概念，且我们得知态射其实是可以被直接作为函数来看待的，在这里要再补充的是：对象（Object）在态射这个过程中不仅仅只是存在一个对象，而是可以有一个或多个对象在同时态射，就例如我们在数学上不仅可以定义两个整数为对象，然后把它们相加在一起（像 <span class="math inline">\(5 + 8\)</span> 这样），而加法本身也是个函数，而且这条函数本身并不仅能接受 <span class="math inline">\(5\)</span> 作为一个参数，然后返回 <span class="math inline">\(8\)</span>，而是根据具体这条函数的定义域（Domain）来决定所接受的参数都有什么（例如在这我们设为 <span class="math inline">\(\forall x.x \in \mathbb Z\)</span>），再把集合内的所有整数加上另外一个整数（例如 <code>map (+3) [1,2,3]</code> 或 <span class="math inline">\(x + 3\)</span>），最后输出到新的集合 <span class="math inline">\(Y\)</span> 上，正如下图这样： <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/mapping-1.png" alt title>                </div>                <div class="image-caption"></div>            </figure> 集合 <span class="math inline">\(X\)</span> 是作为定义域（Domain）出现的，然后我们把 <span class="math inline">\(X\)</span> 当中的元素给态射到集合 <span class="math inline">\(Y\)</span>，即像 / 值域（Image / Range）上，因此使用映射关系也可以公理化成这样：<span class="math inline">\(X \xrightarrow[f]{} Y\)</span>。</p><h3 id="函数关系relationship-of-function">函数关系（Relationship of function）</h3><p>既然在概念上我们提到，函数之间的关系可以以集合映射的形式表示出来，因为这样可以更清晰地描述其中的关系。下面我们不妨来粗略地了解下函数的映射关系吧（详尽的定义可以参考维基）。</p><h4 id="陪域与值域或像codomain-and-rangeor-image">陪域与值域（或像）（Codomain and Range（or Image））</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/mapping-2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>要谈及到陪域的概念，首先我们需要了解一下值域（或像）的概念，值域就相等于函数实际输出的集合，例如我们说有一条函数 <span class="math inline">\(f : \mathbb Z \mapsto \mathbb Z\)</span>，定义为 <span class="math inline">\(f(x) = x + 2\)</span>，而定义域的则取于 <span class="math inline">\([0,2]\)</span> 区间之间，因此对于给定的输入 <span class="math inline">\(0, 1, 2\)</span>，可得到实际输出 <span class="math inline">\(2, 3, 4\)</span>，实际上这些也就是值域内的对象。</p><p>那么培域（Codomain）呢？它其实就相当于一个于一个函数的可能输出范围，那什么叫 "可能输出的范围" 呢？由于我们上面给定的定义域只有 <span class="math inline">\(0, 1, 2\)</span> 这三个数，但我们千万不能忽视除了这几个数以外，对于这条函数来讲其实是可以接受其他整数 <span class="math inline">\(x \in \mathbb Z\)</span> 作为输入的，所以其实我们可能还有 <span class="math inline">\({...,-3,-2,-1,0,1,2,3,...}\)</span> 等等的作为输入的集合，然后对应的可能输出也就是培域（也是值域的超集，<span class="math inline">\(Codomain \supseteq Range\)</span>）了。</p><h4 id="单射函数injective-function">单射函数（Injective function）</h4><p>相较于满射函数，单射函数也就是单独，单一的意思，也即是对于定义域所有的对象，并不会映射到值域上的所有对象，只有部分被一一对应地映射。换句话说就是值域与培域在这种情况下是不相等的，此时值域必然会小于培域（如果相等的话就变成满射函数了）。</p><p>具体定义为： 若满足 <span class="math inline">\(\forall x, y \in X, f(x) = f(y) \implies x = y\)</span>，则 <span class="math inline">\(f : X \to Y\)</span> 为一单射函数。</p><h4 id="满射函数surjective-function">满射函数（Surjective function）</h4><p>满射的含义为完满，完全，所有的意思，也就是指对于值域上的所有对象，都必定至少存在一个映射由定义域映射过去，因此我们 "不会错过" 任何一个输出，即便出现多对一映射的情况。所以说对于所有输出不仅仅是可能的，而且是必然的，最终的结果就是值域会直接等同于培域。</p><p>具体定义为： 若满足 <span class="math inline">\(\forall y \in Y, \exists x \in X, f(x) = y\)</span>，则 <span class="math inline">\(f : X \to Y\)</span> 为一满射函数。</p><h4 id="双射函数bijective-function">双射函数（Bijective function）</h4><p>透过观察在概念中 <span class="math inline">\(X \xrightarrow[f]{} Y\)</span> 的例子我们得知，左边的集合（定义域）与右边集合（像 / 值域）的对象是全部对应起来的，因为我们上面的定义域为 <span class="math inline">\(\forall x.x \in \mathbb Z\)</span>（也就是对于所有 <span class="math inline">\(x\)</span>，它们都属于整数这个集合），且是一一对应的，也就是 <span class="math inline">\(1 \to 2\)</span>，<span class="math inline">\(2 \to 3\)</span>，<span class="math inline">\(3 \to 6\)</span> 这样，它们并不会形成类似多对一，一对多的关系。因此我们可以把这种关系称之为双射（满射且单射）。</p><h4 id="反函数与原像inverse-function-and-preimages">反函数与原像（Inverse function and Preimages）</h4><h5 id="函数可逆性function-invertibility">函数可逆性（Function invertibility）</h5><h4 id="并不属于函数范畴的态射关系">并不属于函数范畴的态射关系</h4><p>上面已经列出部分函数的基础关系，下面我们来看一些 "很像函数但又并不是函数" 的函数。</p><h5 id="多值函数multivalued-function">多值函数（Multivalued function）</h5><p>由于数学上函数的定义每一个输入都只能够对应一个输出，而多值函数也就是一对多的字面意思，所以多值函数并不是一条函数。在数学上最显然的例子就是求根公式得出来的结果有可能是正或者负，如果得出来的结果例如只有一个正整数或者负整数那就是很正常的一条函数，但若果得出来的结果可能是出现多个的，例如 {<span class="math inline">\(-2, 2\)</span>}，那这个就是属于多值函数了。而之所以为什么我们看到当今计算机语言的函数并不能直接拥有多返回值（顶多也只能够返回一个 <code>Array</code> <code>List</code> <code>Tuple</code> <code>Pair</code> <code>Set</code> 之类的容器），究其原因其实也在这里。</p><h5 id="偏函数partial-function">偏函数（Partial function）</h5><p>偏函数指的是在定义域内，有一个或多个对象并未映射到值域内，而这种情况就好比我们日常开发的时候，写一条函数，接受两个参数，但第一个参数从始至终都未在函数体内被间接或直接地引用过，也就是 <code>Unused parameter</code>，这种看似是能写的出来的函数实际上也并不是一条函数。</p><h2 id="范畴关系category-relationship">范畴关系（Category Relationship）</h2><p>请不要忘记我们的目标是什么，在上面介绍完函数的基本关系之后并不是代表就结束了，那仅仅只是函数上关系而已，而我们还有对于范畴论内的态射关系没谈呢！所以现在让我们来开始一起看看吧。</p><h3 id="同态homomorphism">同态（Homomorphism）</h3><p>同态含义为 "相同的形态"，也就是指在映射时保持两个代数结构上它们相同形态不变。对于函数上有不同种类的函数类型（例如上面单射 / 满射 / 双射函数等等），在范畴论上的态射种类也就被称为同态了。</p><h3 id="单同态monomorphismmonic">单同态（Monomorphism（Monic））</h3><p>单同态在范畴论上的概念几乎等同于集合论（或集合范畴 <span class="math inline">\(C_{Set}\)</span>）的单射函数，对于范畴 <span class="math inline">\(C\)</span> 内，我们有 <span class="math inline">\(g_x : C \to A\)</span> 以及 <span class="math inline">\(f : A \to B\)</span>，对于态射 <span class="math inline">\(g_1, g_2\)</span>，若它们均与 <span class="math inline">\(f\)</span> 结合，即 <span class="math inline">\(f \circ g_1\)</span> 与 <span class="math inline">\(f \circ g_2\)</span> 隐含了 <span class="math inline">\(g_1 = g_2\)</span>（这里我们可以左消除（Left cancellable）<span class="math inline">\(f\)</span>，像这样：<span class="math inline">\(\require{cancel} \cancel{f \circ} g_1 = \cancel{f \circ} g_2\)</span>），满足这个条件时我们称 <span class="math inline">\(A \rightarrowtail B\)</span> 是单同态的。</p><h3 id="满同态epimorphismepic">满同态（Epimorphism（Epic））</h3><p>满同态在范畴论上的概念几乎等同于集合论（或集合范畴 <span class="math inline">\(C_{Set}\)</span>）的满射函数，在这里我们不妨也给出 <span class="math inline">\(f : A \to B\)</span> 以及 <span class="math inline">\(g_x : B \to C\)</span>，对于态射 <span class="math inline">\(g_1\)</span>, <span class="math inline">\(g_2\)</span>，若它们均与 <span class="math inline">\(f\)</span> 结合，即 <span class="math inline">\(g_1 \circ f\)</span> 与 <span class="math inline">\(g_2 \circ f\)</span> 隐含了 <span class="math inline">\(g_1 = g_2\)</span> （因为我们可以右消除（Right cancellable） <span class="math inline">\(f\)</span>，像这样：<span class="math inline">\(g_1 \require{cancel} \cancel{\circ f} = g_2 \cancel{\circ f}\)</span>），所以 <span class="math inline">\(A \twoheadrightarrow B\)</span> 是满同态的。</p><h3 id="同构isomorphism">同构（Isomorphism）</h3><p>同构的皆指在范畴在态射之间保持了不变的结构，换句话说就是一样的结构，假设我们有态射 <span class="math inline">\(f : A \to B\)</span>，若这个态射是同构关系，那么它肯定保留了可逆以及对称性，所以有 <span class="math inline">\(g : B \to A\)</span>。而因每个对象本身都存在单位元，例如每次当 <span class="math inline">\(g \circ f\)</span> 绕回来的时候其实也就等同于 <span class="math inline">\(id_A\)</span>，因此保有如下性质：<span class="math inline">\(g \circ f = id_A\)</span> 以及 <span class="math inline">\(f \circ g = id_B\)</span>。</p><p>而在 Haskell 中我们能很简单的定义一个类型表示同构关系： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type ISO a b = (a -&gt; b, b -&gt; a)</span><br></pre></td></tr></table></figure></p><h2 id="总结">总结</h2><p>本篇略略介绍了一些简单的基础函数与同态的关系，所以当然关系是不止这么一点的，后续会慢慢提及到。而了解清楚这些关系之后在写代码时也有助于看清楚函数背后的细节与作用，使逻辑条理更为清晰。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;要说到函数与类型，只要是个写带有类型系统的编程语言，都应该很熟悉，因为我们天天都会接触到。但是对于在范畴论上，或更广义地我们指在数学上的函数，以及类型的概念（因为数学上类型相等于只是集合，下面会提及），他们又或许又有不一样的面貌展现在
      
    
    </summary>
    
    
      <category term="范畴论" scheme="https://a9032676.github.io/tags/%E8%8C%83%E7%95%B4%E8%AE%BA/"/>
    
      <category term="函数式编程" scheme="https://a9032676.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一个 Haskeller 的范畴论入坑笔记 第一章: 复合的本质</title>
    <link href="https://a9032676.github.io/2019/07/19/Category-Theory-1/"/>
    <id>https://a9032676.github.io/2019/07/19/Category-Theory-1/</id>
    <published>2019-07-19T11:13:32.000Z</published>
    <updated>2019-09-13T19:12:01.831Z</updated>
    
    <content type="html"><![CDATA[<p>在入坑接触 Haskell 一段时间后，碰到很多类似 <code>Functor</code> <code>Applicative</code> <code>Monad</code> 等等这些诸如此类的 "魔法"，虽然有时候用是会用了，利用各种自定义的 Monad instance 也实际优化了 FP （Functional Programming） 工程上的代码，但是回头一看 Monad（单子）这个神奇的词，仔细想想又并不这么简单能够解释，一查发现其中又牵涉出 <code>Monoid（么半群）</code> <code>Semigroup（半群）</code> 等等这些群论以至于范畴论上的概念出来。于是乎为了能够 <ruby>彻底弄清楚这一大堆东西<rp> (</rp><rt>mǎn zú hào qí xīn</rt><rp>) </rp></ruby>（顺便记录下学习的过程），特意开了本篇作为学习笔记，也希望能够记录这个入坑 <ruby>猫论<rp> (</rp><rt>Category Theory</rt><rp>) </rp></ruby> 到入土的心路历程（笑。</p><h2 id="概念concept">概念（Concept）</h2><blockquote><p>研究范畴就是试图以“公理化”的方法抓住在各种相关连的“数学结构”中的共同特性，并以结构间的“结构保持函数”将这些结构相关起来。因此，对范畴论系统化的研究将允许任何一个此类数学结构的普遍结论由范畴的公理中证出。</p></blockquote><p>范畴论这门学问，虽然分类上是属于数学的基础内容，但个人（以作为 Haskeller 的角度）反倒觉得像是一门 "数学上的抽象语言"。就如同上面引文提及：它负责对数学结构中的共同特性，加以公理化的形式把这一个个的数学结构连接起来。举个例子：就如同数学上最简单的加减乘除这些 "二元运算"，均能被视为是一种连接两个数学结构之间的一个公理化的连接，因此才被称为 "二元运算"。</p><h2 id="对象与态射object-and-morphism">对象与态射（Object and Morphism）</h2><p>通俗地讲，一个最简单的范畴结构可以由一个 <code>对象（Object）</code> 与 <code>态射（Morphism）</code> 复合而成的，一个对象可以是任何东西（例如一个自然数或是个英文字母等等），而态射就相等于对象变换的过程，然后把一个个对象之间像是加上了一个个箭头（Arrow）一样将它们逐一连接起来，首先由对象 <span class="math inline">\(a\)</span> 态射到对象 <span class="math inline">\(b\)</span> ，最终由对象 <span class="math inline">\(b\)</span> 再态射到对象 <span class="math inline">\(c\)</span>，正如这样：<span class="math display">\[ a \to b \to c \]</span> 从上面我们可以很清晰的看到似乎就只是加上了箭头作为对象之间的连接，就形成了一个包含三个对象，两次态射的范畴了。</p><h2 id="态射复合composition">态射复合（Composition）</h2><p>现在我们要提及到另一个重要的概念：<code>复合（Composition）</code>。上面对象与态射的小章节已经举出了一个简单的范畴例子，实际上我们可以为上面的态射给命名一下，例如改成这样：<span class="math display">\[ a \xrightarrow[f]{} b \xrightarrow[g]{} c \]</span> 于是乎现在会更加直观地看到态射的名字了，我们设对象 <span class="math inline">\(a\)</span> 到 <span class="math inline">\(b\)</span> 的态射称为 <span class="math inline">\(f\)</span> ，而从对象 <span class="math inline">\(b\)</span> 到 <span class="math inline">\(c\)</span> 的态射为 <span class="math inline">\(g\)</span>，最终由于对象 <span class="math inline">\(a\)</span> <span class="math inline">\(b\)</span> <span class="math inline">\(c\)</span> 会透过态射形成一个具备可传递性质的范畴，对象 <span class="math inline">\(a\)</span> 态射到 <span class="math inline">\(c\)</span> 的时候就会形成一个态射的复合（Composition of morphism），因此可以演变成这样：<span class="math display">\[ a \xrightarrow[g \circ f]{} c \]</span> 我们看到上面由 <span class="math inline">\(a\)</span> 到 <span class="math inline">\(c\)</span> 的过程实际就是把 态射 <span class="math inline">\(g\)</span> 和 <span class="math inline">\(f\)</span> 给复合起来，形成一个新的复合态射，称之为 <span class="math inline">\(g \circ f\)</span>。</p><h3 id="在-haskell-上的函数复合">在 Haskell 上的函数复合</h3><p>众所周知很多图灵完全的编程语言上，函数不仅仅只能接受一个或多个参数，并且返回一个返回值，而是可以在满足下列至少任一条件： 1. 一个函数接受一个或多个函数作为输入 2. 输出一个函数</p><p>的情况下，作为一个普通函数使用，而这一概念也就是为人熟知的 <code>高阶函数（Higher-order function）</code>。那么当然在 Haskell 中也不例外，比方说我们现在有两条函数： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trim  :: String -&gt; String</span><br><span class="line">lower :: String -&gt; String</span><br></pre></td></tr></table></figure></p><p>分别是首先对字符串清除空格和后续的把字符串转换为全小写的函数。现在我们可以简单地把它们复合在一起，形成一个复合函数，在 Haskell 里面以 Point-free 形式写出来的代码大概像是这样：<code>lower . trim</code>，就已经成为了一个简单的函数复合了！</p><h2 id="复合的特性properties-of-composition">复合的特性（Properties of Composition）</h2><p>复合（Composition）有两个非常重要的特性，在任何范畴内都必须满足这些特性，才能被称之为复合。</p><h3 id="结合律associative-property">结合律（Associative Property）</h3><p>复合是可结合的，也就是指出一个二元运算（这里是复合）只要它们算子（态射）的位置没有被改变，那就不会对整个复合过程的结果产生影响，也就是即使我们给复合加上改变优先级的运算符（例如括号），也并不会改变整个过程的结果。现在给出三个对象，它们分别是 <span class="math inline">\(f\)</span>，<span class="math inline">\(g\)</span>，<span class="math inline">\(h\)</span>。然后把它们复合到一起：<span class="math display">\[(h \circ g) \circ f = h \circ (g \circ f) = h \circ g \circ f\]</span> 最终可以看出它们的结果均是恒等的。</p><h3 id="单位元identity">单位元（Identity）</h3><p>单位元就如同一个特殊的单位（Unit），任何对象与其复合结果都会返回对象自身：<span class="math display">\[ a \xrightarrow[id_a]{} a \]</span> <span class="math display">\[f \circ id_a = id_a \circ f = f \]</span> 但要切记，上面的单位元 <span class="math inline">\(id_A\)</span> 依旧是一种态射，只不过复合后的结果还是落入了与 <span class="math inline">\(f\)</span> 同一个范畴内。就如同 <span class="math inline">\(2 \times 1\)</span>一样（<span class="math inline">\(1\)</span> 是乘法单位元），它的运算结果永远都只会是整数（这里的范畴可以是整数乘法群，且群论上已定义了封闭性，所以结果不会是其他什么像是字符串，其他类型的自然数等等的这类东西），且最终它运算得出来的结果都会是等于 <span class="math inline">\(2\)</span>，也就是等于自身，因此 <span class="math inline">\(1\)</span> 便符合了作为乘法单位元的特性。</p><h2 id="复合的哲学philosophy-of-composition">复合的哲学（Philosophy of Composition）</h2><p>要讲到复合的本质，它不仅仅只是在 物理学 / 数学 领域下某些分支的概念，或是函数式编程领域公理化或简化实际问题的 "东西"。从计算机的角度出发的话，它表示成一个个的过程，例如说实际编写 Haskell / Java / C++ 等等这些 Higher-Level 编程语言的代码，经过编译这个过程，实际上看似也很类似于态射这个概念，然后把这些代码 "自然转换" 为机器读的懂的东西，最终再由承载执行该语言的虚拟机，或者是 Runtime 负责运行，这一系列的过程连接起来也就形成了一个复合，而这个复合最终代表的就是一个完整的范畴，甚至某种程度上我们可以说我们日常生活遇到的各种事情都可以是一个范畴，而不仅仅是一个集合。范畴本身不仅可以被当成一个分类，而且他还可以把多个小分类给 "连接" 起来，解决一个很复杂很困难的事。在计算机领域最为直接的例子就是现代 CPU 的架构，其逻辑或线路布局复杂程度显然相当的高，但还是分出了 ALU，CU，寄存器，各种总线 等等的这些概念，然后把它们复合在一起运行。其次也就是我们日常编写代码时，如果没有这样化简归纳成一个个范畴的概念，那么现在的程序员可能每时每刻都只能用二进制去编写程序了，导致编写一个程序的门槛不知道高了多少多少，计算机领域的发展也就十分局限了。</p><h2 id="总结conclusion">总结（Conclusion）</h2><p>以上便是本章节的内容了，本篇作为第一节可能会较少讲述实质在范畴论上的内容，而概念较多也是为了帮助自己和读者能够理解及学习到范畴论上的概念，作为日后深入范畴论的一个垫脚石。</p><h2 id="外部链接outside-links">外部链接（Outside Links）</h2><p>本文部分内容参考或引用至下列网页，也可供作为额外的延伸资源帮助阅读： - <a href="https://zh.wikipedia.org/wiki/%E8%8C%83%E7%95%B4%E8%AE%BA" target="_blank" rel="noopener">范畴论 - Wikipedia</a> - <a href="https://bartoszmilewski.com/2014/11/04/category-the-essence-of-composition/" target="_blank" rel="noopener">Category: The Essence of Composition - Bartosz Milewski</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在入坑接触 Haskell 一段时间后，碰到很多类似 &lt;code&gt;Functor&lt;/code&gt; &lt;code&gt;Applicative&lt;/code&gt; &lt;code&gt;Monad&lt;/code&gt; 等等这些诸如此类的 &quot;魔法&quot;，虽然有时候用是会用了，利用各种自定义的 Monad inst
      
    
    </summary>
    
    
      <category term="范畴论" scheme="https://a9032676.github.io/tags/%E8%8C%83%E7%95%B4%E8%AE%BA/"/>
    
      <category term="函数式编程" scheme="https://a9032676.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Codewars: Haskell Five Fundamental Monads</title>
    <link href="https://a9032676.github.io/2019/06/24/Codewars-Five-Fundamental-Monads/"/>
    <id>https://a9032676.github.io/2019/06/24/Codewars-Five-Fundamental-Monads/</id>
    <published>2019-06-24T11:32:13.000Z</published>
    <updated>2019-06-25T13:24:24.478Z</updated>
    
    <content type="html"><![CDATA[<p>This kata corresponds to <a href="https://www.codewars.com/kata/547202bdf7587835d9000c46" target="_blank" rel="noopener">Five-Fundamental-Monads</a> in Codewars Difficulty: 4 kyu Tags: <code>FUNDAMENTALS</code> <code>MONADS</code> <code>DATA STRUCTURES</code> <code>FUNCTIONAL PROGRAMMING</code></p><h2 id="questions">Questions</h2><p>In this kata we will implement five of the most fundamental monads.</p><p>Newcomers to Haskell find monads to be one of the most intimidating concepts but on a basic level - they are not too difficult to understand.</p><p>A datatype forms a monad if it is possible to complete the following definitions such that the monad laws (described below) hold. There's nothing more to it! For a more intuitive understanding then there are a plethora of tutorials which use (sometimes wild) analogies to explain this concept. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Monad m where</span><br><span class="line">    return :: a -&gt; m a</span><br><span class="line">    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br></pre></td></tr></table></figure></p><p>Monad laws <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return x &gt;&gt;= f = f x</span><br><span class="line">m &gt;&gt;= return = m</span><br><span class="line">(m &gt;&gt;= f) &gt;&gt;= g = m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</span><br></pre></td></tr></table></figure></p><p>It turns out that many different types of computation can be encapsulated by monads. For example the Maybe monad encapsulates a computation which can fail and State a computation with mutable state.</p><p>The five we will implement here are <code>Identity</code>, <code>Maybe</code>, <code>State</code>, <code>Writer</code> and <code>Reader</code>.</p><p>Hint: https://www.haskell.org/haskellwiki/Monad_tutorials_timeline</p><p>Note: Please feel free to contribute!</p><h2 id="sources-code">Sources Code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#123;-# LANGUAGE NoImplicitPrelude #-&#125;</span><br><span class="line">module Monads where</span><br><span class="line"></span><br><span class="line">import Prelude hiding (Monad, Identity, Maybe(..), State, Reader, Writer)</span><br><span class="line">import Data.Monoid</span><br><span class="line"></span><br><span class="line">class Monad m where</span><br><span class="line">  return :: a -&gt; m a</span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line"></span><br><span class="line">data Identity a = Identity a</span><br><span class="line">  deriving (Show, Eq)</span><br><span class="line"></span><br><span class="line">data Maybe a = Nothing | Just a</span><br><span class="line">  deriving (Show, Eq)</span><br><span class="line"></span><br><span class="line">data State s a = State &#123;runState :: s -&gt; (a, s)&#125;</span><br><span class="line"></span><br><span class="line">data Reader s a = Reader &#123;runReader :: s -&gt; a &#125;</span><br><span class="line"></span><br><span class="line">data Writer w a = Writer &#123;runWriter :: (w, a)&#125;</span><br><span class="line"></span><br><span class="line">instance Monad Identity where</span><br><span class="line">  return = undefined</span><br><span class="line">  (Identity v) &gt;&gt;= f = undefined</span><br><span class="line"></span><br><span class="line">instance Monad Maybe where</span><br><span class="line">  return = undefined</span><br><span class="line">  Nothing &gt;&gt;= f = undefined</span><br><span class="line">  (Just v) &gt;&gt;= f = undefined</span><br><span class="line"></span><br><span class="line">instance Monad (State s) where</span><br><span class="line">  return = undefined</span><br><span class="line">  (State g) &gt;&gt;= f = undefined</span><br><span class="line"></span><br><span class="line">instance Monad (Reader s) where</span><br><span class="line">  return = undefined</span><br><span class="line">  (Reader g) &gt;&gt;= f = undefined</span><br><span class="line"></span><br><span class="line">instance Monoid w =&gt; Monad (Writer w) where</span><br><span class="line">  return = undefined</span><br><span class="line">  (Writer (s, v)) &gt;&gt;= f = undefined</span><br></pre></td></tr></table></figure><h2 id="how-to-solve">How to solve</h2><h3 id="identity-monad">Identity Monad</h3><p>Above all, we need to implement the Identity monad instance at first, according to the law of identity in Category Theory: which means for every object <span class="math inline">\(x\)</span>, there exists a morphism <span class="math inline">\(id_x : x \mapsto x\)</span> called the identity morphism for <span class="math inline">\(x\)</span>, such that for every morphism <span class="math inline">\(f : a \mapsto x\)</span> and every morphism <span class="math inline">\(g : x \mapsto b\)</span>, we have <span class="math inline">\(id_x \circ f = f\)</span> and <span class="math inline">\(g \circ id_x = g\)</span>. Straightforwardly we can call this as a morphism (or function in a programming language) which always return itself, and for every morphism combine with any identity must be equals to morphism itself anyway.</p><p>By looking at Monad typeclass defination: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Applicative m =&gt; Monad (m :: * -&gt; *) where</span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">  (&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line">  return :: a -&gt; m a</span><br><span class="line">  fail :: String -&gt; m a</span><br><span class="line">  &#123;-# MINIMAL (&gt;&gt;=) #-&#125;</span><br><span class="line">      -- Defined in ‘GHC.Base’</span><br></pre></td></tr></table></figure></p><p>So, in Haskell we can implement identity instance like this: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance Monad Identity where</span><br><span class="line">  return = Identity</span><br><span class="line">  (Identity v) &gt;&gt;= f = f v</span><br></pre></td></tr></table></figure></p><p><code>return</code> function was return a Identity which accepted a parameter <code>a</code> implicitly, and as explicitly can be write like this: <code>return a = Identity a</code></p><p><code>&gt;&gt;=</code> is a monad-binding operator function, means that <code>(Identity v)</code> was bound on function <code>f</code>, by looking at type definition of this function, which accept the parameter <code>m a</code>, <code>(a -&gt; m b)</code> and return the monad <code>m b</code> finally. So now let's turn back to this instance, <code>(Identity v)</code> is the first parameter <code>m a</code> also <code>f</code> represents to <code>(a -&gt; m b)</code>, after the <code>(Identity v)</code> is done the pattern-matching, by take the parameter <code>v</code> out and put it into <code>f</code> and finally return the monad <code>m b</code>, that's it what we need!</p><h3 id="maybe-monad">Maybe Monad</h3><p>After done the identity monad, we are learned about how to construct the simple monad in Haskell, but just the only identity? Not enough! So now I'll start to talk about the next most useful monad in Haskell, the <code>Maybe Monad</code>.</p><p>In this monad, defined two data types: <code>Nothing</code> and <code>Just a</code>, which <code>Nothing</code> does not accept any type parameter but <code>Just a</code> will accept a type parameter <code>a</code> here. So when we hold something just like an integer 1, they we can put it into <code>Just 1</code>, but when holding nothing, then we didn't need to put anything into <code>Just a</code>, so we use <code>Nothing</code> to alternative that.</p><p>So let's implement <code>return</code> function on <code>Maybe Monad</code> first, it seems like the identity monad, but still have some differences. In this case, we need to specify the <code>Nothing</code> and <code>Just</code>, just take a look at the type definition of <code>return</code> function, it's must provide a parameter <code>a</code>, then we can be wrapping it into <code>Just a</code> to becomes <code>return = Just</code> in instance.</p><p>Second, after completed <code>return</code> function, to finish the <code>&gt;&gt;=</code> function, it's also closed to the identity instance, but we know when we put a <code>Nothing</code> into <code>f</code>, there must always return <code>Nothing</code>, otherwise return the result moand from <code>f</code>, so here could be using pattern-matching to partition these two case.</p><p>Finally the <code>Maybe Monad</code> likes: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">instance Monad Maybe where</span><br><span class="line">  return = Just</span><br><span class="line">  Nothing &gt;&gt;= f = Nothing</span><br><span class="line">  (Just v) &gt;&gt;= f = f v</span><br></pre></td></tr></table></figure></p><h3 id="state-monad">State Monad</h3><h3 id="reader-monad">Reader Monad</h3><h3 id="writer-monad">Writer Monad</h3><h2 id="conclusion">Conclusion</h2><p>Great thanks to Henry for fixing my noob English grammar problem!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This kata corresponds to &lt;a href=&quot;https://www.codewars.com/kata/547202bdf7587835d9000c46&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Five-Fundamental
      
    
    </summary>
    
    
      <category term="Haskell" scheme="https://a9032676.github.io/tags/Haskell/"/>
    
      <category term="Monad" scheme="https://a9032676.github.io/tags/Monad/"/>
    
      <category term="Data Structures" scheme="https://a9032676.github.io/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>记录一次在 Linux 下增加分区大小的过程</title>
    <link href="https://a9032676.github.io/2018/12/04/Linux-partition-sizes-modify/"/>
    <id>https://a9032676.github.io/2018/12/04/Linux-partition-sizes-modify/</id>
    <published>2018-12-04T01:23:54.000Z</published>
    <updated>2019-07-22T09:42:36.844Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为要开发一个 Android 项目，因此需要在系统上安装 AndroidStudio，安装途中却提示我 <code>java.io.IOException: No space left on device</code>，立刻就意识到分区空间不足了，因此进行了该次扩容。而我本身是双系统（Ubuntu 18.04 作为日常开发使用，而 Windows 10 作为游戏娱乐用），因此我要对 Ubuntu 下的分区进行扩容。</p><h2 id="如何扩容">如何扩容</h2><ol type="1"><li>使用 GUI 工具：GParted （本篇文章不进行阐述）</li><li>利用 fdisk / parted / lvm 等指令进行扩容</li></ol><h2 id="提前准备">提前准备</h2><ol type="1"><li>备份重要数据，很关键！！！</li><li>因为涉及到 <code>umount</code> 卸载分区操作，请制作好 LiveCD（对应 Linux 版本的 USB 启动盘）</li><li>遇到其他问题请主动查阅相关资料</li></ol><h2 id="找出空间不足的分区">找出空间不足的分区</h2><p>首先使用 <code>df -h | grep "dev/sda"</code> 指令查看 <code>/dev/sda</code> 以下各个分区占用比 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> a9032676@90-Ubuntu  ~  df -h | grep &quot;sda&quot;</span><br><span class="line">/dev/sda10       22G   21G   96M 100% /</span><br><span class="line">/dev/sda8       1.9G  467M  1.3G  27% /media/a9032676/b2b692f8-bdcf-46c1-9998-503b0970f5b3</span><br><span class="line">/dev/sda9        19G  2.8G   15G  16% /media/a9032676/9b5cdc3a-f296-490a-b329-6ae23acee7de</span><br><span class="line">/dev/sda7       4.7G   20M  4.4G   1% /media/a9032676/1bbfb6fa-f919-4460-86f9-5ced5a900ec8</span><br></pre></td></tr></table></figure></p><p>可以得出挂载于 <code>/</code> 的根分区 <code>/dev/sda10</code> 空间严重不足，剩下 96MB。然后我们使用 <code>sudo fdisk -l /dev/sda</code> 指令查询 <code>/dev/sda</code> 下各分区大小及总和。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> a9032676@90-Ubuntu  ~  sudo fdisk -l /dev/sda</span><br><span class="line">Disk /dev/sda: 232.9 GiB, 250059350016 bytes, 488397168 sectors</span><br><span class="line">/dev/sda1  *         2048   1126399   1124352   549M  7 HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda2         1126400 383537151 382410752 182.4G  7 HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda3       383539198 488396799 104857602    50G  5 Extended</span><br><span class="line">/dev/sda5       383539200 383928319    389120   190M 83 Linux</span><br><span class="line">/dev/sda6       383930368 387928063   3997696   1.9G 82 Linux swap / Solaris</span><br><span class="line">/dev/sda7       387930112 397928447   9998336   4.8G 83 Linux</span><br><span class="line">/dev/sda8       397930496 401928191   3997696   1.9G 83 Linux</span><br><span class="line">/dev/sda9       401930240 441927679  39997440  19.1G 83 Linux</span><br><span class="line">/dev/sda10      441929728 488396799  46467072  22.2G 83 Linux</span><br><span class="line"> a9032676@90-Ubuntu  ~ </span><br></pre></td></tr></table></figure></p><p>可以看到这个盘大小总和是 232.9G，而由于双系统的缘故， <code>/dev/sda1</code> 与 <code>/dev/sda2</code> 这两个分区是 Windows 10 的，因此是 NTFS 文件系统。<code>/dev/sda5</code> 为 <code>grub</code> 预留分区，而扩展分区 <code>/dev/sda3</code> 则作为我 Ubuntu 系统所有文件的主分区，可以看见扇区从 <code>383539198</code> 横跨到 <code>488396799</code>，途中包含了 <code>sda5</code> 到 <code>sda10</code> 这几个分区，而他们都是 ext4 文件系统的逻辑分区，加起来刚刚好 50G。</p><h2 id="查询分区挂载情况">查询分区挂载情况</h2><p>确定了是 <code>/dev/sda10</code> 分区空间不足后，我们利用 <code>mount -l | grep "/dev/sda"</code> 指令查看分区实际挂载情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> a9032676@90-Ubuntu  ~  sudo mount -l | grep &quot;/dev/sda&quot;</span><br><span class="line">/dev/sda10 on / type ext4 (rw,relatime,errors=remount-ro,data=ordered)</span><br><span class="line">/dev/sda8 on /media/a9032676/b2b692f8-bdcf-46c1-9998-503b0970f5b3 type ext4 (rw,nosuid,nodev,relatime,data=ordered,uhelper=udisks2)</span><br><span class="line">/dev/sda9 on /media/a9032676/9b5cdc3a-f296-490a-b329-6ae23acee7de type ext4 (rw,nosuid,nodev,relatime,data=ordered,uhelper=udisks2)</span><br><span class="line">/dev/sda7 on /media/a9032676/1bbfb6fa-f919-4460-86f9-5ced5a900ec8 type ext4 (rw,nosuid,nodev,relatime,data=ordered,uhelper=udisks2)</span><br></pre></td></tr></table></figure><p>从以上情况总括出：这台电脑两个系统都是安装在了同一个盘上面（因为是 SSD），合计可用大小是 232.9G，而分给 Ubuntu 的总共有 50G，Windows 则占用了 182.4G（撇除系统保留的 549M）。但现在 Ubuntu 挂载在根目录的分区 <code>/dev/sda10</code> 已经所剩无几，因此我打算的是从 Windows 处 <code>/dev/sda2</code> 释放 30G 的空间为 <code>/dev/sda10</code> 增加容量。</p><h2 id="开始调整">开始调整</h2><ol type="1"><li><p>重启电脑，将系统更换成 Windows 10。</p></li><li><p>在【磁盘管理】处压缩 NTFS 卷/分区，释放已分配空间给予 Ubuntu 使用，这里我共计在 <code>/dev/sda2</code> 处压缩并腾出了共计 30G 的未分配空间。（本步骤不多作阐述，具体可参考：<a href="https://support.microsoft.com/zh-cn/help/944248" target="_blank" rel="noopener">如何在 Windows 中对硬盘进行分区</a>）</p></li><li><p>因为途中涉及根分区前后移动，因此必须要让本身处于 busy（忙碌） 状态的根分区先 <code>unmount</code> （卸载分区），否则会一直锁定着，无法移动。制作对应 Ubuntu 版本的 LiveCD（USB启动盘）。</p></li><li><p>重启电脑并插入刚刚制作好的 USB，切换系统到 USB 搭载的 Ubuntu 系统上。</p></li><li><p>进入系统后。于命令行内手动输入 <code>sudo umount /dev/sda10</code>，把我们的目标分区卸载掉，同时需要将扩展分区内的 Swap Space（交换空间）关闭掉：<code>sudo swapoff -a</code>。</p></li><li><p>然后使用 <code>sudo fdisk /dev/sda</code> 进入 fdisk 命令交互界面以调整分区： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> a9032676@90-Ubuntu  ~  sudo fdisk /dev/sda</span><br><span class="line">[sudo] password for a9032676: </span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.31.1).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m for help):</span><br></pre></td></tr></table></figure></p></li><li><p>然后我们使用 <code>p</code> 指令查询分区情况，虽然上面已经查询过，但为了安全起见还是先确认一遍。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): p</span><br><span class="line">Disk /dev/sda: 232.9 GiB, 250059350016 bytes, 488397168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0xdefb6f09</span><br><span class="line"></span><br><span class="line">Device     Boot     Start       End   Sectors   Size Id Type</span><br><span class="line">/dev/sda1  *         2048   1126399   1124352   549M  7 HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda2         1126400 320622591 319496192 152.4G  7 HPFS/NTFS/exFAT</span><br><span class="line">/dev/sda3       383539198 488396799 104857602    50G  5 Extended</span><br><span class="line">/dev/sda5       383539200 383928319    389120   190M 83 Linux</span><br><span class="line">/dev/sda6       383930368 387928063   3997696   1.9G 82 Linux swap / Solaris</span><br><span class="line">/dev/sda7       387930112 397928447   9998336   4.8G 83 Linux</span><br><span class="line">/dev/sda8       397930496 401928191   3997696   1.9G 83 Linux</span><br><span class="line">/dev/sda9       401930240 441927679  39997440  19.1G 83 Linux</span><br><span class="line">/dev/sda10      441929728 488396799  46467072  22.2G 83 Linux</span><br></pre></td></tr></table></figure><p>可以看到在 <code>/dev/sda2</code> 的扇尾 <code>320622591</code> 与 <code>/dev/sda3</code> 的扇头 <code>383539198</code> 之间差了 <code>62916607</code> 个 Blocks，刚好 30G，也就是我们之前在 Windows 上腾出来的空间。</p><ol start="8" type="1"><li>接下来这一步很关键，由于在我们上面的分区里面，没分配空间是处于扩展分区 <code>/dev/sda3</code> 以及 <code>/dev/sda10</code> 的前面（左侧），而我们需要先将其移动到靠近我们的 <code>/dev/sda10</code> 分区右侧（也就是把 free space 移动到整个盘最后面）方可与 <code>/dev/sda10</code> 逻辑分区进行合并，因此我们需要用到 <code>dd</code> 这条指令去操作分区移动：</li></ol><p>待补充</p><ol start="9" type="1"><li>但由于我们这里的例子 <code>/dev/sda10</code> 本身已经处于整个盘的最后方，因此可以直接使用 fdisk 的 <code>d</code> 与 <code>n</code> 指令直接合并已经移动到 <code>/dev/sda10</code> 左侧旁的 free space，而省去了最后的从 <code>/dev/sda10</code> 左侧移动到其的右侧。</li></ol><p>待补充</p><ol start="10" type="1"><li>在一轮操作完成之后，再输入 <code>p</code> 查询分区表究竟是否有误，再三确认后输入 <code>w</code> 保存变更并退出。</li></ol><p>待补充</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近因为要开发一个 Android 项目，因此需要在系统上安装 AndroidStudio，安装途中却提示我 &lt;code&gt;java.io.IOException: No space left on device&lt;/code&gt;，立刻就意识到分区空间不足了，因此进行了该次扩容。
      
    
    </summary>
    
    
      <category term="硬盘分区" scheme="https://a9032676.github.io/tags/%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA/"/>
    
      <category term="Linux" scheme="https://a9032676.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>让 Lambda 特性使你的 Kotlin 代码更加优雅</title>
    <link href="https://a9032676.github.io/2018/11/22/Lambda-make-code-more-elegant-on-Kotlin/"/>
    <id>https://a9032676.github.io/2018/11/22/Lambda-make-code-more-elegant-on-Kotlin/</id>
    <published>2018-11-21T17:20:36.000Z</published>
    <updated>2019-07-22T09:43:19.555Z</updated>
    
    <content type="html"><![CDATA[<p>相信近年来，也许有这么一批人会认为 Java 语法过于保守及传统，代码写起来就显得有点臃肿了，不直观也不方便，而相对于 Java 而言，Kotlin 虽然与 Java 同属 JVM 平台衍生出来的计算机语言，Kotlin 的语法却比起 Java 来讲有更大的语法自由度（这里仅从语法角度分析），因此我们得以很好地实现某些看起来更简洁更方便的写法，就如同我们今天要讲的主题：在 Kotlin 上让你的代码更加优雅。</p><h2 id="开发环境">开发环境</h2><p>System：Ubuntu 18.04 IDE：IntelliJ IDEA 2018.2.5 JDK version：1.8.0_181（Java 8） Kotlin version：1.3.10（Kotlin 1.3）</p><h2 id="dsl-是什么">DSL 是什么？</h2><h3 id="概念">概念</h3><p>阅读本篇文章要求读者应清晰地认识 DSL 的概念，以及 Kotlin Lambda 的思想。 关于 DSL 可参考我择写的另外一篇文章：</p><h3 id="对于-kotlin-而言dsl-的思维究竟可以对代码有什么实际帮助">对于 Kotlin 而言，DSL 的思维究竟可以对代码有什么实际帮助？</h3><p>如果你已经阅读过上面的文章，应该能够明白到 DSL 应在特定领域发挥作用的重要性，而在 Kotlin 上也是如此。如果你是使用 <code>IntelliJ IDEA</code> 作为你的 IDE，那么在你学习 Kotlin 的时候肯定会使用到内置的 <code>Java to Kotlin converter（J2KC）</code>，也就是把复制后的 Java 的代码粘贴到 <code>.kt</code> 文件后自动转换成 Kotlin 代码，如下面 JavaFX 创建布局的示例：</p><p>原本的 Java 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void create() &#123;</span><br><span class="line">    Label label = new Label(&quot;This is label&quot;);</span><br><span class="line">    label.setStyle(&quot;-fx-font-weight: bold;&quot;);</span><br><span class="line">    label.setTextFill(Color.web(&quot;0069B1&quot;));</span><br><span class="line"></span><br><span class="line">    Rectangle rectangle = new Rectangle(46.0, 18.0);</span><br><span class="line">    rectangle.setArcHeight(10.0);</span><br><span class="line">    rectangle.setArcWidth(10.0);</span><br><span class="line">    rectangle.setFill(Color.web(&quot;#CCEEFF&quot;));</span><br><span class="line">    rectangle.setPadding(new Insets(2.0, 3.0, 2.0, 3.0));</span><br><span class="line"></span><br><span class="line">    StackPane stack = new StackPane();</span><br><span class="line">    stack.setHgap(10);</span><br><span class="line">    stack.setVgap(10);</span><br><span class="line">    stack.children.addAll(rectangle, label);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>透过 <code>J2KC</code> 之后自动转换的 Kotlin 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun create() &#123;</span><br><span class="line">    val label = Label(&quot;This is label&quot;)</span><br><span class="line">    label.style(&quot;-fx-font-weight: bold;&quot;)</span><br><span class="line">    label.textFill(Color.web(&quot;0069B1&quot;))</span><br><span class="line"></span><br><span class="line">    val rectangle = Rectangle(46.0, 18.0)</span><br><span class="line">    rectangle.arcHeight(10.0)</span><br><span class="line">    rectangle.arcWidth(10.0)</span><br><span class="line">    rectangle.fill(Color.web(&quot;#CCEEFF&quot;))</span><br><span class="line">    rectangle.padding(Insets(2.0, 3.0, 2.0, 3.0))</span><br><span class="line"></span><br><span class="line">    val stack = StackPane()</span><br><span class="line">    stack.hgap(10)</span><br><span class="line">    stack.vgap(10)</span><br><span class="line">    stack.children.addAll(rectangle, label)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来回顾下上面代码的转化过，首先 <code>J2KC</code> 分别自动将函数标签从 <code>public void create()</code> 简化成了 <code>fun create()</code>，而因为在 Java 里返回值为 <code>void</code> 而在 Kotlin 里的后置类型声明 <code>fun create(): Unit</code> 可以直接被简化掉。除此以外还有包含对局部变量类型声明直接简化成 <code>var</code> <code>val</code> 以及在创建新实例时把 <code>new</code> 关键词直接去除。当然 <code>J2KC</code> 还有很聪明的一点，也就是能够识别出以 <code>get</code> <code>set</code> 为开头的函数名，直接将其简化成像是对一个字段进行赋值一样，而且也将以 <code>;</code> 为行结尾的符号也去掉了，看起来已经相当不错了。</p><h3 id="美中不足">美中不足</h3><p>转换过程虽然简单，但也足够粗暴，我们再来观察一下转换后的结果，可以看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val stack = StackPane()</span><br><span class="line">stack.hgap(10)</span><br><span class="line">stack.vgap(10)</span><br><span class="line">stack.children.addAll(rectangle, label)</span><br></pre></td></tr></table></figure><p><code>stack.xxx</code> 像这样的操作实在太繁琐，每设置一个值都得事先输入 <code>stack.</code>，而且看上去代码也会显得特别密集，怎么办呢？这部分就是接下来便是我们要解决的问题了。</p><h2 id="如何优化">如何优化</h2><h3 id="善用-apply-与-also-函数">善用 apply() 与 also() 函数</h3><p>像是上面这种情况，我们可以透过 Kotlin 上一个叫 <code>apply()</code> 的函数解决！这个函数位于 Kotlin 标准库内的 <code>Standard.kt</code> 文件里，下面我直接把这一段源码贴上来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Calls the specified function [block] with `this` value as its receiver and returns `this` value.</span><br><span class="line"> */</span><br><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="源码分析">源码分析</h4><p>对于何为扩展函数与泛型本篇并不多作阐述，具体可参考官方文档： <a href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="noopener">Kotlin - Extensions</a> <a href="https://kotlinlang.org/docs/reference/generics.html" target="_blank" rel="noopener">Kotlin - Generics</a></p><p>这个函数很简单，我们首先先看函数标签：<code>public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T</code>，意思大概就是一个带有型参 T <a href="https://kotlinlang.org/docs/reference/inline-functions.html" target="_blank" rel="noopener">内联函数</a>，并以这个型参作为扩展函数 <code>apply</code> 的目标，并且接受一个 <code>T.() -&gt; Unit</code> 的 Lambda 类型作为参数传入，最终返回型参实际值 T。可以看到其实最核心的部分其实是 <code>T.() -&gt; Unit</code>，也就是接受一个无参数无返回值的 Lambda，其作用就相当于是一个回调函数，而这个 Lambda 也是基于型参 T 扩展出来的函数。因此我们传入回调函数的时候就可以像这么写：<code>example.apply {}</code>，在 <code>{}</code> 之内的内容就是我们回调函数需要执行的代码了。</p><h4 id="例子">例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val example = Example()</span><br><span class="line"></span><br><span class="line">example.apply &#123;</span><br><span class="line"></span><br><span class="line">    // 这里的 `this` 实际上指向的是 `example` 这个实例</span><br><span class="line">    this</span><br><span class="line"></span><br><span class="line">    // 调用一条被定义在 `Example` 类下的函数实际上可以从</span><br><span class="line">    this.test()</span><br><span class="line">    // 简化成这样，而类下方的字段则也是相同做法</span><br><span class="line">    test()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实际使用">实际使用</h4><p>然后我们使用在之前提到的 JavaFX 例子上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun create() &#123;</span><br><span class="line">    val label = Label(&quot;This is label&quot;).apply &#123;</span><br><span class="line">        style(&quot;-fx-font-weight: bold;&quot;)</span><br><span class="line">        textFill(Color.web(&quot;0069B1&quot;))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val rectangle = Rectangle(46.0, 18.0).apply &#123;</span><br><span class="line">        arcHeight(10.0)</span><br><span class="line">        arcWidth(10.0)</span><br><span class="line">        fill(Color.web(&quot;#CCEEFF&quot;))</span><br><span class="line">        padding(Insets(2.0, 3.0, 2.0, 3.0))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val stack = StackPane().apply &#123;</span><br><span class="line">        hgap(10)</span><br><span class="line">        vgap(10)</span><br><span class="line">        children.addAll(rectangle, label)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉不够？我们还可以改成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun create() &#123;</span><br><span class="line">    val label = </span><br><span class="line">    val rectangle = </span><br><span class="line">    val stack = StackPane().apply &#123;</span><br><span class="line">        hgap(10)</span><br><span class="line">        vgap(10)</span><br><span class="line">        children.addAll(</span><br><span class="line">            Label(&quot;This is label&quot;).apply &#123;</span><br><span class="line">            style(&quot;-fx-font-weight: bold;&quot;)</span><br><span class="line">            textFill(Color.web(&quot;0069B1&quot;))</span><br><span class="line">        &#125;,</span><br><span class="line">        Rectangle(46.0, 18.0).apply &#123;</span><br><span class="line">            arcHeight(10.0)</span><br><span class="line">            arcWidth(10.0)</span><br><span class="line">            fill(Color.web(&quot;#CCEEFF&quot;))</span><br><span class="line">            padding(Insets(2.0, 3.0, 2.0, 3.0))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相信近年来，也许有这么一批人会认为 Java 语法过于保守及传统，代码写起来就显得有点臃肿了，不直观也不方便，而相对于 Java 而言，Kotlin 虽然与 Java 同属 JVM 平台衍生出来的计算机语言，Kotlin 的语法却比起 Java 来讲有更大的语法自由度（这里
      
    
    </summary>
    
    
      <category term="DSL" scheme="https://a9032676.github.io/tags/DSL/"/>
    
      <category term="代码设计" scheme="https://a9032676.github.io/tags/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Kotlin" scheme="https://a9032676.github.io/tags/Kotlin/"/>
    
      <category term="Lambda" scheme="https://a9032676.github.io/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>DSL：解释与设计目的</title>
    <link href="https://a9032676.github.io/2018/11/21/DSL-explain-and-goals/"/>
    <id>https://a9032676.github.io/2018/11/21/DSL-explain-and-goals/</id>
    <published>2018-11-21T14:29:41.000Z</published>
    <updated>2019-07-22T09:41:28.162Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来，对于 DSL 这个词大家应该是既熟悉而又陌生，熟悉的是它写起来像啥样，陌生的是他的本质到底是什么，而今天作为第一篇在博客发布的文章就想来探讨一下这个问题。</p><h2 id="dsl-的本质与解释">DSL 的本质与解释</h2><p>首先，我们来看看 Wiki 是怎么解释 DSL 的： &gt; A domain-specific language (DSL) is a computer language specialized to a particular application domain. This is in contrast to a general-purpose language (GPL), which is broadly applicable across domains （原文出处：<a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="noopener">Wiki: Domain-Specific Language</a>）</p><p>而把上面择要翻译过来就是：DSL (领域特定语言) 是专注于某个应用程序领域的计算机语言，而对比起 GPL （通用程序设计语言，例如 Java / C / Python...），DSL 能够在特定的应用领域中具有更大的拓展性及其延伸性。看到这里可能还有部分人不明白这到底是怎么一回事，其实简单来说 DSL 就是为解决特定领域的事情而生的，如果曾经作为 Java 程序员，你可能会经常使用 Maven 跟 Gradle 这两款包管理器去管理你的依赖/库，而透过对比两者语法上更是大相径庭，例如 Maven 采用的是 XML 语法的标记语言，因此我们先来看一下在 Maven 引用依赖部分是怎么写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;group&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;project&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>而 Gradle 则是像这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile group: &quot;group&quot;, name: &quot;project&quot;, version: 1.0.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述看到的两种包管理框架语法差别都很大，而 Gradle 对比起 Maven 而言则要更为简洁，而这是为什么呢？最主要的其实就是这两者各自采用了不同种类的语法，Maven 采用的是基于 GPL 的标记语言： <a href="https://en.wikipedia.org/wiki/General-purpose_markup_language" target="_blank" rel="noopener">GPML (General-purpose markup languages)</a>，而 <code>GPML</code> 还包含了 <code>XML</code> <code>YAML</code> <code>GML</code> 等等。除此以外，我们想要在 Maven 里插入有关构建时执行的代码段（或是Task）是非常困难的，其 XML 语法的甚至都大大束缚了代码编写，例如 <code>if</code> <code>switch</code> 这一类流程控制的语法在 XML 上实现就显得非常困难或根本无法实现。由此可见，其实 Maven 虽然用了 XML，但其本身是基于 GPML 的，对于解决特定范畴的问题就显得特别的繁琐了。</p><p>而 Gradle 呢？除了继承自 Groovy 的语法外，其本身还具有一个特性：为解决 Java，Kotlin，Scala 等包问题管理而推出的一种独立框架，也就三基于 DSL 设计思想出来的产物，而相较于 Maven，Gradle 其本身就是为了解决特定领域的问题而生的，其本身语法上导入包更简洁，而且可以比 Maven 更方便解决插入构建期的代码段，解决了 Maven 一直以来难以实现的地方。</p><h2 id="dsl-的设计目标">DSL 的设计目标</h2><p>DSL 的设计理应十分谨慎，在软件工程上，DSL 总是负责解决领域相关问题及应用于特定领域。一个良好的 DSL 语法设计可以有助于在特定领域更方便地使用，以至于提升开发效率。</p><p>以下给出在 Wiki 给出的三个设计重点的定义，而且均是有别于 GPL 的：</p><blockquote><p>domain-specific languages are less comprehensive. domain-specific languages are much more expressive in their domain. domain-specific languages should exhibit minimal redundancy.</p></blockquote><ul><li>DSL 相较于 GPL 而言范用性要低，因为需要专注于单个特定领域</li><li>DSL 理应在特定领域上比基于 GPL 发挥的作用更大更广</li><li>DSL 应该要尽可能地将（语法设计）冗余部分最小化，更为简单</li></ul><h2 id="总结">总结</h2><p>总括而言，虽然 GPL 出来的产物可以广泛地应用在不同领域上，例如序列化，上述的 Maven 包管理等，有些时候这类语言在解决某些领域上的特定问题就很困难。而 DSL 则可以解决某些特定领域的问题，而且提出该领域应用更优的解决方案，就如同上述的 Gradle，SQL 等。</p><h2 id="延伸阅读">延伸阅读</h2><ul><li><a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="noopener">Domain-specific language - Wikipedia</a></li><li><a href="https://stackoverflow.com/questions/809574/what-is-domain-specific-language-anybody-using-it-and-in-what-way" target="_blank" rel="noopener">What is domain specific language? Anybody using it? And in what way? - StackOverflow</a></li><li><a href="https://www.jetbrains.com/mps/concepts/domain-specific-languages/" target="_blank" rel="noopener">Domain-Specific Languages - Jetbrains</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直以来，对于 DSL 这个词大家应该是既熟悉而又陌生，熟悉的是它写起来像啥样，陌生的是他的本质到底是什么，而今天作为第一篇在博客发布的文章就想来探讨一下这个问题。&lt;/p&gt;
&lt;h2 id=&quot;dsl-的本质与解释&quot;&gt;DSL 的本质与解释&lt;/h2&gt;
&lt;p&gt;首先，我们来看看 Wi
      
    
    </summary>
    
    
      <category term="DSL" scheme="https://a9032676.github.io/tags/DSL/"/>
    
      <category term="代码设计" scheme="https://a9032676.github.io/tags/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
