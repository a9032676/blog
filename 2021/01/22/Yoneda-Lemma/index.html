<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    
    
    
    
    <title>Yoneda Lemma 的证明 | 9032676&#39;s Blog | 为探索而生</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="范畴论,函数式编程">
    <meta name="description" content="阅读须知  本篇文章面向人群是接触过 Category theory (范畴论) 以及 函数式编程，但未曾接触过 Yoneda Lemma (米田引理) 的读者食用。 通篇对于范畴论内的专有名词一律采用了英文词汇的形式表达，以防中文翻译各类型文章不统一，可能存在误导性。 文章中可能会存在一些 Agda 或 Haskell 语言的代码。没有相关知识不要紧，这只是给予相关领域的朋友一个直觉，用以辅助说">
<meta name="keywords" content="范畴论,函数式编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Yoneda Lemma 的证明">
<meta property="og:url" content="https://a9032676.github.io/2021/01/22/Yoneda-Lemma/index.html">
<meta property="og:site_name" content="9032676&#39;s Blog">
<meta property="og:description" content="阅读须知  本篇文章面向人群是接触过 Category theory (范畴论) 以及 函数式编程，但未曾接触过 Yoneda Lemma (米田引理) 的读者食用。 通篇对于范畴论内的专有名词一律采用了英文词汇的形式表达，以防中文翻译各类型文章不统一，可能存在误导性。 文章中可能会存在一些 Agda 或 Haskell 语言的代码。没有相关知识不要紧，这只是给予相关领域的朋友一个直觉，用以辅助说">
<meta property="og:locale" content="zh_CN">
<meta property="og:updated_time" content="2021-03-02T06:05:13.550Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yoneda Lemma 的证明">
<meta name="twitter:description" content="阅读须知  本篇文章面向人群是接触过 Category theory (范畴论) 以及 函数式编程，但未曾接触过 Yoneda Lemma (米田引理) 的读者食用。 通篇对于范畴论内的专有名词一律采用了英文词汇的形式表达，以防中文翻译各类型文章不统一，可能存在误导性。 文章中可能会存在一些 Agda 或 Haskell 语言的代码。没有相关知识不要紧，这只是给予相关领域的朋友一个直觉，用以辅助说">
    
        <link rel="alternate" type="application/atom+xml" title="9032676&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">9032676</h5>
          <a href="mailto:9032676@gmail.com" title="9032676@gmail.com" class="mail">9032676@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/a9032676" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/friends"  >
                <i class="icon icon-lg icon-link"></i>
                朋友们
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about-me"  >
                <i class="icon icon-lg icon-question-circle"></i>
                关于我
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Yoneda Lemma 的证明</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Yoneda Lemma 的证明</h1>
        <h5 class="subtitle">
            
                <time datetime="2021-01-21T16:29:00.000Z" itemprop="datePublished" class="page-time">
  2021-01-22
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#阅读须知"><span class="post-toc-number">1.</span> <span class="post-toc-text">阅读须知</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前言"><span class="post-toc-number">2.</span> <span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#hom-set-hom-集合"><span class="post-toc-number">3.</span> <span class="post-toc-text">Hom-set (Hom-集合)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">定义</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#例子"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">例子</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#hom-functor-hom-函子"><span class="post-toc-number">4.</span> <span class="post-toc-text">Hom-functor (Hom-函子)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#covariant-hom-functor-协变-hom-函子"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">Covariant Hom-functor (协变 Hom-函子)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义-1"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">定义</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#证明"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">证明</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#contravariant-hom-functor-逆变-hom-函子"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">Contravariant Hom-functor (逆变 Hom-函子)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义-2"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">定义</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#证明-1"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">证明</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#mixed-variant-hom-functor-双变-hom-函子"><span class="post-toc-number">4.7.</span> <span class="post-toc-text">Mixed-variant Hom-functor (双变 Hom-函子)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义-3"><span class="post-toc-number">4.8.</span> <span class="post-toc-text">定义</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#yoneda-lemma"><span class="post-toc-number">5.</span> <span class="post-toc-text">Yoneda Lemma</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义-4"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">定义</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#透过交换图观察米田引理的结构"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">透过交换图观察米田引理的结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#证明-2"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">证明</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#于-agda-中的表达"><span class="post-toc-number">5.3.1.</span> <span class="post-toc-text">于 Agda 中的表达</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#于-haskell-中表达"><span class="post-toc-number">5.3.2.</span> <span class="post-toc-text">于 Haskell 中表达</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#结语"><span class="post-toc-number">6.</span> <span class="post-toc-text">结语</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#外部链接"><span class="post-toc-number">7.</span> <span class="post-toc-text">外部链接</span></a></li></ol>
        </nav>
    </aside>


<article id="post-Yoneda-Lemma"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Yoneda Lemma 的证明</h1>
        <div class="post-meta">
            <time class="post-time" title="2021-01-22 00:29:00" datetime="2021-01-21T16:29:00.000Z"  itemprop="datePublished">2021-01-22</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="阅读须知">阅读须知</h2>
<ul>
<li>本篇文章面向人群是接触过 Category theory (范畴论) 以及 函数式编程，但未曾接触过 Yoneda Lemma (米田引理) 的读者食用。</li>
<li>通篇对于范畴论内的专有名词一律采用了英文词汇的形式表达，以防中文翻译各类型文章不统一，可能存在误导性。</li>
<li>文章中可能会存在一些 Agda 或 Haskell 语言的代码。没有相关知识不要紧，这只是给予相关领域的朋友一个直觉，用以辅助说明的。</li>
<li>这是我在知乎发布的第一篇文章，如对文章本身抱有任何疑问或是纠错欢迎提出，在此感谢各位！</li>
</ul>
<h2 id="前言">前言</h2>
<p><a href="https://en.wikipedia.org/wiki/Yoneda_lemma" target="_blank" rel="noopener">Yoneda Lemma (米田引理)</a> 是范畴论里面一个有关函子的态射实质上可被映射至固定对象上的重要结论，使我们得以透过该引理去推导出更多的定理出来，或者透过该引理观察某些结构上的微妙联系，而对应到计算机编程上亦可擦出火花，比如 Yoneda-embedding 与 CPS 变换 的关系等等。当然，本篇文章主要目的皆指在于引导读者一步步地推导出 Yoneda Lemma，以及给予相应的直觉。</p>
<p>由于 Yoneda Lemma 涉及到一些范畴论上的前置知识，因此在介绍 Yoneda Lemma 之前，首先从 hom-set 开始讲起。</p>
<h2 id="hom-set-hom-集合">Hom-set (Hom-集合)</h2>
<p>就函数而言，比方说从 <span class="math inline">\(\Bbb{Z}\)</span> 到 <span class="math inline">\(\Bbb{Z}\)</span> 之间的映射存在的可能不止有仅仅一条函数，它可能还存在着很多不同的函数，诸如 <span class="math inline">\(f,\ g,\ h, ... : \Bbb{Z} \to \Bbb{Z}\)</span> 等等。而由这一束函数所组成的集合，在范畴论中则被称之为 hom-set，即由 morphism(s) 所组成的集合。</p>
<p>由集合作为 object 所组成的 category 则被称之为 category of sets (集合范畴)，它们之间的 morphism(s) 即是 hom-set(s)，因此也可被称为 locally small category (局部小范畴)。</p>
<h3 id="定义">定义</h3>
<p>给定 object <span class="math inline">\(x,\ y\)</span> 于 locally small category <span class="math inline">\(C\)</span> 内，hom-set 则是所有从 object <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的 morphisms 所形成的搜集，记为 <span class="math inline">\(Hom_C(x,\ y)\)</span> （这里的 <span class="math inline">\(C\)</span> 为 category 的名字，或是 <span class="math inline">\(C(x,\ y)\)</span>，并且可省略地记为 <span class="math inline">\(Hom(x,\ y)\)</span>）。</p>
<h3 id="例子">例子</h3>
<p>设有 category <span class="math inline">\(C\)</span>，并且有： <br> 1. Objects：<span class="math inline">\(a,\ b \in obj(C)\)</span> <br> 2. Morphisms：<span class="math inline">\(f : a \to b\)</span>，<span class="math inline">\(g : a \to b\)</span>，<span class="math inline">\(h : a \to b\)</span></p>
<p><span class="math display">\[
\xymatrix{
a \ar@{-&gt;}[r]|-{f} \ar@/^1pc/@{-&gt;}[r]|-{g} \ar@/_1pc/@{-&gt;}[r]|-{h} &amp; b
}
\]</span></p>
<p>那么对于所有从 object <span class="math inline">\(a\)</span> 到 <span class="math inline">\(b\)</span> 的 morphisms，则记为 <span class="math inline">\(Hom_C(a,\ b)\)</span>，因此 <span class="math inline">\(f,\ g,\ h \in Hom_C(a,\ b)\)</span> 。</p>
<h2 id="hom-functor-hom-函子">Hom-functor (Hom-函子)</h2>
<p>由于 Yoneda Lemma 涉及到 hom-functor 的概念，因此 hom-set 肯定是不足够表达 Yoneda Lemma 含义的，我们还需要事先定义一下何为 hom-functor。而 hom-functor 共分为三种，分别是 covariant，contravariant 以及 mixed-variant hom-functor。</p>
<h3 id="covariant-hom-functor-协变-hom-函子">Covariant Hom-functor (协变 Hom-函子)</h3>
<p>我们都知道在 object 之间的 morphism(s) 所组成的集合是 hom-set。而对于 hom-functor 而言，通俗的说即是把 object 从原来的 category 中映射为 hom-set，并且把 morphisms 映射为 hom-sets 之间的 morphisms，进而建立 (covariant) hom-functor 的概念。</p>
<p>那么该如何构造出这一概念？对于这一疑问，我们可以先假设有 locally small category <span class="math inline">\(C\)</span> 以及一些 object，例如 <span class="math inline">\(X, A, B \in obj(C)\)</span>，然后 对于所有 <span class="math inline">\(X\)</span> 将作为 fixed object，并且分别有 <span class="math inline">\(X\)</span> 到 <span class="math inline">\(A\)</span> 以及 <span class="math inline">\(X\)</span> 到 <span class="math inline">\(B\)</span> 的 hom-sets。那么 (covariant) hom-functor 的样子是这样的：</p>
<p><span class="math display">\[
\xymatrix{
X \ar@/_/@{-&gt;}[r] \ar@{-&gt;}[rd] \ar@/^/@{-&gt;}[r] \ar@/_/@{-&gt;}[rd] \ar@/^/@{-&gt;}[rd] \ar@{-&gt;}[r] &amp; A \ar@/^/@{-&gt;}[rrr]^{Covariant\ hom-functor} &amp;  &amp;  &amp; Hom(X,\ A) \\
 &amp; B \ar@/^/@{-&gt;}[rrr]^{Covariant\ hom-functor} &amp;  &amp;  &amp; Hom(X,\ B)
}
\]</span></p>
<p>从上图可见，当把 <span class="math inline">\(X\)</span> 给固定住后，object <span class="math inline">\(A\)</span> 将会映射为一个 <span class="math inline">\(Hom(X,\ A)\)</span>，<span class="math inline">\(B\)</span> 则被映射为 <span class="math inline">\(Hom(X,\ B)\)</span>，所以说只要把其中一边给固定住了 (这里固定了 hom-set 的左侧，而右侧可变的位置是协变位，因此称为 covariant hom-functor)，对于任何可变的 object (这里则指 <span class="math inline">\(A\)</span> 或 <span class="math inline">\(B\)</span>)，便可透过 (covariant) hom-functor 被映射成 hom-set 了。</p>
<p>当然，除了 object 以外，我们还需设想 morphisms 的情况。<br> 现在设 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 之间存在 morphism <span class="math inline">\(f\)</span>，那么对于 morphisms 而言，被映射至 <span class="math inline">\(Set\)</span> 之后便是这样：</p>
<p><span class="math display">\[
\xymatrix{
X \ar@/_/@{-&gt;}[r] \ar@{-&gt;}[rd] \ar@/^/@{-&gt;}[r] \ar@/_/@{-&gt;}[rd] \ar@/^/@{-&gt;}[rd] \ar@{-&gt;}[r] &amp; A \ar@/^/@{-&gt;}[rrr]^{Covariant\ hom-functor} \ar@{-&gt;}[d]^{f} &amp;  &amp;  &amp; Hom(X,\ A) \ar@{-&gt;}[d]^{Hom(X,\ f)} \\
 &amp; B \ar@/^/@{-&gt;}[rrr]^{Covariant\ hom-functor} &amp;  &amp;  &amp; Hom(X,\ B)
}
\]</span></p>
<p>即 morphism <span class="math inline">\(f\)</span> 将被映射成 <span class="math inline">\(Hom(X,\ f)\)</span> (这里可以理解为 <span class="math inline">\(Hom(id_X,\ f)\)</span>)。</p>
<p>那么便可总结出规律，想要定义出 hom-functor 的概念，必须要知道到底 objects 是应该怎样被映射的，morphisms 亦应怎么被映射的，并且证明其满足 functor laws，最终便可定义出 covariant hom-functor 了。</p>
<h3 id="定义-1">定义</h3>
<p>设有 locally small category <span class="math inline">\(C\)</span>，固定 <span class="math inline">\(C\)</span> 下的 object <span class="math inline">\(X\)</span> 为 fixed object，有：<br> 1. Objects：<span class="math inline">\(A, B \in obj(C)\)</span>，<span class="math inline">\(Hom(X,\ A)\)</span>，<span class="math inline">\(Hom(X,\ B) \in obj(Set)\)</span><br> 2. Morphisms：<span class="math inline">\(f : A \to B, g : X \to A \in mor(C)\)</span>，<span class="math inline">\(Hom(X,\ f) \in mor(Set)\)</span></p>
<p>则 <span class="math inline">\(Hom(X, -) : C \to Set\)</span> (或 <span class="math inline">\(h_X\)</span>) 被称为 covariant hom-functor，并有如下图表：</p>
<p><span class="math display">\[
\xymatrix{
X \ar@{-&gt;}[r]^{g} \ar@{-&gt;}[rd]_{f \circ g} &amp; A \ar@{-&gt;}[d]^{f} \ar@/^/@{-&gt;}[rr]|-{Hom(X,-)} &amp;  &amp; Hom(X, A) \ar@{-&gt;}[d]_{Hom(X, f)} &amp; g \ar@{|-&gt;}[d] \\
 &amp; B \ar@/^/@{-&gt;}[rr]|-{Hom(X,-)} &amp;  &amp; Hom(X, B) &amp; f \circ g
}
\]</span></p>
<p>而 covariant hom-functor 由以下两部分组成：<br> <span class="math inline">\(obj(C) \to obj(Set)\)</span>：<span class="math inline">\(\forall A \in obj(C)，有 A \mapsto Hom(X,\ A)\)</span><br> <span class="math inline">\(mor(C) \to mor(Set)\)</span>：<span class="math inline">\(\forall f \in A \to B\)</span>，<span class="math inline">\(g : Hom(X,\ A)\)</span>，有 <span class="math inline">\(g \mapsto f \circ g\)</span></p>
<p>Covariant hom-functor 本身结构是 <span class="math inline">\(F : C \to Set\)</span>，因此也可被称为 representable functor (可表函子) 。</p>
<h3 id="证明">证明</h3>
<p>Identity laws：<span class="math inline">\(Hom(X, id_A) = id_A\)</span><br> Composition laws：<span class="math inline">\(Hom(X,\ g \circ f) = Hom(X,\ g) \circ Hom(X,\ f)\)</span></p>
<p>由此可见 covariant hom-functor 满足 functor laws，因此它是一个 functor。</p>
<h3 id="contravariant-hom-functor-逆变-hom-函子">Contravariant Hom-functor (逆变 Hom-函子)</h3>
<p>而 contravariant hom-functor，只需把 covariant hom-functor 中 domain (逆变位置) 或 codomain (协变位置) 其中任意一个 category 改为 opposite category，这里我们采用改变逆变位置的 category，即有：</p>
<p><span class="math display">\[
\xymatrix{
X &amp; A \ar@/^/@{-&gt;}[l] \ar@/^/@{-&gt;}[rrr]^{Contravariant\ hom-functor} \ar@/_/@{-&gt;}[l] \ar@{-&gt;}[l] &amp;  &amp;  &amp; Hom(A,\ X) \ar@{-&gt;}[d]^{Hom(f,\ X)} \\
 &amp; B \ar@{-&gt;}[lu] \ar@/^/@{-&gt;}[rrr]^{Contravariant\ hom-functor} \ar@/^/@{-&gt;}[lu] \ar@/_/@{-&gt;}[lu] \ar@{-&gt;}[u]_{f} &amp;  &amp;  &amp; Hom(B,\ X)
}
\]</span></p>
<h3 id="定义-2">定义</h3>
<p>设有 locally small category <span class="math inline">\(C^{op}\)</span>，固定 <span class="math inline">\(C\)</span> 下的 object <span class="math inline">\(X\)</span> 为 fixed object，并且有：<br> 1. Objects：<span class="math inline">\(A, B \in Obj(C^{op})\)</span>，<span class="math inline">\(Hom(A,\ X), Hom(B,\ X) \in obj(Set)\)</span><br> 2. Morphisms：<span class="math inline">\(f : B \to A, g : A \to X \in mor(C)\)</span>，<span class="math inline">\(Hom(f,\ X) \in mor(Set)\)</span><br></p>
<p>则 <span class="math inline">\(Hom(-, X) : C \to Set\)</span> (或 <span class="math inline">\(h^X\)</span>) 被称为 contravariant hom-functor，并有如下图表：</p>
<p><span class="math display">\[
\xymatrix{
X &amp; A \ar@{-&gt;}[l]_{g} \ar@/^/@{-&gt;}[rr]^{Hom(-,\ X)} &amp;  &amp; Hom(A,\ X) \ar@{-&gt;}[d]^{Hom(f,\ X)} &amp; g  \ar@{|-&gt;}[d] \\
 &amp; B \ar@{-&gt;}[lu]^{f \circ g} \ar@/^/@{-&gt;}[rr]^{Hom(-,\ X)} \ar@{-&gt;}[u]_{f} &amp;  &amp; Hom(B,\ X) &amp; f \circ g
}
\]</span></p>
<p>而 contravariant hom-functor 由以下两部分组成：<br> <span class="math inline">\(obj(C^{op}) \to obj(Set)\)</span>：<span class="math inline">\(\forall A \in obj(C^{op})\)</span>，有 <span class="math inline">\(A \mapsto Hom(A,\ X)\)</span><br> <span class="math inline">\(mor(C^{op}) \to mor(Set)\)</span>：<span class="math inline">\(\forall f \in B \to A\)</span>，<span class="math inline">\(g : Hom(A,\ X)\)</span>，有 <span class="math inline">\(g \mapsto f \circ g\)</span></p>
<p>Contravariant hom-functor 本身结构是 <span class="math inline">\(F : C^{op} \to Set\)</span>，于拓扑里有另外一个名字，称之为 presheaf (预层) 。</p>
<h3 id="证明-1">证明</h3>
<p>Identity laws：<span class="math inline">\(Hom(id_A, X) = id_A\)</span><br> Composition laws：<span class="math inline">\(Hom(g \circ f,\ X) = Hom(g,\ X) \circ Hom(f,\ X)\)</span></p>
<p>由此可见 contravariant hom-functor 满足 functor laws，因此它是一个 functor。</p>
<h3 id="mixed-variant-hom-functor-双变-hom-函子">Mixed-variant Hom-functor (双变 Hom-函子)</h3>
<p>Mixed-variant hom-functor 相较于上述的 covariant 及 contravariant hom-functor，最大的区别是它能同时接受两个变元，即 <span class="math inline">\(Hom(-, -) : C^{op} \times C \to Set\)</span>，因此被称为 mixed-variant hom-functor，该 functor 是一个 <span class="math inline">\(Id_C\)</span> 的 profunctor，亦可被视为是一个 bifunctor 的结构。</p>
<h3 id="定义-3">定义</h3>
<p>设有 locally small category <span class="math inline">\(C\)</span> 并且有 <span class="math inline">\(C\)</span> 的 opposite category <span class="math inline">\(C^{op}\)</span><br> Objects：<span class="math inline">\(A, A&#39; \in Obj(C^{op})\)</span>，<span class="math inline">\(B, B&#39; \in Obj(C)\)</span><br> Morphisms：<span class="math inline">\(f : A&#39; \to A\)</span>，<span class="math inline">\(h : B \to B&#39;\)</span><br> Functors：<span class="math inline">\(Hom(-, X) : C^{op} \to Set\)</span>，<span class="math inline">\(Hom(X, -) : C \to Set\)</span></p>
<p>那么即有图：</p>
<p><span class="math display">\[
\xymatrix{
A \ar@{-&gt;}[rr]^{Hom(-,X)} &amp;  &amp; Hom(A,\ B) \ar@{-&gt;}[rd]^{Hom(f,\ h)} &amp;  \\
A&#39; \ar@{-&gt;}[u]^{f} \ar@{-&gt;}[rrr]^{Hom(-,X)} &amp;  &amp;  &amp; Hom(A&#39;,\ B&#39;) \\
 &amp;  &amp;  &amp;  \\
 &amp;  &amp; B \ar@{-&gt;}[r]_{h} \ar@{-&gt;}[uuu]|-{Hom(X,-)} &amp; B&#39; \ar@{-&gt;}[uu]|-{Hom(X,-)}
}
\]</span></p>
<p>而由于 <span class="math inline">\(Hom(X, -)\)</span> 以及 <span class="math inline">\(Hom(-, X)\)</span> 二者皆是从某个 category 中 morphism 至 <span class="math inline">\(Set\)</span>，因此该处可构成一 product category (乘积范畴)，即 <span class="math inline">\(C^{op} \times C\)</span>，所以有 functor <span class="math inline">\(Hom(-, -) : C^{op} \times C \to Set\)</span>：</p>
<p><span class="math display">\[
\xymatrix{
 &amp;  &amp; Hom(A,\ B) \ar@{-&gt;}[rd]|-{Hom(f,\ h)} &amp;  \\
A \ar@{-&gt;}[r] &amp; (A,\ B) \ar@{-&gt;}[rd]|-{(f,\ h)} \ar@{-&gt;}[ru]|-{Hom(-,\ -)} &amp;  &amp; Hom(A&#39;, \ B&#39;) \\
A&#39; \ar@{-&gt;}[u]^{f} \ar@{-&gt;}[rr] &amp;  &amp; (A&#39;,\ B&#39;) \ar@{-&gt;}[ru]|-{Hom(-,\ -)} &amp;  \\
 &amp; B \ar@{-&gt;}[r]_{h} \ar@{-&gt;}[uu] &amp; B&#39; \ar@{-&gt;}[u] &amp; 
}
\]</span></p>
<p>而对于 <span class="math inline">\(Set\)</span> 中 <span class="math inline">\(Hom(f,\ h) : Hom(A,\ B) \to Hom(A&#39;,\ B&#39;)\)</span>，假设固定任意一边的变元为 <span class="math inline">\(id\)</span>，那么 morphisms 则为：<span class="math inline">\(Hom(id_A,\ h) : Hom(A, B) \to Hom(A, B&#39;)\)</span>，<span class="math inline">\(Hom(f,\ id_B) : Hom(A,\ B) \to Hom(A&#39;,\ B)\)</span>，<span class="math inline">\(Hom(id_{A&#39;},\ h) : Hom(A&#39;, B) \to Hom(A&#39;, B&#39;)\)</span>，<span class="math inline">\(Hom(f,\ id_{B&#39;}) : Hom(A,\ B&#39;) \to Hom(A&#39;,\ B&#39;)\)</span>，所以会有图：</p>
<p><span class="math display">\[
\xymatrix{
Hom(A,\ B) \ar@{-&gt;}[rr]^{Hom(A,\ h)} \ar@{-&gt;}[dd]_{Hom(f,\ B)} &amp;  &amp; Hom(A,\ B&#39;) \ar@{-&gt;}[dd]^{Hom(f,\ B&#39;)} \\
 &amp;  &amp;  \\
Hom(A&#39;,\ B) \ar@{-&gt;}[rr]_{Hom(A&#39;,\ h)} &amp;  &amp; Hom(A&#39;,\ B&#39;)
}
\]</span></p>
<p>为了证明该图可交换，现在假设有 <span class="math inline">\(g \in Hom(A,\ B)\)</span>，那么有：</p>
<p><span class="math display">\[
\xymatrix{
Hom(A,\ B) \ar@{-&gt;}[rrr]^{Hom(A,\ h)} \ar@{-&gt;}[ddd]_{Hom(f,\ B)} &amp;  &amp;  &amp; Hom(A,\ B&#39;) \ar@{-&gt;}[ddd]^{Hom(f,\ B&#39;)} \\
 &amp; g \ar@{|-&gt;}[r] \ar@{|-&gt;}[d] &amp; h \circ g \ar@{|-&gt;}[d] &amp;  \\
 &amp; g \circ f \ar@{|-&gt;}[r] &amp; h \circ g \circ f &amp;  \\
Hom(A&#39;,\ B) \ar@{-&gt;}[rrr]_{Hom(A&#39;,\ h)} &amp;  &amp;  &amp; Hom(A&#39;,\ B&#39;)
}
\]</span></p>
<p>最终得出结论：<span class="math inline">\(g \mapsto h \circ g \circ f : Hom(A,\ B) \to Hom(A&#39;,\ B&#39;)\)</span>，因此该图可交换。</p>
<h2 id="yoneda-lemma">Yoneda Lemma</h2>
<p>在把上述的 hom-set，hom-functor 等概念定义完毕后，现在我们终于可以开始来谈谈何为 Yoneda Lemma 了，首先我们从它的定义开始。</p>
<h3 id="定义-4">定义</h3>
<ol type="1">
<li>设 <span class="math inline">\(C\)</span> 为任意的 locally small category 以及有 category <span class="math inline">\(Set\)</span></li>
<li>固定某个 object <span class="math inline">\(X \in Obj(C)\)</span></li>
<li>Functors：<span class="math inline">\(Hom(X, -) : C \to Set\)</span>，一个任意的 functor <span class="math inline">\(F : C \to Set\)</span></li>
</ol>
<p>而 Yoneda Lemma 所描述的即设有任一的对于 <span class="math inline">\(Hom(X, -)\)</span> 与 <span class="math inline">\(F\)</span> 之间的 natural transformation (自然变换) <span class="math inline">\(\alpha\)</span>，它与 <span class="math inline">\(x \in F(X)\)</span> 即可视为是 isomorphic 的。换句话说即对于集合 <span class="math inline">\(F(X)\)</span>，它必定能够一对一地把 objects 从 <span class="math inline">\(F(X)\)</span> bijection 至 <span class="math inline">\(Hom(Hom(X, -),\ F)\)</span> 集合上的 functor。</p>
<p>米田引理的形式化定义如下：</p>
<p><span class="math display">\[ [C,\ Set](Hom(X, -),\ F) \cong F(X) \]</span></p>
<p>其中 <span class="math inline">\([C,\ Set]\)</span> 是一 functor category (函子范畴)，object 为 functor，morphisms 则为 natural transformations。 有些时候我们也能把 functor category 替换成 <span class="math inline">\(Set\)</span>，其含义是一样的，因此有：</p>
<p><span class="math display">\[ Hom(Hom(X, -),\ F) \cong F(X) \]</span></p>
<h3 id="透过交换图观察米田引理的结构">透过交换图观察米田引理的结构</h3>
<p>由于文字叙述往往不是很直观，因此让我们从交换图的角度来观察一下米田引理：</p>
<p>首先定义 <span class="math inline">\(A, B \in Obj(C)\)</span>，且有态射 <span class="math inline">\(f : A \to B\)</span>，以及一个任意的 object <span class="math inline">\(X\)</span>，因此对于 category <span class="math inline">\(C\)</span>，我们有：</p>
<p><span class="math display">\[
\xymatrix{
X \ar@{--&gt;}[r]^{-} \ar@{--&gt;}[rd]_{f \circ -} &amp; A \ar@{-&gt;}[d]^{f} \\
 &amp; B
}
\]</span></p>
<p>因此对于任意 <span class="math inline">\(X\)</span>，我们可以定义出 morphism <span class="math inline">\(- : X \to A\)</span> 以及 <span class="math inline">\(f \circ - : X \to B\)</span>。</p>
<p>而后考虑到有 functor <span class="math inline">\(Hom(X,\ -) : C \to Set\)</span> 和 <span class="math inline">\(F : C \to Set\)</span>，以及有一自然变换 <span class="math inline">\(\alpha : Hom(X, -) \to F\)</span>，我们能够得出如下图：</p>
<p><span class="math display">\[
\xymatrix{
X \ar@{--&gt;}[r]^{-} \ar@{--&gt;}[rd]_{f \circ -} &amp; A \ar@{-&gt;}[d]^{f} \ar@/^/@{-&gt;}[rrdd]|-{Hom(X,-)} \ar@/^/@{-&gt;}[rrrrdd]|-{F} &amp;  &amp;  &amp;  &amp;  \\
 &amp; B \ar@/^/@{-&gt;}[rrddd]|-{Hom(X,-)} \ar@/^/@{-&gt;}[rrrrddd]|-{F} &amp;  &amp;  &amp;  &amp;  \\
 &amp;  &amp;  &amp; Hom(X,\ A) \ar@{-&gt;}[dd]^{Hom(X,\ f)} \ar@{-&gt;}[rr]^{\alpha_A} &amp;  &amp; F(A) \ar@{-&gt;}[dd]^{F\ f} \\
 &amp;  &amp;  &amp;  &amp;  &amp;  \\
 &amp;  &amp;  &amp; Hom(X,\ B) \ar@{-&gt;}[rr]_{\alpha_B} &amp;  &amp; F(B)
}
\]</span></p>
<p>所以在 category <span class="math inline">\(Set\)</span> 中，有<br> Objects：<span class="math inline">\(Hom(X,\ A), Hom(X,\ B), F(A), F(B)\)</span><br> 作为 Morphisms 的 Functors：<span class="math inline">\(Hom(X,\ f) : Hom(X,\ A) \to Hom(X,\ B)\)</span>，<span class="math inline">\(F\ f : F(A) \to F(B)\)</span><br> 作为 Morphisms 的 Natural transformations：<span class="math inline">\(\alpha_A : Hom(X,\ A) \to F(A)\)</span>，<span class="math inline">\(\alpha_B : Hom(X,\ B) \to F(B)\)</span>。</p>
<p>对于 category <span class="math inline">\(Set\)</span>，由于 <span class="math inline">\((F\ f) \circ \alpha_A = \alpha_B \circ Hom(X,\ f)\)</span>，因此该图可交换。</p>
<h3 id="证明-2">证明</h3>
<p>为了证明米田引理，可以取出 <span class="math inline">\(Hom(X,\ A)\)</span> 中的 identity morphism <span class="math inline">\(id_X\)</span> 作为实例，即 <span class="math inline">\(Hom(X,\ X)\)</span>，所以上图将更变为：</p>
<p><span class="math display">\[
\xymatrix{
X \ar@{--&gt;}[r]^{id} \ar@{--&gt;}[rd] &amp; X \ar@{-&gt;}[d]^{f} \ar@/^/@{-&gt;}[rrdd]|-{Hom(X,-)} \ar@/^1pc/@{-&gt;}[rrrrrdd]|-{F} &amp;  &amp;  &amp;  &amp;  &amp;  \\
 &amp; B \ar@/^/@{-&gt;}[rrdddd]|-{Hom(X,-)} \ar@/^1pc/@{-&gt;}[rrrrrdddd]|-{F} &amp;  &amp;  &amp;  &amp;  &amp;  \\
 &amp;  &amp;  &amp; Hom(X,\ X) \ar@{-&gt;}[ddd]^{Hom(X,\ f)} \ar@{-&gt;}[rrr]^{\alpha_X} &amp;  &amp;  &amp; F(X) \ar@{-&gt;}[ddd]^{F\ f} \\
 &amp;  &amp;  &amp;  &amp; id_X \ar@{-&gt;}[r] \ar@{-&gt;}[d] &amp; u \ar@{-&gt;}[d] &amp;  \\
 &amp;  &amp;  &amp;  &amp; f \ar@{-&gt;}[r] &amp; \alpha_B\ f = (F\ f)\ u &amp;  \\
 &amp;  &amp;  &amp; Hom(X,\ B) \ar@{-&gt;}[rrr]_{\alpha_B} &amp;  &amp;  &amp; F(B)
}
\]</span></p>
<p>其中包含了 <span class="math inline">\(id_X \in Hom(X,\ X)\)</span>，<span class="math inline">\(u \in F(X)\)</span>，<span class="math inline">\(f \in Hom(X,\ B)\)</span> 以及 <span class="math inline">\(\alpha_B\ f \in F(B)\)</span>。</p>
<p>而现在我们要做的仅仅是证出该图中所有的 natural transformation <span class="math inline">\(\alpha\)</span> 与 functor <span class="math inline">\(F\)</span> 之间是 isomorphic 的，因此需要证明出 <span class="math inline">\(toYoneda : \forall X \in C. (\forall \varphi \in C. Hom(X,\ \varphi) \to F(\varphi)) \to F(X)\)</span> 以及 <span class="math inline">\(fromYoneda : \forall X \in C. F(X) \to (\forall \varphi \in C. Hom(X,\ \varphi) \to F(\varphi))\)</span> 这两条路是行得通的，所以最终得出证明：<br></p>
<p>设 <span class="math inline">\(\alpha_\varphi : \forall \varphi. Hom(X,\ \varphi) \to F(\varphi)\)</span>：<br> <span class="math inline">\(toYoneda\)</span>：<span class="math inline">\(id : Hom(\varphi,\ \varphi)\)</span>，有 <span class="math inline">\(\alpha_\varphi\ id = u\)</span><br> <span class="math inline">\(fromYoneda\)</span>：<span class="math inline">\(u : F(\varphi)\)</span>，有 <span class="math inline">\(\alpha_\varphi\ f = (F\ f)\ u\)</span></p>
<p>至此证毕。</p>
<h4 id="于-agda-中的表达">于 Agda 中的表达</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">toYoneda : (C : Category o m) &#123;X : Obj C&#125; &#123;F : Functor C (𝒮ℯ𝓉 m)&#125;</span><br><span class="line">           → [ C , 𝒮ℯ𝓉 m ]⟨ Hom C [ X ,─] , F ⟩</span><br><span class="line">           → Fₒ F X</span><br><span class="line">toYoneda</span><br><span class="line">  record &#123; id = id &#125;</span><br><span class="line">  record &#123; η = η &#125;</span><br><span class="line">  = η id</span><br><span class="line"></span><br><span class="line">fromYoneda : &#123;C : Category o m&#125; &#123;X : Obj C&#125; (F : Functor C (𝒮ℯ𝓉 m))</span><br><span class="line">             → Fₒ F X</span><br><span class="line">             → [ C , 𝒮ℯ𝓉 m ]⟨ Hom C [ X ,─] , F ⟩</span><br><span class="line">fromYoneda</span><br><span class="line">  record &#123; Fₘ = Fₘ &#125;</span><br><span class="line">  u</span><br><span class="line">  = record &#123; η = λ f → (Fₘ f) u &#125;</span><br></pre></td></tr></table></figure>
<p>注：该部分只写出了最终的证明步骤，需要查看详尽的前置定义及源码可移步至 <a href="http://home.e7mc.com:12450/9032676/category-research" target="_blank" rel="noopener">这里</a>。</p>
<h4 id="于-haskell-中表达">于 Haskell 中表达</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">toYoneda :: (forall a. (x -&gt; a) -&gt; f a) -&gt; f x</span><br><span class="line">toYoneda alpha = alpha id</span><br><span class="line"></span><br><span class="line">fromYoneda :: f x -&gt; (forall a. (x -&gt; a) -&gt; f a)</span><br><span class="line">fromYoneda u f = fmap f u</span><br></pre></td></tr></table></figure>
<p>注：该证明被直接翻译为 Haskell 中 category theory 的语义，所以与 agda 中把所有在证明过程中所使用的 concept 全部构造出来是有所区别的。</p>
<h2 id="结语">结语</h2>
<p>至此，Yoneda lemma 证明篇正式完毕，而接下来笔者将会撰写两篇后续的文章，重点讨论 Yoneda embedding (米田嵌入) 与 Continuation passing style (CPS 变换) 的关系，以及 co-Yoneda lemma 的证明。在此感谢各位细心阅览！</p>
<h2 id="外部链接">外部链接</h2>
<p>本文部分内容参考或引用至下列网页，也可供作为额外的延伸资源帮助阅读：</p>
<ul>
<li><a href="https://ncatlab.org/nlab/show/Yoneda+lemma" target="_blank" rel="noopener">Yoneda lemma - nLab</a></li>
<li><a href="https://bartoszmilewski.com/2015/09/01/the-yoneda-lemma/" target="_blank" rel="noopener">The Yoneda Lemma - Bartosz Milewski</a></li>
<li><a href="https://www.youtube.com/watch?v=KaBz45nZEZw" target="_blank" rel="noopener">Category Theory II 4.1: Representable Functors</a></li>
<li><a href="https://www.youtube.com/watch?v=BiWqNdtptDI" target="_blank" rel="noopener">Category Theory II 4.2: The Yoneda Lemma</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2021-03-02T06:05:13.550Z" itemprop="dateUpdated">2021-03-02 14:05:13</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://a9032676.github.io">
            <img src="/img/avatar.jpg" alt="9032676">
            9032676
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/范畴论/">范畴论</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://a9032676.github.io/2021/01/22/Yoneda-Lemma/&title=《Yoneda Lemma 的证明》 — 9032676's Blog&pic=https://a9032676.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://a9032676.github.io/2021/01/22/Yoneda-Lemma/&title=《Yoneda Lemma 的证明》 — 9032676's Blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://a9032676.github.io/2021/01/22/Yoneda-Lemma/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Yoneda Lemma 的证明》 — 9032676's Blog&url=https://a9032676.github.io/2021/01/22/Yoneda-Lemma/&via=https://a9032676.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://a9032676.github.io/2021/01/22/Yoneda-Lemma/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/11/03/Scala-Depedent-Types/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Dotty Scala 上的依赖类型</h4>
      </a>
    </div>
  
</nav>



    

















</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>9032676 &copy; 2018 - 2021</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://a9032676.github.io/2021/01/22/Yoneda-Lemma/&title=《Yoneda Lemma 的证明》 — 9032676's Blog&pic=https://a9032676.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://a9032676.github.io/2021/01/22/Yoneda-Lemma/&title=《Yoneda Lemma 的证明》 — 9032676's Blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://a9032676.github.io/2021/01/22/Yoneda-Lemma/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Yoneda Lemma 的证明》 — 9032676's Blog&url=https://a9032676.github.io/2021/01/22/Yoneda-Lemma/&via=https://a9032676.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://a9032676.github.io/2021/01/22/Yoneda-Lemma/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACOElEQVR42u3aS27DMAwAUd//0uo2QC1nSMoBRI1WRdJYfl7Q4ue68Bofa/b557djsv7/drbX9caSIUPGtozxuGaM+q9mtx7dRYYMGecwngPfc6gl//PlJvC+089lyJAhA186Gl4re8mQIUNG9HKEVyHJkCFDBklHyaFwVUr8Yi4uQ4aMDRm86v77v1/pb8iQIWMrxgiu3BHwOURGg+zNLjJkyGjN4AGOHAejTcrKsU+GDBmnMUi4zBX6eauSF+DCx0QZMmRsziBBMFqy59fPPcSbxyRDhozWjOj2vACXa1jykC1DhozTGPXSWLQMR0p4vKkpQ4aM3gweWKPDEKToz8c4vrwlZMiQ0ZqR2yxcrA8ObfBC2817Q4YMGe0YJLTVg2nlESyoGsqQIWNzRm60Ily9w03TXForQ4aM3ozo8Fa0JJdDloYtZMiQ0Y7B4zEp7vNHE01W0dFQhgwZTRnRW48GZR6Cc4fLK/cGkCFDxoaMenkrd9MkZUWhWYYMGa0ZuZZArkxPmpelvWTIkHEkg7cYKy3PaJFuGqZlyJBxDOONgMgHMl4crZAhQ0YLxqpklR80c21ONHIhQ4aMRowRXDxn5Gktv3LgbCtDhoxGjEqzM3ohHlgrh1QZMmR0ZfCDHUlEK0he/gu/PWTIkNGCkQt8fGiDP6YFubgMGTJkpNqNa5PYi28mQ4aMIxnR5LaeW6MioAwZMg5gVBqQfJAi12BYXG6TIUPGhoxKOWzteFklZMuQIaMp4w/O0tE/hxuXrQAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdn.staticfile.org/MathJax/MathJax-2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"TeX":{"extensions":["AMSmath.js","AMSsymbols.js","https://a9032676.github.io/mathjax_ext/xypic.js"]}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
